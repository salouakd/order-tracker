'use strict';

const ramda = require('ramda');

const templatify = (template) => {
  return template;
};
function l(arg) {
  return arg;
}

const TypeUtils = {
  __proto__: null,
  templatify: templatify,
  l: l
};

function uid(prefix) {
  return prefix + Date.now().toString(36).substring(4) + Math.random().toString(36).substring(2);
}
function partition(predicate) {
  return function(subject) {
    return subject.reduce(
      (acc, val, idx, arr) => {
        acc[predicate(val, idx, arr) ? 0 : 1].push(val);
        return acc;
      },
      [[], []]
    );
  };
}
function toDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.readAsDataURL(file);
  });
}
function deferred(ms) {
  let cancel;
  const promise = new Promise((resolve, reject) => {
    cancel = reject;
    setTimeout(resolve, ms);
  });
  return { promise, cancel };
}
function debounce(closure, ms) {
  let t = { promise: null, cancel: (_ = void 0) => void 0 };
  return [
    async (...args) => {
      try {
        t.cancel();
        t = deferred(ms);
        await t.promise;
        await closure(...args);
      } catch (_) {
      }
    },
    (_ = void 0) => t.cancel()
  ];
}

const MiscUtils = {
  __proto__: null,
  uid: uid,
  partition: partition,
  toDataUrl: toDataUrl,
  debounce: debounce
};

const removeFromArray = (array, index) => {
  return ramda.remove(index, 1, array);
};
const updateArray = (array, index, value) => {
  return ramda.update(index, value, array);
};

const ArrayUtils = {
  __proto__: null,
  removeFromArray: removeFromArray,
  updateArray: updateArray
};

const index$1 = { ...TypeUtils, ...MiscUtils, ...ArrayUtils };

const CLR_BLACK = "#000000";
const CLR_WHITE = "#FFFFFF";
const CLR_OFFWHITE = "#CCD5DB";
const constructAlphaBackdrop = (radius) => {
  const size = radius * 2;
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d", { willReadFrequently: true });
  canvas.width = size;
  canvas.height = size;
  context.fillStyle = CLR_WHITE;
  context.fillRect(0, 0, size, size);
  context.fillStyle = CLR_OFFWHITE;
  context.fillRect(0, 0, radius, radius);
  context.fillRect(radius, radius, radius, radius);
  return canvas;
};
const constructLinearGradient = (context, width, height, color1, color2, direction = "left") => {
  const left = direction === "left";
  const gradient = context.createLinearGradient(
    0,
    0,
    left ? width : 0,
    left ? 0 : height
  );
  gradient.addColorStop(0.01, color1);
  gradient.addColorStop(0.99, color2);
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
};
const constructAlphaGradient = (context, width, height, color1, color2) => {
  const gradient = context.createLinearGradient(
    0,
    0,
    width,
    0
  );
  gradient.addColorStop(0.01, color1);
  gradient.addColorStop(0.99, color2);
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
};
const constructHueGradient = (context, width) => {
  const gradient = context.createLinearGradient(0, 0, width, 0);
  gradient.addColorStop(0, "#FF0000");
  gradient.addColorStop(0.17 * 1, "#FF00FF");
  gradient.addColorStop(0.17 * 2, "#0000FF");
  gradient.addColorStop(0.17 * 3, "#00FFFF");
  gradient.addColorStop(0.17 * 4, "#00FF00");
  gradient.addColorStop(0.17 * 5, "#FFFF00");
  gradient.addColorStop(1, "#FF0000");
  return gradient;
};
const toHex = (value) => {
  const hex = value.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
};
const toDec = (value) => {
  return parseInt(value, 16) || 0;
};
const rgbToHex = ({ r, g, b }) => {
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
};
const rgbaToHex = ({ r, g, b, a }) => {
  const alpha = (a * 255 | 1 << 8).toString(16).slice(1);
  return `#${toHex(r)}${toHex(g)}${toHex(b)}${alpha}`.toUpperCase();
};
const hexToRgb = (hex) => {
  hex = hex.startsWith("#") ? hex.slice(1) : hex;
  return {
    r: toDec(hex.slice(0, 2)),
    g: toDec(hex.slice(2, 4)),
    b: toDec(hex.slice(4, 6))
  };
};
const hexaToRgb = (hex) => {
  hex = hex.startsWith("#") ? hex.slice(1) : hex;
  return {
    r: toDec(hex.slice(0, 2)),
    g: toDec(hex.slice(2, 4)),
    b: toDec(hex.slice(4, 6)),
    a: +(parseInt(hex.substring(6, 8), 16) / 255).toFixed(2)
  };
};
const parseRgbString = (value) => {
  const rgba = (/rgba?\((.*?)\)/.exec(value) || ["", "0,0,0,1"])[1].split(",");
  return {
    r: Number(rgba[0]) || 0,
    g: Number(rgba[1]) || 0,
    b: Number(rgba[2]) || 0,
    a: Number(rgba[3] ?? 1)
  };
};
const rgbToHsv = (rgb) => {
  const { r, g, b } = {
    r: rgb.r / 255,
    g: rgb.g / 255,
    b: rgb.b / 255
  };
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;
  let h = 0;
  if (max === min) {
    h = 0;
  } else if (max === r) {
    if (g >= b) {
      h = 60 * (g - b) / delta;
    } else {
      h = 60 * (g - b) / delta + 360;
    }
  } else if (max === g) {
    h = 60 * (b - r) / delta + 120;
  } else if (max === b) {
    h = 60 * (r - g) / delta + 240;
  }
  h = Math.floor(h);
  const s = parseFloat((max === 0 ? 0 : 1 - min / max).toFixed(2));
  const v = parseFloat(max.toFixed(2));
  return { h, s, v };
};
const parseColor = (color, alpha = 1) => {
  let rgba = { r: 0, g: 0, b: 0, a: alpha };
  if (/^#[a-zA-Z0-9]{1,6}$/.test(color)) {
    rgba = { ...hexToRgb(color), a: alpha };
  } else if (/^#[a-zA-Z0-9]{1,8}$/.test(color)) {
    rgba = { ...hexaToRgb(color) };
  } else if (/rgb/.test(color)) {
    rgba = parseRgbString(color);
  } else if (ramda.is(String)(color)) {
    rgba = parseRgbString(`rgba(${color})`);
  } else if (ramda.is(Object)(color)) {
    const a = "a" in color ? color.a : alpha;
    rgba = l({ ...color, a });
  }
  const hsv = rgbToHsv(rgba);
  return { ...rgba, ...hsv, a: rgba.a ?? alpha };
};

const getDaysInMonth = (date) => {
  return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
};
const getDaysBeforeMonth = (date, daysBefore) => {
  const lastDayOfPreviousMonth = new Date(date.getFullYear(), date.getMonth(), 0);
  return [...Array(daysBefore)].map(
    (_, i) => new Date(lastDayOfPreviousMonth.getFullYear(), lastDayOfPreviousMonth.getMonth(), lastDayOfPreviousMonth.getDate() - i)
  ).reverse();
};
const getDaysAfterMonth = (date, daysAfter) => {
  const firstDayOfNextMonth = new Date(date.getFullYear(), date.getMonth() + 1, 1);
  return [...Array(daysAfter)].map(
    (_, i) => new Date(firstDayOfNextMonth.getFullYear(), firstDayOfNextMonth.getMonth(), firstDayOfNextMonth.getDate() + i)
  );
};
const getDaysInMonthArray = (date) => {
  return [...Array(getDaysInMonth(date))].map(
    (_, i) => new Date(date.getFullYear(), date.getMonth(), i + 1)
  );
};
const addStatusToDays = (today, days) => {
  return days.map(
    (day) => ({
      date: day,
      isToday: day.toDateString() === new Date().toDateString(),
      inCurrentMonth: day.getMonth() === today.getMonth()
    })
  );
};
const weekDays = () => {
  return [...Array(7)].map(
    (_, i) => new Date(2021, 0, 4 + i)
  );
};
const getDaysForDateMonthCycle = (date) => {
  const daysInMonth = getDaysInMonth(date);
  const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
  const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth(), daysInMonth);
  const firstDayOfWeek = firstDayOfMonth.getDay();
  const lastDayOfWeek = lastDayOfMonth.getDay();
  const daysBefore = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  const daysAfter = lastDayOfWeek === 0 ? 0 : 7 - lastDayOfWeek;
  const daysBeforeMonth = getDaysBeforeMonth(date, daysBefore);
  const daysAfterMonth = getDaysAfterMonth(date, daysAfter);
  return [...addStatusToDays(date, daysBeforeMonth), ...addStatusToDays(date, getDaysInMonthArray(date)), ...addStatusToDays(date, daysAfterMonth)];
};
const getAlphabeticalWeekday = (date, format = "short") => {
  return Intl.DateTimeFormat("en-US", { weekday: format }).format(date);
};
const getAlphabeticalMonth = (date, format = "long") => {
  return Intl.DateTimeFormat("en-US", { month: format }).format(date);
};
const isSameDay = (a, b) => {
  return a.toDateString() === b.toDateString();
};
const isBetween = (date, start, end) => {
  return date > start && date < end;
};
const biggerThan = (a, b) => {
  return a >= b;
};
const getCalendarDay = (date, label) => {
  if (!date) {
    return label;
  }
  return date.toLocaleString().split(",")[0];
};

const DateUtils = {
  __proto__: null,
  weekDays: weekDays,
  getDaysForDateMonthCycle: getDaysForDateMonthCycle,
  getAlphabeticalWeekday: getAlphabeticalWeekday,
  getAlphabeticalMonth: getAlphabeticalMonth,
  isSameDay: isSameDay,
  isBetween: isBetween,
  biggerThan: biggerThan,
  getCalendarDay: getCalendarDay
};

const index = { ...DateUtils };

exports.CLR_BLACK = CLR_BLACK;
exports.CLR_OFFWHITE = CLR_OFFWHITE;
exports.CLR_WHITE = CLR_WHITE;
exports.DateUtils = index;
exports.Utils = index$1;
exports.constructAlphaBackdrop = constructAlphaBackdrop;
exports.constructAlphaGradient = constructAlphaGradient;
exports.constructHueGradient = constructHueGradient;
exports.constructLinearGradient = constructLinearGradient;
exports.debounce = debounce;
exports.hexToRgb = hexToRgb;
exports.hexaToRgb = hexaToRgb;
exports.l = l;
exports.parseColor = parseColor;
exports.parseRgbString = parseRgbString;
exports.partition = partition;
exports.removeFromArray = removeFromArray;
exports.rgbToHex = rgbToHex;
exports.rgbToHsv = rgbToHsv;
exports.rgbaToHex = rgbaToHex;
exports.templatify = templatify;
exports.toDataUrl = toDataUrl;
exports.toDec = toDec;
exports.toHex = toHex;
exports.uid = uid;
exports.updateArray = updateArray;
