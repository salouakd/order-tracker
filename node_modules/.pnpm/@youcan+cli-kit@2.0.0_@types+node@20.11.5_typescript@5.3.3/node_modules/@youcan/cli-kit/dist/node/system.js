import { execa } from 'execa';
import tpu from 'tcp-port-used';
import findProcess from 'find-process';

function buildExec(command, args, options) {
    const env = options?.env ?? process.env;
    const commandProcess = execa(command, args, {
        env,
        cwd: options?.cwd,
        input: options?.input,
        stdio: options?.stdio,
        stdin: options?.stdin,
        stdout: options?.stdout === 'inherit' ? 'inherit' : undefined,
        stderr: options?.stderr === 'inherit' ? 'inherit' : undefined,
        windowsHide: false,
    });
    return commandProcess;
}
async function exec(command, args, options) {
    const commandProcess = buildExec(command, args, options);
    if (options?.stderr && options.stderr !== 'inherit') {
        commandProcess.stderr?.pipe(options.stderr, { end: false });
    }
    if (options?.stdout && options.stdout !== 'inherit') {
        commandProcess.stdout?.pipe(options.stdout, { end: false });
    }
    let aborted = false;
    options?.signal?.addEventListener('abort', () => {
        const pid = commandProcess.pid;
        if (pid) {
            aborted = true;
        }
    });
    try {
        await commandProcess;
    }
    catch (err) {
        if (aborted) {
            return;
        }
        if (options?.errorHandler) {
            await options?.errorHandler(err);
            return;
        }
        throw err;
    }
}
async function isPortAvailable(port) {
    return !await tpu.check(port);
}
async function getPortProcessName(port) {
    const info = await findProcess('port', port);
    return (info && info.length > 0) ? `(${info[0]?.name})` : '';
}
async function killPortProcess(port) {
    const { killPortProcess: kill } = await import('kill-port-process');
    await kill(port);
}
async function open(url) {
    const _open = await import('open');
    await _open.default(url);
}

export { exec, getPortProcessName, isPortAvailable, killPortProcess, open };
