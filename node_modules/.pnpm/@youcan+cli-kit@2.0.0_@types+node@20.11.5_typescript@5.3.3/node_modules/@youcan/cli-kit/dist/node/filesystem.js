import FilesystemPromises from 'node:fs/promises';
import { createWriteStream } from 'node:fs';
import { temporaryDirectoryTask } from 'tempy';
import FsExtra from 'fs-extra';
import archiver from 'archiver';
import chokidar from 'chokidar';
import './cli.js';
import 'simple-git';
import 'execa';
import 'tcp-port-used';
import 'find-process';
import 'env-paths';
import { resolve } from './path.js';
import 'node-fetch';
import 'ramda';
import 'change-case';
import 'formdata-node';
import 'formdata-node/file-from-path';
import 'kleur';
import 'conf';
import 'dayjs';

async function exists(path) {
    try {
        await FilesystemPromises.access(path);
        return true;
    }
    catch {
        return false;
    }
}
async function tapIntoTmp(callback) {
    return temporaryDirectoryTask(callback);
}
async function mkdir(path) {
    await FilesystemPromises.mkdir(path, { recursive: true });
}
async function move(src, dest, options = {}) {
    await FsExtra.move(src, dest, options);
}
async function readFile(path, options = { encoding: 'utf-8', flag: 'r' }) {
    return await FilesystemPromises.readFile(path, options);
}
async function writeFile(path, data, options = { encoding: 'utf-8', flag: 'w' }) {
    return await FilesystemPromises.writeFile(path, data, options);
}
async function readJsonFile(path) {
    const file = await readFile(path);
    return JSON.parse(file instanceof Buffer ? file.toString() : file);
}
async function writeJsonFile(path, data) {
    return writeFile(path, JSON.stringify(data, null, 4));
}
async function glob(pattern, options) {
    const { default: _glob } = await import('fast-glob');
    let _options = options;
    if (options?.dot == null) {
        _options = { ...options, dot: true };
    }
    return _glob(pattern, _options);
}
async function archived(path$1, name, glob = '**/*') {
    return new Promise((resolve$1, reject) => {
        try {
            const archivePath = resolve(path$1, `${name}.zip`);
            const output = createWriteStream(archivePath);
            const _archiver = archiver('zip', { zlib: { level: 9 } });
            output.on('close', () => resolve$1(archivePath));
            _archiver.on('error', () => (err) => reject(err));
            _archiver.pipe(output);
            _archiver.glob(glob, {
                ignore: [`${name}.zip`],
                cwd: path$1,
            });
            _archiver.finalize();
        }
        catch (err) {
            reject(err);
        }
    });
}
async function unlink(path) {
    if (await exists(path)) {
        await FilesystemPromises.unlink(path);
    }
}
async function readdir(path) {
    return await FilesystemPromises.readdir(path);
}
async function stat(path) {
    return await FilesystemPromises.stat(path);
}
const watch = chokidar.watch;

export { archived, exists, glob, mkdir, move, readFile, readJsonFile, readdir, stat, tapIntoTmp, unlink, watch, writeFile, writeJsonFile };
