import { Worker, Color, Http, Env, System, Path, Filesystem, Crypto, Form } from '@youcan/cli-kit';
import { Server } from 'socket.io';
import debounce from 'debounce';

class ThemeWorker extends Worker.Abstract {
    command;
    store;
    theme;
    logger;
    previewLogger;
    queue = [];
    io;
    FILE_TYPES = [
        'layouts',
        'sections',
        'locales',
        'assets',
        'snippets',
        'config',
        'templates',
    ];
    constructor(command, store, theme) {
        super();
        this.command = command;
        this.store = store;
        this.theme = theme;
        this.logger = new Worker.Logger('stdout', 'themes', Color.magenta);
        this.previewLogger = new Worker.Logger('stdout', 'preview', Color.dim);
    }
    async boot() {
        try {
            const res = await Http.get(`${Env.apiHostname()}/themes/${this.theme.theme_id}/metadata`);
            this.theme.metadata = res;
            this.io = new Server(7565, {
                cors: {
                    origin: `${Http.scheme()}://${this.store.domain}`,
                    methods: ['GET', 'POST'],
                },
            });
            this.io.on('connection', (socket) => {
                this.previewLogger.write(`attached to preview page at ${socket.handshake.address}`);
            });
            System.open(`${Http.scheme()}://${this.store.domain}/themes/${this.theme.theme_id}/preview`);
        }
        catch (err) {
            this.command.error(err);
        }
    }
    async run() {
        this.logger.write(`pushing changes to ${this.theme.metadata.theme_name}...`);
        for (const type of this.FILE_TYPES) {
            const descriptors = this.theme.metadata[type] ?? [];
            const directory = Path.resolve(this.theme.root, type);
            const present = await Filesystem.exists(directory)
                ? await Filesystem.readdir(directory)
                : [];
            if (type === 'config') {
                const order = ['settings_schema.json', 'settings_data.json'];
                descriptors.sort((a, b) => order.indexOf(a.file_name) - order.indexOf(b.file_name));
            }
            present.filter(f => !descriptors.find(d => d.file_name === f))
                .forEach(async (file) => this.enqueue('save', type, file));
            descriptors.forEach(async (descriptor) => {
                const path = Path.resolve(directory, descriptor.file_name);
                if (!(await Filesystem.exists(path))) {
                    return this.enqueue('delete', type, descriptor.file_name);
                }
                const buffer = await Filesystem.readFile(path);
                const hash = Crypto.sha1(buffer);
                if (hash !== descriptor.hash) {
                    this.enqueue('save', type, descriptor.file_name);
                }
            });
        }
        const directories = this.FILE_TYPES.map(t => Path.resolve(this.theme.root, t));
        const watcher = Filesystem.watch(directories, {
            awaitWriteFinish: { stabilityThreshold: 50 },
            ignoreInitial: true,
            persistent: true,
        });
        this.command.controller.signal.addEventListener('abort', () => {
            watcher.close();
        });
        watcher.on('all', async (event, path) => {
            if (!['add', 'change', 'unlink'].includes(event)) {
                return;
            }
            const [filetype, filename] = [
                Path.basename(Path.dirname(path)),
                Path.basename(path),
            ];
            switch (event) {
                case 'add':
                case 'change':
                    this.enqueue('save', filetype, filename);
                    break;
                case 'unlink':
                    this.enqueue('delete', filetype, filename);
                    break;
            }
        });
        // quick racing conditions hack
        setInterval(async () => {
            const task = this.queue.shift();
            if (task == null) {
                return;
            }
            await task();
        }, 10);
    }
    enqueue(op, type, name) {
        this.queue.push(async () => {
            try {
                const path = Path.join(this.theme.root, type, name);
                await Http.post(`${Env.apiHostname()}/themes/${this.theme.theme_id}/update`, {
                    body: Form.convert({
                        file_name: name,
                        file_type: type,
                        file_operation: op,
                        file_content: op === 'save'
                            ? await Form.file(path)
                            : undefined,
                    }),
                });
                this.logger.write(`[${op === 'save' ? 'updated' : 'deleted'}] - ${Path.join(type, name)}`);
                debounce(() => {
                    this.io.emit('theme:update');
                    this.previewLogger.write('reloading preview...');
                }, 100)();
            }
            catch (err) {
                if (err instanceof Error) {
                    this.logger.write(`[error] - ${Path.join(type, name)}\n${err.message}`);
                }
            }
        });
    }
}

export { ThemeWorker as default };
