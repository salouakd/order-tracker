import { getCurrentScope as pS, onScopeDispose as hS, unref as X, watch as En, defineComponent as K, computed as ue, openBlock as E, createElementBlock as F, createBlock as ge, createCommentVNode as ne, createElementVNode as O, normalizeClass as de, toDisplayString as re, renderSlot as fe, ref as G, nextTick as Ks, withDirectives as yt, vModelText as _a, Fragment as ze, renderList as Je, withCtx as ee, normalizeProps as $l, guardReactiveProps as Ll, createVNode as ce, useSlots as Kt, mergeProps as Mn, createSlots as Fr, pushScopeId as Ye, popScopeId as Xe, watchEffect as Xv, normalizeStyle as Tn, vModelCheckbox as mS, useAttrs as gf, onBeforeMount as vf, vModelDynamic as gS, onUnmounted as po, useCssVars as Zn, onMounted as bt, withModifiers as ki, vShow as Kn, onUpdated as vS, createTextVNode as nn, Teleport as Zv, Transition as eo, resolveComponent as yS, resolveDynamicComponent as bS, toHandlers as Zc, shallowRef as Od, toRaw as Fd, h as Gn, vModelRadio as Qv, onBeforeUnmount as wa, getCurrentInstance as _S, reactive as e0, markRaw as wS, customRef as DS, withKeys as CS } from "vue";
const Du = typeof window < "u", xS = (n) => typeof n == "string", kS = () => {
};
function SS(n) {
  return typeof n == "function" ? n() : X(n);
}
function AS(n) {
  return n;
}
function ES(n) {
  return pS() ? (hS(n), !0) : !1;
}
function Go(n) {
  var e;
  const t = SS(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const t0 = Du ? window : void 0;
Du && window.document;
Du && window.navigator;
Du && window.location;
function gl(...n) {
  let e, t, r, i;
  if (xS(n[0]) || Array.isArray(n[0]) ? ([t, r, i] = n, e = t0) : [e, t, r, i] = n, !e)
    return kS;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((f) => f()), s.length = 0;
  }, l = (f, h, m) => (f.addEventListener(h, m, i), () => f.removeEventListener(h, m, i)), u = En(() => Go(e), (f) => {
    o(), f && s.push(...t.flatMap((h) => r.map((m) => l(f, h, m))));
  }, { immediate: !0, flush: "post" }), d = () => {
    u(), o();
  };
  return ES(d), d;
}
function mr(n, e, t = {}) {
  const { window: r = t0, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = t;
  if (!r)
    return;
  let l = !0, u;
  const d = (g) => i.some((y) => {
    if (typeof y == "string")
      return Array.from(r.document.querySelectorAll(y)).some((b) => b === g.target || g.composedPath().includes(b));
    {
      const b = Go(y);
      return b && (g.target === b || g.composedPath().includes(b));
    }
  }), f = (g) => {
    r.clearTimeout(u);
    const y = Go(n);
    if (!(!y || y === g.target || g.composedPath().includes(y))) {
      if (g.detail === 0 && (l = !d(g)), !l) {
        l = !0;
        return;
      }
      e(g);
    }
  }, h = [
    gl(r, "click", f, { passive: !0, capture: s }),
    gl(r, "pointerdown", (g) => {
      const y = Go(n);
      y && (l = !g.composedPath().includes(y) && !d(g));
    }, { passive: !0 }),
    gl(r, "pointerup", (g) => {
      if (g.button === 0) {
        const y = g.composedPath();
        g.composedPath = () => y, u = r.setTimeout(() => f(g), 50);
      }
    }, { passive: !0 }),
    o && gl(r, "blur", (g) => {
      var y;
      const b = Go(n);
      ((y = r.document.activeElement) == null ? void 0 : y.tagName) === "IFRAME" && !(b != null && b.contains(r.document.activeElement)) && e(g);
    })
  ].filter(Boolean);
  return () => h.forEach((g) => g());
}
const $m = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Lm = "__vueuse_ssr_handlers__";
$m[Lm] = $m[Lm] || {};
var Pm;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(Pm || (Pm = {}));
var TS = Object.defineProperty, zm = Object.getOwnPropertySymbols, MS = Object.prototype.hasOwnProperty, OS = Object.prototype.propertyIsEnumerable, Vm = (n, e, t) => e in n ? TS(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, FS = (n, e) => {
  for (var t in e || (e = {}))
    MS.call(e, t) && Vm(n, t, e[t]);
  if (zm)
    for (var t of zm(e))
      OS.call(e, t) && Vm(n, t, e[t]);
  return n;
};
const IS = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
FS({
  linear: AS
}, IS);
const RS = {
  key: 1,
  class: "preview"
}, NS = { class: "label" }, BS = /* @__PURE__ */ K({
  __name: "DropdownItem",
  props: {
    selected: { type: Boolean },
    checkbox: { type: Boolean, default: !1 },
    item: {}
  },
  emits: ["toggle"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.selected,
      set: (o) => r("toggle", o)
    });
    function s(o) {
      o.preventDefault(), i.value = !i.value;
    }
    return (o, l) => (E(), F("button", {
      role: "button",
      class: "item",
      onClick: l[1] || (l[1] = (u) => s(u))
    }, [
      o.checkbox ? (E(), ge(X(ho), {
        key: 0,
        modelValue: i.value,
        "onUpdate:modelValue": l[0] || (l[0] = (u) => i.value = u),
        tabindex: "-1",
        class: "checkbox"
      }, null, 8, ["modelValue"])) : ne("", !0),
      o.item.image || o.item.icon ? (E(), F("div", RS, [
        o.item.image ? (E(), ge(X(mo), {
          key: 0,
          size: "small",
          src: o.item.image,
          alt: o.item.label,
          class: "preview-image"
        }, null, 8, ["src", "alt"])) : ne("", !0),
        O("i", {
          class: de(["preview-icon", [o.item.icon]])
        }, null, 2)
      ])) : ne("", !0),
      O("div", NS, re(o.item.label), 1),
      fe(o.$slots, "default", {}, void 0, !0)
    ]));
  }
});
const J = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, i] of e)
    t[r] = i;
  return t;
}, Hm = /* @__PURE__ */ J(BS, [["__scopeId", "data-v-8b4493af"]]);
function Wm(n, e) {
  return n == null ? void 0 : n.toLowerCase().includes(e.toLowerCase());
}
function $S(n, e = {}) {
  return n ? Array.isArray(e) ? e.filter((t) => Wm(t.label, n)) : Object.fromEntries(
    Object.entries(e).map(([t, r]) => [
      t,
      r.filter((i) => Wm(i.label, n))
    ]).filter(([, t]) => t.length)
  ) : e;
}
const LS = {
  key: 0,
  class: "search"
}, PS = { class: "title" }, zS = { class: "array-list" }, VS = {
  key: 2,
  class: "no-results"
}, HS = {
  key: 3,
  class: "loading"
}, WS = /* @__PURE__ */ K({
  __name: "DropdownList",
  props: {
    selected: {},
    items: {},
    searchable: { type: Boolean, default: !1 },
    loading: { type: Boolean },
    multiple: { type: Boolean, default: !1 },
    show: { type: Boolean },
    searchHandler: { type: Function, default: $S }
  },
  emits: ["toggle", "select", "scrollEnd"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(""), s = G(), o = ue({
      get: () => i.value,
      set: (h) => {
        i.value = h.trim(), t.searchHandler(h.trim(), t.items);
      }
    }), l = ue(() => {
      const h = t.searchHandler(o.value.trim(), t.items);
      return Array.isArray(h) ? h : t.items;
    });
    function u(h) {
      return t.selected == null ? !1 : Array.isArray(t.selected) ? !!t.selected.find((m) => m.value === h.value) : t.selected.value === h.value;
    }
    function d(h, m) {
      if (t.multiple)
        return r("toggle", h, m);
      m && r("select", h);
    }
    const f = async (h) => {
      const m = h.target, g = m.scrollHeight, y = m.scrollTop, b = m.clientHeight;
      y + b >= g && r("scrollEnd");
    };
    return En(() => t.show, (h) => {
      h && s.value && Ks(() => {
        s.value.focus();
      });
    }), (h, m) => (E(), F("div", {
      class: de([{ searchable: h.searchable }, "dropdown-list"])
    }, [
      h.searchable ? (E(), F("div", LS, [
        yt(O("input", {
          ref_key: "searchInput",
          ref: s,
          "onUpdate:modelValue": m[0] || (m[0] = (g) => o.value = g),
          type: "text",
          placeholder: "Search.."
        }, null, 512), [
          [_a, o.value]
        ])
      ])) : ne("", !0),
      O("div", {
        class: "inner",
        onScroll: f
      }, [
        Array.isArray(l.value) ? (E(!0), F(ze, { key: 0 }, Je(l.value, (g) => (E(), ge(Hm, {
          key: g.value,
          checkbox: h.multiple,
          item: g,
          selected: u(g),
          onToggle: (y) => d(g, y)
        }, {
          default: ee(() => [
            fe(h.$slots, "accessory", $l(Ll(g)), void 0, !0)
          ]),
          _: 2
        }, 1032, ["checkbox", "item", "selected", "onToggle"]))), 128)) : Object.entries(l.value).length ? (E(!0), F(ze, { key: 1 }, Je(Object.entries(l.value), ([g, y]) => (E(), F("div", { key: g }, [
          O("div", PS, re(g), 1),
          O("div", zS, [
            (E(!0), F(ze, null, Je(y, (b) => (E(), ge(Hm, {
              key: b.value,
              checkbox: h.multiple,
              selected: u(b),
              item: b,
              onToggle: (w) => d(b, w)
            }, {
              default: ee(() => [
                fe(h.$slots, "accessory", $l(Ll(b)), void 0, !0)
              ]),
              _: 2
            }, 1032, ["checkbox", "selected", "item", "onToggle"]))), 128))
          ])
        ]))), 128)) : (E(), F("div", VS, " No results were found ")),
        h.loading ? (E(), F("div", HS, [
          ce(X(cp), { size: "15px" })
        ])) : ne("", !0)
      ], 32)
    ], 2));
  }
});
const Cu = /* @__PURE__ */ J(WS, [["__scopeId", "data-v-53505dd7"]]), US = (n) => (Ye("data-v-267d33e4"), n = n(), Xe(), n), jS = { class: "dropdown" }, qS = { class: "label" }, KS = /* @__PURE__ */ US(() => /* @__PURE__ */ O("i", { class: "chevron i-youcan-carret-down" }, null, -1)), GS = /* @__PURE__ */ K({
  __name: "Dropdown",
  props: {
    size: { default: 36 },
    icon: {},
    placeholder: {},
    searchable: { type: Boolean, default: !1 },
    modelValue: {},
    items: {},
    disabled: { type: Boolean, default: !1 },
    loading: { type: Boolean },
    searchHandler: {}
  },
  emits: ["update:modelValue", "scrollEnd"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Kt(), s = G(), o = G(), l = G(!1), u = G(!1), d = (h = !l.value) => {
      s.value.classList.remove("dropdown-top");
      const m = s.value.getBoundingClientRect();
      m && (u.value = m.bottom > window.innerHeight), l.value = h;
    };
    mr(s, () => d(!1), { ignore: [o] });
    const f = ue({
      get: () => t.modelValue,
      set: (h) => {
        d(!1), r("update:modelValue", h);
      }
    });
    return (h, m) => {
      var g;
      return E(), F("div", jS, [
        O("button", {
          ref_key: "button",
          ref: o,
          type: "button",
          class: de([[{ disabled: h.disabled }, `size-${h.size}`], "dropdown-input"]),
          onClick: m[0] || (m[0] = () => d())
        }, [
          h.icon ? (E(), F("i", {
            key: 0,
            class: de(["icon", h.icon])
          }, null, 2)) : ne("", !0),
          O("span", qS, re(((g = f.value) == null ? void 0 : g.label) ?? h.placeholder), 1),
          KS
        ], 2),
        O("div", {
          ref_key: "list",
          ref: s,
          class: de([{ "dropdown-show": l.value && !h.disabled, "dropdown-top": u.value }, "dropdown-wrapper"])
        }, [
          ce(Cu, Mn({ "search-handler": h.searchHandler }, { items: h.items, searchable: h.searchable, selected: h.modelValue, multiple: !1 }, {
            show: l.value,
            loading: h.loading,
            onScrollEnd: m[1] || (m[1] = () => r("scrollEnd")),
            onSelect: m[2] || (m[2] = (y) => f.value = y)
          }), Fr({ _: 2 }, [
            X(i).accessory ? {
              name: "accessory",
              fn: ee((y) => [
                fe(h.$slots, "accessory", $l(Ll(y)), void 0, !0)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["search-handler", "show", "loading"])
        ], 2)
      ]);
    };
  }
});
const n0 = /* @__PURE__ */ J(GS, [["__scopeId", "data-v-267d33e4"]]);
const JS = {}, r0 = (n) => (Ye("data-v-043001b0"), n = n(), Xe(), n), YS = { class: "note" }, XS = { class: "icon" }, ZS = /* @__PURE__ */ r0(() => /* @__PURE__ */ O("i", { class: "icon i-tabler-mail-opened" }, null, -1)), QS = { class: "content" }, eA = /* @__PURE__ */ r0(() => /* @__PURE__ */ O("p", null, "Don't forget to check your inbox, we have sent a link to verify your account.", -1));
function tA(n, e) {
  return E(), F("div", YS, [
    O("div", XS, [
      fe(n.$slots, "icon", { class: "icon" }, () => [
        ZS
      ], !0)
    ]),
    O("div", QS, [
      fe(n.$slots, "content", {}, () => [
        eA
      ], !0)
    ])
  ]);
}
const nA = /* @__PURE__ */ J(JS, [["render", tA], ["__scopeId", "data-v-043001b0"]]), rA = (n) => (Ye("data-v-ed5a662e"), n = n(), Xe(), n), iA = { class: "loading" }, sA = {
  class: "loading-svg",
  viewBox: "0 0 100 100"
}, oA = /* @__PURE__ */ rA(() => /* @__PURE__ */ O("circle", {
  class: "loading-circle",
  cx: "50",
  cy: "50",
  r: "45"
}, null, -1)), aA = { class: "loading-value" }, lA = /* @__PURE__ */ K({
  __name: "Loading",
  props: {
    duration: { default: 12e3 }
  },
  emits: ["complete"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(0), s = G(!1), o = ue(() => ({
      strokeDashoffset: `${(100 - i.value) * 2.64}px`,
      transition: s.value ? "all 0.1s ease" : "none"
    }));
    return En(t, () => {
      i.value = 0, s.value = !0;
    }), Xv(() => {
      const l = t.duration, u = l / 100, d = 100 / (l / u);
      let f = 0;
      s.value = !0;
      const h = setInterval(() => {
        f += d, i.value = f, f >= 100 && (clearInterval(h), s.value = !1, r("complete"));
      }, u);
      return () => clearInterval(h);
    }), (l, u) => (E(), F("div", iA, [
      (E(), F("svg", sA, [
        oA,
        O("circle", {
          class: "loading-circle-progress",
          style: Tn(o.value),
          cx: "50",
          cy: "50",
          r: "45"
        }, null, 4)
      ])),
      O("div", aA, re(`${i.value}%`), 1)
    ]));
  }
});
const uA = /* @__PURE__ */ J(lA, [["__scopeId", "data-v-ed5a662e"]]);
function lt(n) {
  return n != null && typeof n == "object" && n["@@functional/placeholder"] === !0;
}
function yi(n) {
  return function e(t) {
    return arguments.length === 0 || lt(t) ? e : n.apply(this, arguments);
  };
}
function qi(n) {
  return function e(t, r) {
    switch (arguments.length) {
      case 0:
        return e;
      case 1:
        return lt(t) ? e : yi(function(i) {
          return n(t, i);
        });
      default:
        return lt(t) && lt(r) ? e : lt(t) ? yi(function(i) {
          return n(i, r);
        }) : lt(r) ? yi(function(i) {
          return n(t, i);
        }) : n(t, r);
    }
  };
}
function cA(n, e) {
  n = n || [], e = e || [];
  var t, r = n.length, i = e.length, s = [];
  for (t = 0; t < r; )
    s[s.length] = n[t], t += 1;
  for (t = 0; t < i; )
    s[s.length] = e[t], t += 1;
  return s;
}
function yf(n) {
  return function e(t, r, i) {
    switch (arguments.length) {
      case 0:
        return e;
      case 1:
        return lt(t) ? e : qi(function(s, o) {
          return n(t, s, o);
        });
      case 2:
        return lt(t) && lt(r) ? e : lt(t) ? qi(function(s, o) {
          return n(s, r, o);
        }) : lt(r) ? qi(function(s, o) {
          return n(t, s, o);
        }) : yi(function(s) {
          return n(t, r, s);
        });
      default:
        return lt(t) && lt(r) && lt(i) ? e : lt(t) && lt(r) ? qi(function(s, o) {
          return n(s, o, i);
        }) : lt(t) && lt(i) ? qi(function(s, o) {
          return n(s, r, o);
        }) : lt(r) && lt(i) ? qi(function(s, o) {
          return n(t, s, o);
        }) : lt(t) ? yi(function(s) {
          return n(s, r, i);
        }) : lt(r) ? yi(function(s) {
          return n(t, s, i);
        }) : lt(i) ? yi(function(s) {
          return n(t, r, s);
        }) : n(t, r, i);
    }
  };
}
var dA = /* @__PURE__ */ yf(function(e, t, r) {
  var i = r.length;
  if (e >= i || e < -i)
    return r;
  var s = (i + e) % i, o = cA(r);
  return o[s] = t(r[s]), o;
});
const fA = dA;
var pA = /* @__PURE__ */ yi(function(e) {
  return function() {
    return e;
  };
});
const hA = pA;
var mA = /* @__PURE__ */ yf(function(e, t, r) {
  var i = Array.prototype.slice.call(r, 0);
  return i.splice(e, t), i;
});
const gA = mA;
var vA = /* @__PURE__ */ qi(function(e, t) {
  return t instanceof e || t != null && (t.constructor === e || e.name === "Object" && typeof t == "object");
});
const Um = vA;
var yA = /* @__PURE__ */ yf(function(e, t, r) {
  return fA(e, hA(t), r);
});
const bA = yA, _A = (n) => n;
function wA(n) {
  return n;
}
const DA = {
  __proto__: null,
  templatify: _A,
  l: wA
};
function CA(n) {
  return n + Date.now().toString(36).substring(4) + Math.random().toString(36).substring(2);
}
function xA(n) {
  return function(e) {
    return e.reduce(
      (t, r, i, s) => (t[n(r, i, s) ? 0 : 1].push(r), t),
      [[], []]
    );
  };
}
function kA(n) {
  return new Promise((e, t) => {
    const r = new FileReader();
    r.onerror = t, r.onload = () => {
      e(r.result);
    }, r.readAsDataURL(n);
  });
}
function SA(n) {
  let e;
  return { promise: new Promise((r, i) => {
    e = i, setTimeout(r, n);
  }), cancel: e };
}
function AA(n, e) {
  let t = { promise: null, cancel: (r = void 0) => {
  } };
  return [
    async (...r) => {
      try {
        t.cancel(), t = SA(e), await t.promise, await n(...r);
      } catch {
      }
    },
    (r = void 0) => t.cancel()
  ];
}
const EA = {
  __proto__: null,
  uid: CA,
  partition: xA,
  toDataUrl: kA,
  debounce: AA
}, TA = (n, e) => gA(e, 1, n), MA = (n, e, t) => bA(e, t, n), OA = {
  __proto__: null,
  removeFromArray: TA,
  updateArray: MA
}, pr = { ...DA, ...EA, ...OA }, i0 = "#000000", xu = "#FFFFFF", FA = "#CCD5DB", bf = (n) => {
  const e = n * 2, t = document.createElement("canvas"), r = t.getContext("2d", { willReadFrequently: !0 });
  return t.width = e, t.height = e, r.fillStyle = xu, r.fillRect(0, 0, e, e), r.fillStyle = FA, r.fillRect(0, 0, n, n), r.fillRect(n, n, n, n), t;
}, jm = (n, e, t, r, i, s = "left") => {
  const o = s === "left", l = n.createLinearGradient(
    0,
    0,
    o ? e : 0,
    o ? 0 : t
  );
  l.addColorStop(0.01, r), l.addColorStop(0.99, i), n.fillStyle = l, n.fillRect(0, 0, e, t);
}, IA = (n, e, t, r, i) => {
  const s = n.createLinearGradient(
    0,
    0,
    e,
    0
  );
  s.addColorStop(0.01, r), s.addColorStop(0.99, i), n.fillStyle = s, n.fillRect(0, 0, e, t);
}, RA = (n, e) => {
  const t = n.createLinearGradient(0, 0, e, 0);
  return t.addColorStop(0, "#FF0000"), t.addColorStop(0.17 * 1, "#FF00FF"), t.addColorStop(0.17 * 2, "#0000FF"), t.addColorStop(0.17 * 3, "#00FFFF"), t.addColorStop(0.17 * 4, "#00FF00"), t.addColorStop(0.17 * 5, "#FFFF00"), t.addColorStop(1, "#FF0000"), t;
}, Gs = (n) => {
  const e = n.toString(16);
  return e.length === 1 ? `0${e}` : e;
}, Js = (n) => parseInt(n, 16) || 0, NA = ({ r: n, g: e, b: t }) => `#${Gs(n)}${Gs(e)}${Gs(t)}`.toUpperCase(), BA = ({ r: n, g: e, b: t, a: r }) => {
  const i = (r * 255 | 256).toString(16).slice(1);
  return `#${Gs(n)}${Gs(e)}${Gs(t)}${i}`.toUpperCase();
}, $A = (n) => (n = n.startsWith("#") ? n.slice(1) : n, {
  r: Js(n.slice(0, 2)),
  g: Js(n.slice(2, 4)),
  b: Js(n.slice(4, 6))
}), LA = (n) => (n = n.startsWith("#") ? n.slice(1) : n, {
  r: Js(n.slice(0, 2)),
  g: Js(n.slice(2, 4)),
  b: Js(n.slice(4, 6)),
  a: +(parseInt(n.substring(6, 8), 16) / 255).toFixed(2)
}), qm = (n) => {
  const e = (/rgba?\((.*?)\)/.exec(n) || ["", "0,0,0,1"])[1].split(",");
  return {
    r: Number(e[0]) || 0,
    g: Number(e[1]) || 0,
    b: Number(e[2]) || 0,
    a: Number(e[3] ?? 1)
  };
}, PA = (n) => {
  const { r: e, g: t, b: r } = {
    r: n.r / 255,
    g: n.g / 255,
    b: n.b / 255
  }, i = Math.max(e, t, r), s = Math.min(e, t, r), o = i - s;
  let l = 0;
  i === s ? l = 0 : i === e ? t >= r ? l = 60 * (t - r) / o : l = 60 * (t - r) / o + 360 : i === t ? l = 60 * (r - e) / o + 120 : i === r && (l = 60 * (e - t) / o + 240), l = Math.floor(l);
  const u = parseFloat((i === 0 ? 0 : 1 - s / i).toFixed(2)), d = parseFloat(i.toFixed(2));
  return { h: l, s: u, v: d };
}, Km = (n, e = 1) => {
  let t = { r: 0, g: 0, b: 0, a: e };
  if (/^#[a-zA-Z0-9]{1,6}$/.test(n))
    t = { ...$A(n), a: e };
  else if (/^#[a-zA-Z0-9]{1,8}$/.test(n))
    t = { ...LA(n) };
  else if (/rgb/.test(n))
    t = qm(n);
  else if (Um(String)(n))
    t = qm(`rgba(${n})`);
  else if (Um(Object)(n)) {
    const i = "a" in n ? n.a : e;
    t = { ...n, a: i };
  }
  const r = PA(t);
  return { ...t, ...r, a: t.a ?? e };
}, s0 = (n) => new Date(n.getFullYear(), n.getMonth() + 1, 0).getDate(), zA = (n, e) => {
  const t = new Date(n.getFullYear(), n.getMonth(), 0);
  return [...Array(e)].map(
    (r, i) => new Date(t.getFullYear(), t.getMonth(), t.getDate() - i)
  ).reverse();
}, VA = (n, e) => {
  const t = new Date(n.getFullYear(), n.getMonth() + 1, 1);
  return [...Array(e)].map(
    (r, i) => new Date(t.getFullYear(), t.getMonth(), t.getDate() + i)
  );
}, HA = (n) => [...Array(s0(n))].map(
  (e, t) => new Date(n.getFullYear(), n.getMonth(), t + 1)
), Qc = (n, e) => e.map(
  (t) => ({
    date: t,
    isToday: t.toDateString() === new Date().toDateString(),
    inCurrentMonth: t.getMonth() === n.getMonth()
  })
), WA = () => [...Array(7)].map(
  (n, e) => new Date(2021, 0, 4 + e)
), UA = (n) => {
  const e = s0(n), t = new Date(n.getFullYear(), n.getMonth(), 1), r = new Date(n.getFullYear(), n.getMonth(), e), i = t.getDay(), s = r.getDay(), o = i === 0 ? 6 : i - 1, l = s === 0 ? 0 : 7 - s, u = zA(n, o), d = VA(n, l);
  return [...Qc(n, u), ...Qc(n, HA(n)), ...Qc(n, d)];
}, jA = (n, e = "short") => Intl.DateTimeFormat("en-US", { weekday: e }).format(n), qA = (n, e = "long") => Intl.DateTimeFormat("en-US", { month: e }).format(n), KA = (n, e) => n.toDateString() === e.toDateString(), GA = (n, e, t) => n > e && n < t, JA = (n, e) => n >= e, YA = (n, e) => n ? n.toLocaleString().split(",")[0] : e, XA = {
  __proto__: null,
  weekDays: WA,
  getDaysForDateMonthCycle: UA,
  getAlphabeticalWeekday: jA,
  getAlphabeticalMonth: qA,
  isSameDay: KA,
  isBetween: GA,
  biggerThan: JA,
  getCalendarDay: YA
}, Wt = { ...XA }, o0 = (n) => (Ye("data-v-d9c65e9c"), n = n(), Xe(), n), ZA = ["for"], QA = ["id", "value"], eE = /* @__PURE__ */ o0(() => /* @__PURE__ */ O("i", { class: "i-youcan-check" }, null, -1)), tE = [
  eE
], nE = /* @__PURE__ */ o0(() => /* @__PURE__ */ O("i", { class: "i-youcan-minus" }, null, -1)), rE = [
  nE
], iE = {
  key: 0,
  class: "label"
}, sE = /* @__PURE__ */ K({
  __name: "Checkbox",
  props: {
    value: {},
    modelValue: { type: [Boolean, Array] }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Kt(), s = ue({
      get: () => t.modelValue,
      set: (u) => r("update:modelValue", u)
    }), o = ue(
      () => Array.isArray(s.value) ? s.value.find((u) => u === t.value) : s.value
    ), l = pr.uid("checkbox");
    return (u, d) => (E(), F("label", Mn({ for: X(l) }, u.$attrs), [
      O("div", {
        class: de(["checkbox", { "has-label": X(i).label }])
      }, [
        yt(O("input", Mn(u.$attrs, {
          id: X(l),
          "onUpdate:modelValue": d[0] || (d[0] = (f) => s.value = f),
          type: "checkbox",
          class: "input",
          value: u.value
        }), null, 16, QA), [
          [mS, s.value]
        ]),
        u.$attrs.indeterminate ? (E(), F("span", {
          key: 1,
          class: de(["checkmark", [{ checked: o.value }]])
        }, rE, 2)) : (E(), F("span", {
          key: 0,
          class: de(["checkmark", { checked: o.value }])
        }, tE, 2))
      ], 2),
      X(i).label ? (E(), F("div", iE, [
        fe(u.$slots, "label", {}, void 0, !0)
      ])) : ne("", !0)
    ], 16, ZA));
  }
});
const ho = /* @__PURE__ */ J(sE, [["__scopeId", "data-v-d9c65e9c"]]), oE = ["disabled"], aE = {
  key: 0,
  class: "icon"
}, lE = { class: "text" }, uE = /* @__PURE__ */ K({
  __name: "_BaseButton",
  props: {
    size: { default: "md" },
    disabled: { type: Boolean, default: !1 },
    iconPosition: { default: "left" },
    roundedFull: { type: Boolean, default: !1 }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), F("button", {
      ref: "button",
      class: de(["base-button", { "rounded-full": t.roundedFull, [`size-${t.size}`]: !0, [`icon-${t.iconPosition}`]: !0 }]),
      disabled: t.disabled
    }, [
      X(e).icon ? (E(), F("span", aE, [
        fe(t.$slots, "icon", {}, void 0, !0)
      ])) : ne("", !0),
      O("span", lE, [
        fe(t.$slots, "default", {}, void 0, !0)
      ])
    ], 10, oE));
  }
});
const Da = /* @__PURE__ */ J(uE, [["__scopeId", "data-v-108d77d5"]]), cE = /* @__PURE__ */ K({
  __name: "PrimaryButton",
  props: {
    size: {},
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), ge(Da, {
      size: t.size,
      disabled: t.disabled,
      "icon-position": t.iconPosition,
      "rounded-full": t.roundedFull,
      class: "primary"
    }, Fr({
      default: ee(() => [
        fe(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 2
    }, [
      X(e).icon ? {
        name: "icon",
        fn: ee(() => [
          fe(t.$slots, "icon", {}, void 0, !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "disabled", "icon-position", "rounded-full"]));
  }
});
const Ca = /* @__PURE__ */ J(cE, [["__scopeId", "data-v-f59cbc10"]]), dE = /* @__PURE__ */ K({
  __name: "SecondaryButton",
  props: {
    size: {},
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), ge(Da, {
      size: t.size,
      disabled: t.disabled,
      "icon-position": t.iconPosition,
      "rounded-full": t.roundedFull,
      class: "secondary"
    }, Fr({
      default: ee(() => [
        fe(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 2
    }, [
      X(e).icon ? {
        name: "icon",
        fn: ee(() => [
          fe(t.$slots, "icon", {}, void 0, !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "disabled", "icon-position", "rounded-full"]));
  }
});
const Zr = /* @__PURE__ */ J(dE, [["__scopeId", "data-v-b9356457"]]), fE = /* @__PURE__ */ K({
  __name: "PrimaryDestructiveButton",
  props: {
    size: {},
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), ge(Da, {
      size: t.size,
      disabled: t.disabled,
      "icon-position": t.iconPosition,
      "rounded-full": t.roundedFull,
      class: "primary-destructive"
    }, Fr({
      default: ee(() => [
        fe(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 2
    }, [
      X(e).icon ? {
        name: "icon",
        fn: ee(() => [
          fe(t.$slots, "icon", {}, void 0, !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "disabled", "icon-position", "rounded-full"]));
  }
});
const a0 = /* @__PURE__ */ J(fE, [["__scopeId", "data-v-67d99faa"]]), pE = /* @__PURE__ */ K({
  __name: "SecondaryDestructiveButton",
  props: {
    size: {},
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), ge(Da, {
      size: t.size,
      disabled: t.disabled,
      "icon-position": t.iconPosition,
      "rounded-full": t.roundedFull,
      class: "secondary-destructive"
    }, Fr({
      default: ee(() => [
        fe(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 2
    }, [
      X(e).icon ? {
        name: "icon",
        fn: ee(() => [
          fe(t.$slots, "icon", {}, void 0, !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "disabled", "icon-position", "rounded-full"]));
  }
});
const hE = /* @__PURE__ */ J(pE, [["__scopeId", "data-v-c12144c4"]]), mE = /* @__PURE__ */ K({
  __name: "TertiaryButton",
  props: {
    size: {},
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    const e = Kt();
    return (t, r) => (E(), ge(Da, {
      size: t.size,
      disabled: t.disabled,
      "icon-position": t.iconPosition,
      "rounded-full": t.roundedFull,
      class: "tertiary"
    }, Fr({
      default: ee(() => [
        fe(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 2
    }, [
      X(e).icon ? {
        name: "icon",
        fn: ee(() => [
          fe(t.$slots, "icon", {}, void 0, !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "disabled", "icon-position", "rounded-full"]));
  }
});
const rn = /* @__PURE__ */ J(mE, [["__scopeId", "data-v-10b8a1d6"]]), gE = (n) => (Ye("data-v-6b5366db"), n = n(), Xe(), n), vE = { class: "dropdown-prefix-wrapper" }, yE = { class: "label" }, bE = /* @__PURE__ */ gE(() => /* @__PURE__ */ O("i", { class: "chevron i-youcan-carret-down" }, null, -1)), _E = /* @__PURE__ */ K({
  __name: "DropdownPrefix",
  props: {
    placeholder: {},
    searchable: { type: Boolean, default: !1 },
    modelValue: {},
    items: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(), s = G(), o = G(!1), l = (d = !o.value) => o.value = d;
    mr(i, () => l(!1), { ignore: [s] });
    const u = ue({
      get: () => t.modelValue,
      set: (d) => {
        l(!1), r("update:modelValue", d);
      }
    });
    return (d, f) => {
      var h;
      return E(), F("div", vE, [
        O("button", {
          ref_key: "button",
          ref: s,
          type: "button",
          class: "dropdown-input",
          onClick: f[0] || (f[0] = () => l())
        }, [
          O("span", yE, re(((h = u.value) == null ? void 0 : h.label) ?? d.placeholder), 1),
          bE
        ], 512),
        o.value ? (E(), F("div", {
          key: 0,
          ref_key: "list",
          ref: i,
          class: "dropdown-wrapper"
        }, [
          ce(Cu, Mn({ class: "dropdown-list" }, { items: d.items, searchable: d.searchable, selected: d.modelValue, multiple: !1 }, {
            onSelect: f[1] || (f[1] = (m) => u.value = m)
          }), null, 16)
        ], 512)) : ne("", !0)
      ]);
    };
  }
});
const l0 = /* @__PURE__ */ J(_E, [["__scopeId", "data-v-6b5366db"]]), wE = {
  key: 0,
  class: "prefix"
}, DE = ["type"], CE = {
  key: 0,
  class: "i-youcan:eye"
}, xE = {
  key: 1,
  class: "i-youcan:eye-slash"
}, kE = {
  key: 2,
  class: "tail"
}, SE = {
  key: 0,
  class: "icon"
}, AE = {
  key: 1,
  class: "suffix"
}, EE = /* @__PURE__ */ K({
  __name: "Input",
  props: {
    type: { default: "text" },
    modelValue: {},
    error: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(), s = Kt(), o = gf(), l = G(!1), u = ue({
      get: () => t.modelValue,
      set: (f) => r("update:modelValue", f)
    }), d = ue(() => t.type === "password" && l.value ? "text" : t.type);
    return vf(() => {
      if (!s.prefix)
        return;
      const f = s.prefix()[0].type;
      if (!(typeof f != "symbol" && [l0].find((h) => h === f)))
        throw new TypeError("Invalid prefix");
    }), (f, h) => (E(), F("div", {
      class: de([{ enabled: !X(o).disabled, error: f.error }, "wrapper"])
    }, [
      X(s).prefix ? (E(), F("div", wE, [
        fe(f.$slots, "prefix", {}, void 0, !0)
      ])) : ne("", !0),
      yt(O("input", Mn({
        ref_key: "primitive",
        ref: i,
        "onUpdate:modelValue": h[0] || (h[0] = (m) => u.value = m),
        class: "input",
        type: d.value
      }, f.$attrs), null, 16, DE), [
        [gS, u.value]
      ]),
      f.type === "password" ? (E(), F("div", {
        key: 1,
        class: "show-password",
        onClick: h[1] || (h[1] = (m) => l.value = !l.value)
      }, [
        l.value ? (E(), F("i", CE)) : (E(), F("i", xE))
      ])) : ne("", !0),
      X(s).icon || X(s).suffix ? (E(), F("div", kE, [
        X(s).icon ? (E(), F("div", SE, [
          fe(f.$slots, "icon", {}, void 0, !0)
        ])) : ne("", !0),
        X(s).suffix ? (E(), F("div", AE, [
          fe(f.$slots, "suffix", {}, void 0, !0)
        ])) : ne("", !0)
      ])) : ne("", !0)
    ], 2));
  }
});
const ss = /* @__PURE__ */ J(EE, [["__scopeId", "data-v-860c11c6"]]), TE = { class: "input-group" }, ME = ["for"], OE = { class: "input" }, FE = {
  key: 1,
  class: "error"
}, IE = {
  key: 2,
  class: "info"
}, RE = /* @__PURE__ */ K({
  __name: "InputGroup",
  setup(n) {
    const e = Kt(), t = pr.uid("input_group_");
    return (r, i) => (E(), F("div", TE, [
      X(e).label ? (E(), F("label", {
        key: 0,
        for: X(t),
        class: "label"
      }, [
        fe(r.$slots, "label", {}, void 0, !0)
      ], 8, ME)) : ne("", !0),
      O("div", OE, [
        fe(r.$slots, "input", { id: X(t) }, void 0, !0)
      ]),
      X(e).error ? (E(), F("div", FE, [
        fe(r.$slots, "error", {}, void 0, !0)
      ])) : ne("", !0),
      X(e).info ? (E(), F("div", IE, [
        fe(r.$slots, "info", {}, void 0, !0)
      ])) : ne("", !0)
    ]));
  }
});
const NE = /* @__PURE__ */ J(RE, [["__scopeId", "data-v-2054c8b5"]]), BE = { class: "override" }, $E = /* @__PURE__ */ K({
  __name: "Override",
  props: {
    color: { default: "" }
  },
  emits: ["overridecolor"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.color,
      set: (s) => r("overridecolor", s.startsWith("#") ? s : `#${s}`)
    });
    return (s, o) => (E(), F("div", BE, [
      ce(ss, {
        modelValue: i.value,
        "onUpdate:modelValue": o[0] || (o[0] = (l) => i.value = l),
        class: "value/"
      }, null, 8, ["modelValue"])
    ]));
  }
}), LE = {
  key: 0,
  class: "swatch-wrapper storage"
}, PE = { class: "swatches storage" }, zE = ["onClick"], VE = { class: "swatches" }, HE = ["onClick"], vl = "youcan-theme-editor-colors", WE = /* @__PURE__ */ K({
  __name: "Swatches",
  props: {
    color: { default: xu },
    defaultSwatches: { default: () => [] }
  },
  emits: ["setcolor"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(bf(4).toDataURL()), s = G([]);
    localStorage && vl && (s.value = JSON.parse(localStorage.getItem(vl)) || []);
    const o = (u) => {
      if (!u)
        return;
      const d = s.value || [], f = d.indexOf(u);
      f >= 0 && d.splice(f, 1), d.length >= 7 && d.pop(), d.unshift(u), s.value = d || [], localStorage && vl && localStorage.setItem(vl, JSON.stringify(d));
    }, l = (u) => {
      r("setcolor", u);
    };
    return po(() => o(t.color)), (u, d) => (E(), F(ze, null, [
      s.value.length ? (E(), F("div", LE, [
        O("div", PE, [
          (E(!0), F(ze, null, Je(s.value, (f) => (E(), F("div", {
            key: f,
            class: "swatch",
            onClick: (h) => l(f)
          }, [
            O("div", {
              style: Tn({ background: `url(${i.value})` }),
              class: "alpha"
            }, null, 4),
            O("div", {
              style: Tn({ background: f }),
              class: "color"
            }, null, 4)
          ], 8, zE))), 128))
        ])
      ])) : ne("", !0),
      O("div", VE, [
        (E(!0), F(ze, null, Je(u.defaultSwatches, (f) => (E(), F("div", {
          key: f,
          class: "swatch",
          onClick: (h) => l(f)
        }, [
          O("div", {
            style: Tn({ background: `url(${i.value})` }),
            class: "alpha"
          }, null, 4),
          O("div", {
            style: Tn({ background: f }),
            class: "color"
          }, null, 4)
        ], 8, HE))), 128))
      ])
    ], 64));
  }
});
const UE = /* @__PURE__ */ J(WE, [["__scopeId", "data-v-674c0dc4"]]), jE = /* @__PURE__ */ K({
  __name: "Saturation",
  props: {
    color: {},
    hsv: {},
    size: {}
  },
  emits: ["setsaturation"],
  setup(n, { expose: e, emit: t }) {
    Zn((h) => ({
      "6c4a28c6": `${h.size}px`
    }));
    const r = n, i = t, s = G(), o = G(), l = G({}), u = () => {
      const h = o.value.getContext("2d", { willReadFrequently: !0 });
      o.value.width = r.size, o.value.height = r.size, h.fillStyle = r.color, h.fillRect(0, 0, r.size, r.size), jm(h, r.size, r.size, xu, "rgba(255, 255, 255, 0)"), jm(h, r.size, r.size, "rgba(0, 0, 0, 0)", i0, "right");
    }, d = () => {
      l.value = {
        left: `${r.hsv.s * r.size - 5}px`,
        top: `${(1 - r.hsv.v) * r.size - 5}px`
      };
    }, f = (h) => {
      const { top: m, left: g } = s.value.getBoundingClientRect(), y = h.target.getContext("2d", { willReadFrequently: !0 });
      function b(T) {
        let k = T.clientX - g, S = T.clientY - m;
        k < 0 && (k = 0), S < 0 && (S = 0), k > r.size && (k = r.size), S > r.size && (S = r.size), l.value = {
          left: `${k - 10}px`,
          top: `${S - 10}px`
        };
        const C = y.getImageData(Math.min(k, r.size - 1), Math.min(S, r.size - 1), 1, 1), [R, I, P] = C.data;
        i("setsaturation", { r: R, g: I, b: P });
      }
      b(h);
      const w = () => {
        document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", w);
      };
      document.addEventListener("mousemove", b), document.addEventListener("mouseup", w);
    };
    return bt(() => {
      Ks(() => {
        u(), d();
      });
    }), e({ renderColor: u, renderSlider: d }), (h, m) => (E(), F("div", {
      ref_key: "wrapper",
      ref: s,
      class: "saturation-wrapper",
      onMousedown: ki(f, ["prevent", "stop"])
    }, [
      O("canvas", {
        ref_key: "canvas",
        ref: o,
        class: "canvas"
      }, null, 512),
      O("i", {
        "i-youcan-pointer": "",
        style: Tn(l.value),
        class: "slider"
      }, null, 4)
    ], 544));
  }
});
const qE = /* @__PURE__ */ J(jE, [["__scopeId", "data-v-cfed7bf9"]]), KE = /* @__PURE__ */ K({
  __name: "Hue",
  props: {
    hsv: {},
    width: { default: 15 },
    height: { default: 152 }
  },
  emits: ["sethue"],
  setup(n, { expose: e, emit: t }) {
    Zn((g) => ({
      "10b8a246": `${i}px`,
      "878fbb86": `${s}px`
    }));
    const { hsv: r, width: i, height: s } = n, o = t, l = G(), u = G(), d = G({}), f = () => {
      const g = u.value.getContext("2d", { willReadFrequently: !0 });
      u.value.width = i, u.value.height = s;
      const y = RA(g, i);
      g.fillStyle = y, g.fillRect(0, 0, i, s);
    }, h = () => {
      d.value = {
        left: `${(1 - r.h / 360) * i - 2}px`
      };
    }, m = (g) => {
      const { left: y } = l.value.getBoundingClientRect(), b = u.value.getContext("2d", { willReadFrequently: !0 });
      function w(k) {
        let S = k.clientX - y;
        S < 0 && (S = 0), S > i && (S = i), d.value = {
          left: `${S - 12}px`
        };
        const C = b.getImageData(Math.min(S, i - 1), 1, 1, 1), [R, I, P] = C.data;
        o("sethue", { r: R, g: I, b: P });
      }
      w(g);
      const T = () => {
        document.removeEventListener("mousemove", w), document.removeEventListener("mouseup", T);
      };
      document.addEventListener("mousemove", w), document.addEventListener("mouseup", T);
    };
    return bt(() => {
      f(), h();
    }), e({ renderColor: f, renderSlider: h }), (g, y) => (E(), F("div", {
      ref_key: "wrapper",
      ref: l,
      class: "hue-wrapper",
      onMousedown: ki(m, ["prevent", "stop"])
    }, [
      O("canvas", {
        ref_key: "canvas",
        ref: u,
        class: "canvas"
      }, null, 512),
      O("i", {
        "i-youcan-pointer": "",
        style: Tn(d.value),
        class: "slider"
      }, null, 4)
    ], 544));
  }
});
const GE = /* @__PURE__ */ J(KE, [["__scopeId", "data-v-70ac438d"]]), JE = 5, YE = /* @__PURE__ */ K({
  __name: "Alpha",
  props: {
    color: { default: i0 },
    rgba: {},
    height: { default: 152 },
    width: { default: 15 }
  },
  emits: ["setalpha"],
  setup(n, { emit: e }) {
    Zn((f) => ({
      "4587a89e": `${f.width}px`,
      ffb4739c: `${f.height}px`
    }));
    const t = n, r = e, i = G(), s = G(), o = G({}), l = () => {
      const f = bf(JE), h = s.value.getContext("2d", { willReadFrequently: !0 });
      s.value.width = t.width, s.value.height = t.height, h.fillStyle = h.createPattern(f, "repeat"), h.fillRect(0, 0, t.width, t.height), IA(h, t.width, t.height, "rgba(255, 255, 255, 0)", t.color);
    }, u = () => {
      o.value = {
        left: `${t.rgba.a * t.width - 12}px`
      };
    }, d = (f) => {
      const { left: h } = i.value.getBoundingClientRect();
      function m(y) {
        let b = y.clientX - h;
        b < 0 && (b = 0), b > t.width && (b = t.width), r("setalpha", parseFloat((b / t.width).toFixed(2)));
      }
      m(f);
      const g = () => {
        document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", g);
      };
      document.addEventListener("mousemove", m), document.addEventListener("mouseup", g);
    };
    return bt(() => {
      l(), u();
    }), En(() => t.color, () => l()), En(() => t.rgba, () => u()), (f, h) => (E(), F("div", {
      ref_key: "wrapper",
      ref: i,
      class: "alpha-wrapper",
      onMousedown: ki(d, ["prevent", "stop"])
    }, [
      O("canvas", {
        ref_key: "canvas",
        ref: s,
        class: "canvas"
      }, null, 512),
      O("i", {
        "i-youcan-pointer": "",
        style: Tn(o.value),
        class: "slider"
      }, null, 4)
    ], 544));
  }
});
const XE = /* @__PURE__ */ J(YE, [["__scopeId", "data-v-dfc134ff"]]), u0 = (n) => (Ye("data-v-9e4f635e"), n = n(), Xe(), n), ZE = { class: "color-picker" }, QE = { class: "sliders" }, eT = { class: "color-override" }, tT = /* @__PURE__ */ u0(() => /* @__PURE__ */ O("label", null, "HEX", -1)), nT = /* @__PURE__ */ u0(() => /* @__PURE__ */ O("hr", null, null, -1)), rT = { class: "swatches" }, iT = /* @__PURE__ */ K({
  __name: "ColorPicker",
  props: {
    color: { default: "#ffffff" },
    defaults: { default: () => [] },
    preserveTransparency: { type: Boolean, default: !1 }
  },
  emits: ["setcolor"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(), s = G(), o = G(""), l = G(""), u = G(""), d = G({ r: 255, g: 255, b: 255, a: 1, h: 0, s: 0, v: 0 }), f = ue(() => ({ r: d.value.r, g: d.value.g, b: d.value.b, a: d.value.a })), h = ue(() => ({ h: d.value.h, s: d.value.s, v: d.value.v })), m = ue(() => NA(f.value)), g = ue(() => BA(f.value)), y = ue(() => `${d.value.r}, ${d.value.g}, ${d.value.b}, ${d.value.a}`), b = ue(() => `rgb(${d.value.r}, ${d.value.g}, ${d.value.b})`), w = ue(() => `rgba(${y.value})`), T = () => {
      o.value = m.value, u.value = y.value, l.value = g.value;
    };
    bt(() => {
      d.value = P(t.color), T();
    });
    const k = (L) => {
      d.value = P(L), T();
    }, S = (L) => {
      d.value = P(L), T(), Ks(() => {
        i.value.renderColor(), i.value.renderSlider();
      });
    }, C = (L) => {
      d.value.a = L, T();
    }, R = (L) => {
      d.value = P(L), o.value = L, l.value = L, u.value = y.value, Ks(() => {
        s.value.renderSlider(), i.value.renderColor(), i.value.renderSlider();
      });
    }, I = (L) => {
      d.value = P(L), T(), Ks(() => {
        s.value.renderSlider(), i.value.renderColor(), i.value.renderSlider();
      });
    };
    En(
      f,
      () => r("setcolor", { rgba: f.value, hsv: h.value, hex: o.value, hexa: l.value })
    );
    function P(L) {
      return t.preserveTransparency ? Km(L, d.value.a) : Km(L);
    }
    return (L, q) => (E(), F("div", ZE, [
      ce(qE, {
        ref_key: "saturationElement",
        ref: i,
        class: "color-saturation",
        color: b.value,
        hsv: h.value,
        size: 224,
        onSetsaturation: k
      }, null, 8, ["color", "hsv"]),
      O("div", QE, [
        ce(GE, {
          ref_key: "hueElement",
          ref: s,
          class: "color-hue",
          hsv: h.value,
          width: 224,
          height: 10,
          onSethue: S
        }, null, 8, ["hsv"]),
        ce(XE, {
          class: "color-alpha",
          color: b.value,
          rgba: f.value,
          width: 224,
          height: 10,
          onSetalpha: C
        }, null, 8, ["color", "rgba"])
      ]),
      O("div", eT, [
        tT,
        ce($E, {
          class: "hex-input",
          type: "#",
          color: l.value,
          onOverridecolor: R
        }, null, 8, ["color"])
      ]),
      nT,
      O("div", rT, [
        ce(UE, {
          color: w.value,
          "default-swatches": L.defaults,
          onSetcolor: I
        }, null, 8, ["color", "default-swatches"])
      ])
    ]));
  }
});
const _f = /* @__PURE__ */ J(iT, [["__scopeId", "data-v-9e4f635e"]]);
var mn = "top", Jn = "bottom", Yn = "right", gn = "left", ku = "auto", xa = [mn, Jn, Yn, gn], to = "start", ca = "end", sT = "clippingParents", c0 = "viewport", Ho = "popper", oT = "reference", Gm = /* @__PURE__ */ xa.reduce(function(n, e) {
  return n.concat([e + "-" + to, e + "-" + ca]);
}, []), d0 = /* @__PURE__ */ [].concat(xa, [ku]).reduce(function(n, e) {
  return n.concat([e, e + "-" + to, e + "-" + ca]);
}, []), aT = "beforeRead", lT = "read", uT = "afterRead", cT = "beforeMain", dT = "main", fT = "afterMain", pT = "beforeWrite", hT = "write", mT = "afterWrite", Id = [aT, lT, uT, cT, dT, fT, pT, hT, mT];
function Tr(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function Fn(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function as(n) {
  var e = Fn(n).Element;
  return n instanceof e || n instanceof Element;
}
function On(n) {
  var e = Fn(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function wf(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Fn(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function gT(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var r = e.styles[t] || {}, i = e.attributes[t] || {}, s = e.elements[t];
    !On(s) || !Tr(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var l = i[o];
      l === !1 ? s.removeAttribute(o) : s.setAttribute(o, l === !0 ? "" : l);
    }));
  });
}
function vT(n) {
  var e = n.state, t = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), l = o.reduce(function(u, d) {
        return u[d] = "", u;
      }, {});
      !On(i) || !Tr(i) || (Object.assign(i.style, l), Object.keys(s).forEach(function(u) {
        i.removeAttribute(u);
      }));
    });
  };
}
const f0 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: gT,
  effect: vT,
  requires: ["computeStyles"]
};
function cr(n) {
  return n.split("-")[0];
}
var es = Math.max, Pl = Math.min, no = Math.round;
function Rd() {
  var n = navigator.userAgentData;
  return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function p0() {
  return !/^((?!chrome|android).)*safari/i.test(Rd());
}
function ro(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var r = n.getBoundingClientRect(), i = 1, s = 1;
  e && On(n) && (i = n.offsetWidth > 0 && no(r.width) / n.offsetWidth || 1, s = n.offsetHeight > 0 && no(r.height) / n.offsetHeight || 1);
  var o = as(n) ? Fn(n) : window, l = o.visualViewport, u = !p0() && t, d = (r.left + (u && l ? l.offsetLeft : 0)) / i, f = (r.top + (u && l ? l.offsetTop : 0)) / s, h = r.width / i, m = r.height / s;
  return {
    width: h,
    height: m,
    top: f,
    right: d + h,
    bottom: f + m,
    left: d,
    x: d,
    y: f
  };
}
function Df(n) {
  var e = ro(n), t = n.offsetWidth, r = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: t,
    height: r
  };
}
function h0(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && wf(t)) {
    var r = e;
    do {
      if (r && n.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function hr(n) {
  return Fn(n).getComputedStyle(n);
}
function yT(n) {
  return ["table", "td", "th"].indexOf(Tr(n)) >= 0;
}
function Ti(n) {
  return ((as(n) ? n.ownerDocument : n.document) || window.document).documentElement;
}
function Su(n) {
  return Tr(n) === "html" ? n : n.assignedSlot || n.parentNode || (wf(n) ? n.host : null) || Ti(n);
}
function Jm(n) {
  return !On(n) || hr(n).position === "fixed" ? null : n.offsetParent;
}
function bT(n) {
  var e = /firefox/i.test(Rd()), t = /Trident/i.test(Rd());
  if (t && On(n)) {
    var r = hr(n);
    if (r.position === "fixed")
      return null;
  }
  var i = Su(n);
  for (wf(i) && (i = i.host); On(i) && ["html", "body"].indexOf(Tr(i)) < 0; ) {
    var s = hr(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function ka(n) {
  for (var e = Fn(n), t = Jm(n); t && yT(t) && hr(t).position === "static"; )
    t = Jm(t);
  return t && (Tr(t) === "html" || Tr(t) === "body" && hr(t).position === "static") ? e : t || bT(n) || e;
}
function Cf(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function Zo(n, e, t) {
  return es(n, Pl(e, t));
}
function _T(n, e, t) {
  var r = Zo(n, e, t);
  return r > t ? t : r;
}
function m0() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function g0(n) {
  return Object.assign({}, m0(), n);
}
function v0(n, e) {
  return e.reduce(function(t, r) {
    return t[r] = n, t;
  }, {});
}
var wT = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
    placement: t.placement
  })) : e, g0(typeof e != "number" ? e : v0(e, xa));
};
function DT(n) {
  var e, t = n.state, r = n.name, i = n.options, s = t.elements.arrow, o = t.modifiersData.popperOffsets, l = cr(t.placement), u = Cf(l), d = [gn, Yn].indexOf(l) >= 0, f = d ? "height" : "width";
  if (!(!s || !o)) {
    var h = wT(i.padding, t), m = Df(s), g = u === "y" ? mn : gn, y = u === "y" ? Jn : Yn, b = t.rects.reference[f] + t.rects.reference[u] - o[u] - t.rects.popper[f], w = o[u] - t.rects.reference[u], T = ka(s), k = T ? u === "y" ? T.clientHeight || 0 : T.clientWidth || 0 : 0, S = b / 2 - w / 2, C = h[g], R = k - m[f] - h[y], I = k / 2 - m[f] / 2 + S, P = Zo(C, I, R), L = u;
    t.modifiersData[r] = (e = {}, e[L] = P, e.centerOffset = P - I, e);
  }
}
function CT(n) {
  var e = n.state, t = n.options, r = t.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  if (i != null && !(typeof i == "string" && (i = e.elements.popper.querySelector(i), !i))) {
    if (process.env.NODE_ENV !== "production" && (On(i) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !h0(e.elements.popper, i)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    e.elements.arrow = i;
  }
}
const xT = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: DT,
  effect: CT,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function io(n) {
  return n.split("-")[1];
}
var kT = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function ST(n, e) {
  var t = n.x, r = n.y, i = e.devicePixelRatio || 1;
  return {
    x: no(t * i) / i || 0,
    y: no(r * i) / i || 0
  };
}
function Ym(n) {
  var e, t = n.popper, r = n.popperRect, i = n.placement, s = n.variation, o = n.offsets, l = n.position, u = n.gpuAcceleration, d = n.adaptive, f = n.roundOffsets, h = n.isFixed, m = o.x, g = m === void 0 ? 0 : m, y = o.y, b = y === void 0 ? 0 : y, w = typeof f == "function" ? f({
    x: g,
    y: b
  }) : {
    x: g,
    y: b
  };
  g = w.x, b = w.y;
  var T = o.hasOwnProperty("x"), k = o.hasOwnProperty("y"), S = gn, C = mn, R = window;
  if (d) {
    var I = ka(t), P = "clientHeight", L = "clientWidth";
    if (I === Fn(t) && (I = Ti(t), hr(I).position !== "static" && l === "absolute" && (P = "scrollHeight", L = "scrollWidth")), I = I, i === mn || (i === gn || i === Yn) && s === ca) {
      C = Jn;
      var q = h && I === R && R.visualViewport ? R.visualViewport.height : I[P];
      b -= q - r.height, b *= u ? 1 : -1;
    }
    if (i === gn || (i === mn || i === Jn) && s === ca) {
      S = Yn;
      var oe = h && I === R && R.visualViewport ? R.visualViewport.width : I[L];
      g -= oe - r.width, g *= u ? 1 : -1;
    }
  }
  var ae = Object.assign({
    position: l
  }, d && kT), ke = f === !0 ? ST({
    x: g,
    y: b
  }, Fn(t)) : {
    x: g,
    y: b
  };
  if (g = ke.x, b = ke.y, u) {
    var Ee;
    return Object.assign({}, ae, (Ee = {}, Ee[C] = k ? "0" : "", Ee[S] = T ? "0" : "", Ee.transform = (R.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", Ee));
  }
  return Object.assign({}, ae, (e = {}, e[C] = k ? b + "px" : "", e[S] = T ? g + "px" : "", e.transform = "", e));
}
function AT(n) {
  var e = n.state, t = n.options, r = t.gpuAcceleration, i = r === void 0 ? !0 : r, s = t.adaptive, o = s === void 0 ? !0 : s, l = t.roundOffsets, u = l === void 0 ? !0 : l;
  if (process.env.NODE_ENV !== "production") {
    var d = hr(e.elements.popper).transitionProperty || "";
    o && ["transform", "top", "right", "bottom", "left"].some(function(h) {
      return d.indexOf(h) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var f = {
    placement: cr(e.placement),
    variation: io(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Ym(Object.assign({}, f, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: u
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Ym(Object.assign({}, f, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const ET = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: AT,
  data: {}
};
var yl = {
  passive: !0
};
function TT(n) {
  var e = n.state, t = n.instance, r = n.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, l = o === void 0 ? !0 : o, u = Fn(e.elements.popper), d = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && d.forEach(function(f) {
    f.addEventListener("scroll", t.update, yl);
  }), l && u.addEventListener("resize", t.update, yl), function() {
    s && d.forEach(function(f) {
      f.removeEventListener("scroll", t.update, yl);
    }), l && u.removeEventListener("resize", t.update, yl);
  };
}
const MT = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: TT,
  data: {}
};
var OT = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ml(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return OT[e];
  });
}
var FT = {
  start: "end",
  end: "start"
};
function Xm(n) {
  return n.replace(/start|end/g, function(e) {
    return FT[e];
  });
}
function xf(n) {
  var e = Fn(n), t = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: r
  };
}
function kf(n) {
  return ro(Ti(n)).left + xf(n).scrollLeft;
}
function IT(n, e) {
  var t = Fn(n), r = Ti(n), i = t.visualViewport, s = r.clientWidth, o = r.clientHeight, l = 0, u = 0;
  if (i) {
    s = i.width, o = i.height;
    var d = p0();
    (d || !d && e === "fixed") && (l = i.offsetLeft, u = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: l + kf(n),
    y: u
  };
}
function RT(n) {
  var e, t = Ti(n), r = xf(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, s = es(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = es(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), l = -r.scrollLeft + kf(n), u = -r.scrollTop;
  return hr(i || t).direction === "rtl" && (l += es(t.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: l,
    y: u
  };
}
function Sf(n) {
  var e = hr(n), t = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + i + r);
}
function y0(n) {
  return ["html", "body", "#document"].indexOf(Tr(n)) >= 0 ? n.ownerDocument.body : On(n) && Sf(n) ? n : y0(Su(n));
}
function Qo(n, e) {
  var t;
  e === void 0 && (e = []);
  var r = y0(n), i = r === ((t = n.ownerDocument) == null ? void 0 : t.body), s = Fn(r), o = i ? [s].concat(s.visualViewport || [], Sf(r) ? r : []) : r, l = e.concat(o);
  return i ? l : l.concat(Qo(Su(o)));
}
function Nd(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function NT(n, e) {
  var t = ro(n, !1, e === "fixed");
  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;
}
function Zm(n, e, t) {
  return e === c0 ? Nd(IT(n, t)) : as(e) ? NT(e, t) : Nd(RT(Ti(n)));
}
function BT(n) {
  var e = Qo(Su(n)), t = ["absolute", "fixed"].indexOf(hr(n).position) >= 0, r = t && On(n) ? ka(n) : n;
  return as(r) ? e.filter(function(i) {
    return as(i) && h0(i, r) && Tr(i) !== "body";
  }) : [];
}
function $T(n, e, t, r) {
  var i = e === "clippingParents" ? BT(n) : [].concat(e), s = [].concat(i, [t]), o = s[0], l = s.reduce(function(u, d) {
    var f = Zm(n, d, r);
    return u.top = es(f.top, u.top), u.right = Pl(f.right, u.right), u.bottom = Pl(f.bottom, u.bottom), u.left = es(f.left, u.left), u;
  }, Zm(n, o, r));
  return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l;
}
function b0(n) {
  var e = n.reference, t = n.element, r = n.placement, i = r ? cr(r) : null, s = r ? io(r) : null, o = e.x + e.width / 2 - t.width / 2, l = e.y + e.height / 2 - t.height / 2, u;
  switch (i) {
    case mn:
      u = {
        x: o,
        y: e.y - t.height
      };
      break;
    case Jn:
      u = {
        x: o,
        y: e.y + e.height
      };
      break;
    case Yn:
      u = {
        x: e.x + e.width,
        y: l
      };
      break;
    case gn:
      u = {
        x: e.x - t.width,
        y: l
      };
      break;
    default:
      u = {
        x: e.x,
        y: e.y
      };
  }
  var d = i ? Cf(i) : null;
  if (d != null) {
    var f = d === "y" ? "height" : "width";
    switch (s) {
      case to:
        u[d] = u[d] - (e[f] / 2 - t[f] / 2);
        break;
      case ca:
        u[d] = u[d] + (e[f] / 2 - t[f] / 2);
        break;
    }
  }
  return u;
}
function da(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = r === void 0 ? n.placement : r, s = t.strategy, o = s === void 0 ? n.strategy : s, l = t.boundary, u = l === void 0 ? sT : l, d = t.rootBoundary, f = d === void 0 ? c0 : d, h = t.elementContext, m = h === void 0 ? Ho : h, g = t.altBoundary, y = g === void 0 ? !1 : g, b = t.padding, w = b === void 0 ? 0 : b, T = g0(typeof w != "number" ? w : v0(w, xa)), k = m === Ho ? oT : Ho, S = n.rects.popper, C = n.elements[y ? k : m], R = $T(as(C) ? C : C.contextElement || Ti(n.elements.popper), u, f, o), I = ro(n.elements.reference), P = b0({
    reference: I,
    element: S,
    strategy: "absolute",
    placement: i
  }), L = Nd(Object.assign({}, S, P)), q = m === Ho ? L : I, oe = {
    top: R.top - q.top + T.top,
    bottom: q.bottom - R.bottom + T.bottom,
    left: R.left - q.left + T.left,
    right: q.right - R.right + T.right
  }, ae = n.modifiersData.offset;
  if (m === Ho && ae) {
    var ke = ae[i];
    Object.keys(oe).forEach(function(Ee) {
      var rt = [Yn, Jn].indexOf(Ee) >= 0 ? 1 : -1, Qe = [mn, Jn].indexOf(Ee) >= 0 ? "y" : "x";
      oe[Ee] += ke[Qe] * rt;
    });
  }
  return oe;
}
function LT(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = t.boundary, s = t.rootBoundary, o = t.padding, l = t.flipVariations, u = t.allowedAutoPlacements, d = u === void 0 ? d0 : u, f = io(r), h = f ? l ? Gm : Gm.filter(function(y) {
    return io(y) === f;
  }) : xa, m = h.filter(function(y) {
    return d.indexOf(y) >= 0;
  });
  m.length === 0 && (m = h, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var g = m.reduce(function(y, b) {
    return y[b] = da(n, {
      placement: b,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[cr(b)], y;
  }, {});
  return Object.keys(g).sort(function(y, b) {
    return g[y] - g[b];
  });
}
function PT(n) {
  if (cr(n) === ku)
    return [];
  var e = Ml(n);
  return [Xm(n), e, Xm(e)];
}
function zT(n) {
  var e = n.state, t = n.options, r = n.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = t.mainAxis, s = i === void 0 ? !0 : i, o = t.altAxis, l = o === void 0 ? !0 : o, u = t.fallbackPlacements, d = t.padding, f = t.boundary, h = t.rootBoundary, m = t.altBoundary, g = t.flipVariations, y = g === void 0 ? !0 : g, b = t.allowedAutoPlacements, w = e.options.placement, T = cr(w), k = T === w, S = u || (k || !y ? [Ml(w)] : PT(w)), C = [w].concat(S).reduce(function(gt, st) {
      return gt.concat(cr(st) === ku ? LT(e, {
        placement: st,
        boundary: f,
        rootBoundary: h,
        padding: d,
        flipVariations: y,
        allowedAutoPlacements: b
      }) : st);
    }, []), R = e.rects.reference, I = e.rects.popper, P = /* @__PURE__ */ new Map(), L = !0, q = C[0], oe = 0; oe < C.length; oe++) {
      var ae = C[oe], ke = cr(ae), Ee = io(ae) === to, rt = [mn, Jn].indexOf(ke) >= 0, Qe = rt ? "width" : "height", Ke = da(e, {
        placement: ae,
        boundary: f,
        rootBoundary: h,
        altBoundary: m,
        padding: d
      }), He = rt ? Ee ? Yn : gn : Ee ? Jn : mn;
      R[Qe] > I[Qe] && (He = Ml(He));
      var De = Ml(He), Te = [];
      if (s && Te.push(Ke[ke] <= 0), l && Te.push(Ke[He] <= 0, Ke[De] <= 0), Te.every(function(gt) {
        return gt;
      })) {
        q = ae, L = !1;
        break;
      }
      P.set(ae, Te);
    }
    if (L)
      for (var Oe = y ? 3 : 1, je = function(st) {
        var _t = C.find(function(bn) {
          var wt = P.get(bn);
          if (wt)
            return wt.slice(0, st).every(function(Jt) {
              return Jt;
            });
        });
        if (_t)
          return q = _t, "break";
      }, it = Oe; it > 0; it--) {
        var Qn = je(it);
        if (Qn === "break")
          break;
      }
    e.placement !== q && (e.modifiersData[r]._skip = !0, e.placement = q, e.reset = !0);
  }
}
const VT = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: zT,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Qm(n, e, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: n.top - e.height - t.y,
    right: n.right - e.width + t.x,
    bottom: n.bottom - e.height + t.y,
    left: n.left - e.width - t.x
  };
}
function eg(n) {
  return [mn, Yn, Jn, gn].some(function(e) {
    return n[e] >= 0;
  });
}
function HT(n) {
  var e = n.state, t = n.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = da(e, {
    elementContext: "reference"
  }), l = da(e, {
    altBoundary: !0
  }), u = Qm(o, r), d = Qm(l, i, s), f = eg(u), h = eg(d);
  e.modifiersData[t] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: d,
    isReferenceHidden: f,
    hasPopperEscaped: h
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": f,
    "data-popper-escaped": h
  });
}
const WT = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: HT
};
function UT(n, e, t) {
  var r = cr(n), i = [gn, mn].indexOf(r) >= 0 ? -1 : 1, s = typeof t == "function" ? t(Object.assign({}, e, {
    placement: n
  })) : t, o = s[0], l = s[1];
  return o = o || 0, l = (l || 0) * i, [gn, Yn].indexOf(r) >= 0 ? {
    x: l,
    y: o
  } : {
    x: o,
    y: l
  };
}
function jT(n) {
  var e = n.state, t = n.options, r = n.name, i = t.offset, s = i === void 0 ? [0, 0] : i, o = d0.reduce(function(f, h) {
    return f[h] = UT(h, e.rects, s), f;
  }, {}), l = o[e.placement], u = l.x, d = l.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += d), e.modifiersData[r] = o;
}
const qT = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: jT
};
function KT(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = b0({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const GT = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: KT,
  data: {}
};
function JT(n) {
  return n === "x" ? "y" : "x";
}
function YT(n) {
  var e = n.state, t = n.options, r = n.name, i = t.mainAxis, s = i === void 0 ? !0 : i, o = t.altAxis, l = o === void 0 ? !1 : o, u = t.boundary, d = t.rootBoundary, f = t.altBoundary, h = t.padding, m = t.tether, g = m === void 0 ? !0 : m, y = t.tetherOffset, b = y === void 0 ? 0 : y, w = da(e, {
    boundary: u,
    rootBoundary: d,
    padding: h,
    altBoundary: f
  }), T = cr(e.placement), k = io(e.placement), S = !k, C = Cf(T), R = JT(C), I = e.modifiersData.popperOffsets, P = e.rects.reference, L = e.rects.popper, q = typeof b == "function" ? b(Object.assign({}, e.rects, {
    placement: e.placement
  })) : b, oe = typeof q == "number" ? {
    mainAxis: q,
    altAxis: q
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, q), ae = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, ke = {
    x: 0,
    y: 0
  };
  if (I) {
    if (s) {
      var Ee, rt = C === "y" ? mn : gn, Qe = C === "y" ? Jn : Yn, Ke = C === "y" ? "height" : "width", He = I[C], De = He + w[rt], Te = He - w[Qe], Oe = g ? -L[Ke] / 2 : 0, je = k === to ? P[Ke] : L[Ke], it = k === to ? -L[Ke] : -P[Ke], Qn = e.elements.arrow, gt = g && Qn ? Df(Qn) : {
        width: 0,
        height: 0
      }, st = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : m0(), _t = st[rt], bn = st[Qe], wt = Zo(0, P[Ke], gt[Ke]), Jt = S ? P[Ke] / 2 - Oe - wt - _t - oe.mainAxis : je - wt - _t - oe.mainAxis, ln = S ? -P[Ke] / 2 + Oe + wt + bn + oe.mainAxis : it + wt + bn + oe.mainAxis, Lt = e.elements.arrow && ka(e.elements.arrow), er = Lt ? C === "y" ? Lt.clientTop || 0 : Lt.clientLeft || 0 : 0, In = (Ee = ae == null ? void 0 : ae[C]) != null ? Ee : 0, Pt = He + Jt - In - er, vr = He + ln - In, Fi = Zo(g ? Pl(De, Pt) : De, He, g ? es(Te, vr) : Te);
      I[C] = Fi, ke[C] = Fi - He;
    }
    if (l) {
      var Yt, Ii = C === "x" ? mn : gn, gs = C === "x" ? Jn : Yn, Xt = I[R], vt = R === "y" ? "height" : "width", tr = Xt + w[Ii], Rn = Xt - w[gs], Ri = [mn, gn].indexOf(T) !== -1, yr = (Yt = ae == null ? void 0 : ae[R]) != null ? Yt : 0, vs = Ri ? tr : Xt - P[vt] - L[vt] - yr + oe.altAxis, br = Ri ? Xt + P[vt] + L[vt] - yr - oe.altAxis : Rn, nr = g && Ri ? _T(vs, Xt, br) : Zo(g ? vs : tr, Xt, g ? br : Rn);
      I[R] = nr, ke[R] = nr - Xt;
    }
    e.modifiersData[r] = ke;
  }
}
const XT = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: YT,
  requiresIfExists: ["offset"]
};
function ZT(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function QT(n) {
  return n === Fn(n) || !On(n) ? xf(n) : ZT(n);
}
function eM(n) {
  var e = n.getBoundingClientRect(), t = no(e.width) / n.offsetWidth || 1, r = no(e.height) / n.offsetHeight || 1;
  return t !== 1 || r !== 1;
}
function tM(n, e, t) {
  t === void 0 && (t = !1);
  var r = On(e), i = On(e) && eM(e), s = Ti(e), o = ro(n, i, t), l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (r || !r && !t) && ((Tr(e) !== "body" || Sf(s)) && (l = QT(e)), On(e) ? (u = ro(e, !0), u.x += e.clientLeft, u.y += e.clientTop) : s && (u.x = kf(s))), {
    x: o.left + l.scrollLeft - u.x,
    y: o.top + l.scrollTop - u.y,
    width: o.width,
    height: o.height
  };
}
function nM(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), r = [];
  n.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    t.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(l) {
      if (!t.has(l)) {
        var u = e.get(l);
        u && i(u);
      }
    }), r.push(s);
  }
  return n.forEach(function(s) {
    t.has(s.name) || i(s);
  }), r;
}
function rM(n) {
  var e = nM(n);
  return Id.reduce(function(t, r) {
    return t.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function iM(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function ui(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    t[r - 1] = arguments[r];
  return [].concat(t).reduce(function(i, s) {
    return i.replace(/%s/, s);
  }, n);
}
var Ui = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', sM = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', tg = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function oM(n) {
  n.forEach(function(e) {
    [].concat(Object.keys(e), tg).filter(function(t, r, i) {
      return i.indexOf(t) === r;
    }).forEach(function(t) {
      switch (t) {
        case "name":
          typeof e.name != "string" && console.error(ui(Ui, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
          break;
        case "enabled":
          typeof e.enabled != "boolean" && console.error(ui(Ui, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
          break;
        case "phase":
          Id.indexOf(e.phase) < 0 && console.error(ui(Ui, e.name, '"phase"', "either " + Id.join(", "), '"' + String(e.phase) + '"'));
          break;
        case "fn":
          typeof e.fn != "function" && console.error(ui(Ui, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "effect":
          e.effect != null && typeof e.effect != "function" && console.error(ui(Ui, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "requires":
          e.requires != null && !Array.isArray(e.requires) && console.error(ui(Ui, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(e.requiresIfExists) || console.error(ui(Ui, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + tg.map(function(r) {
            return '"' + r + '"';
          }).join(", ") + '; but "' + t + '" was provided.');
      }
      e.requires && e.requires.forEach(function(r) {
        n.find(function(i) {
          return i.name === r;
        }) == null && console.error(ui(sM, String(e.name), r, r));
      });
    });
  });
}
function aM(n, e) {
  var t = /* @__PURE__ */ new Set();
  return n.filter(function(r) {
    var i = e(r);
    if (!t.has(i))
      return t.add(i), !0;
  });
}
function lM(n) {
  var e = n.reduce(function(t, r) {
    var i = t[r.name];
    return t[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var ng = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", uM = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", rg = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function ig() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function cM(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, r = t === void 0 ? [] : t, i = e.defaultOptions, s = i === void 0 ? rg : i;
  return function(l, u, d) {
    d === void 0 && (d = s);
    var f = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, rg, s),
      modifiersData: {},
      elements: {
        reference: l,
        popper: u
      },
      attributes: {},
      styles: {}
    }, h = [], m = !1, g = {
      state: f,
      setOptions: function(T) {
        var k = typeof T == "function" ? T(f.options) : T;
        b(), f.options = Object.assign({}, s, f.options, k), f.scrollParents = {
          reference: as(l) ? Qo(l) : l.contextElement ? Qo(l.contextElement) : [],
          popper: Qo(u)
        };
        var S = rM(lM([].concat(r, f.options.modifiers)));
        if (f.orderedModifiers = S.filter(function(ae) {
          return ae.enabled;
        }), process.env.NODE_ENV !== "production") {
          var C = aM([].concat(S, f.options.modifiers), function(ae) {
            var ke = ae.name;
            return ke;
          });
          if (oM(C), cr(f.options.placement) === ku) {
            var R = f.orderedModifiers.find(function(ae) {
              var ke = ae.name;
              return ke === "flip";
            });
            R || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var I = hr(u), P = I.marginTop, L = I.marginRight, q = I.marginBottom, oe = I.marginLeft;
          [P, L, q, oe].some(function(ae) {
            return parseFloat(ae);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return y(), g.update();
      },
      forceUpdate: function() {
        if (!m) {
          var T = f.elements, k = T.reference, S = T.popper;
          if (!ig(k, S)) {
            process.env.NODE_ENV !== "production" && console.error(ng);
            return;
          }
          f.rects = {
            reference: tM(k, ka(S), f.options.strategy === "fixed"),
            popper: Df(S)
          }, f.reset = !1, f.placement = f.options.placement, f.orderedModifiers.forEach(function(ae) {
            return f.modifiersData[ae.name] = Object.assign({}, ae.data);
          });
          for (var C = 0, R = 0; R < f.orderedModifiers.length; R++) {
            if (process.env.NODE_ENV !== "production" && (C += 1, C > 100)) {
              console.error(uM);
              break;
            }
            if (f.reset === !0) {
              f.reset = !1, R = -1;
              continue;
            }
            var I = f.orderedModifiers[R], P = I.fn, L = I.options, q = L === void 0 ? {} : L, oe = I.name;
            typeof P == "function" && (f = P({
              state: f,
              options: q,
              name: oe,
              instance: g
            }) || f);
          }
        }
      },
      update: iM(function() {
        return new Promise(function(w) {
          g.forceUpdate(), w(f);
        });
      }),
      destroy: function() {
        b(), m = !0;
      }
    };
    if (!ig(l, u))
      return process.env.NODE_ENV !== "production" && console.error(ng), g;
    g.setOptions(d).then(function(w) {
      !m && d.onFirstUpdate && d.onFirstUpdate(w);
    });
    function y() {
      f.orderedModifiers.forEach(function(w) {
        var T = w.name, k = w.options, S = k === void 0 ? {} : k, C = w.effect;
        if (typeof C == "function") {
          var R = C({
            state: f,
            name: T,
            instance: g,
            options: S
          }), I = function() {
          };
          h.push(R || I);
        }
      });
    }
    function b() {
      h.forEach(function(w) {
        return w();
      }), h = [];
    }
    return g;
  };
}
var dM = [MT, GT, ET, f0, qT, VT, XT, xT, WT], _0 = /* @__PURE__ */ cM({
  defaultModifiers: dM
});
const fM = 5, w0 = /* @__PURE__ */ K({
  __name: "Backdrop",
  props: {
    color: { default: xu },
    width: { default: 100 },
    height: { default: 30 }
  },
  setup(n) {
    const e = n, t = G(), r = () => {
      const i = bf(fM), s = t.value.getContext("2d", { willReadFrequently: !0 });
      t.value.width = e.width, t.value.height = e.height, s.fillStyle = s.createPattern(i, "repeat"), s.fillRect(0, 0, e.width, e.height), s.fillStyle = e.color, s.fillRect(0, 0, e.width, e.height);
    };
    return bt(() => r()), En(() => e.color, () => r()), (i, s) => (E(), F("canvas", {
      ref_key: "canvas",
      ref: t,
      class: "canvas"
    }, null, 512));
  }
}), pM = { class: "color-input" }, hM = { class: "value" }, mM = /* @__PURE__ */ K({
  __name: "ColorInput",
  props: {
    modelValue: { default: "#ffffff" },
    preserveTransparency: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = gf(), s = G(), o = G(), l = G(!1);
    function u(m = !l.value) {
      l.value = m;
    }
    mr(o, () => u(!1));
    const d = ue({
      get: () => t.modelValue,
      set: (m) => r("update:modelValue", m)
    }), f = (m) => d.value = m.hexa, h = G();
    return bt(() => {
      !s.value || !h.value || _0(s.value, h.value, {
        placement: "bottom",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          }
        ]
      });
    }), (m, g) => (E(), F("div", pM, [
      O("div", Mn({
        ref_key: "wrapper",
        ref: s,
        tabindex: "0",
        class: [{ enabled: !X(i).disabled }, "wrapper"]
      }, m.$attrs, {
        onClick: g[0] || (g[0] = () => u())
      }), [
        ce(w0, {
          class: "preview",
          width: 40,
          height: 32,
          color: d.value
        }, null, 8, ["color"]),
        O("div", hM, re(d.value), 1)
      ], 16),
      O("div", {
        ref_key: "pickerWrapper",
        ref: h,
        class: "picker-wrapper"
      }, [
        yt(ce(_f, {
          ref_key: "picker",
          ref: o,
          class: "picker",
          color: d.value,
          defaults: [],
          "preserve-transparency": m.preserveTransparency,
          onSetcolor: f
        }, null, 8, ["color", "preserve-transparency"]), [
          [Kn, l.value && !X(i).disabled]
        ])
      ], 512)
    ]));
  }
});
const D0 = /* @__PURE__ */ J(mM, [["__scopeId", "data-v-d09fd8e5"]]), gM = ["aria-checked"], vM = /* @__PURE__ */ K({
  __name: "Toggle",
  props: {
    modelValue: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (s) => r("update:modelValue", s)
    });
    return (s, o) => (E(), F("button", {
      "aria-label": "toggle button",
      class: "toggle",
      role: "switch",
      type: "button",
      "aria-checked": i.value,
      onClick: o[0] || (o[0] = (l) => i.value = !i.value)
    }, null, 8, gM));
  }
});
const C0 = /* @__PURE__ */ J(vM, [["__scopeId", "data-v-0235b9d7"]]), yM = /* @__PURE__ */ K({
  __name: "TextArea",
  props: {
    modelValue: {},
    error: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(), s = gf(), o = ue({
      get: () => t.modelValue,
      set: (l) => {
        r("update:modelValue", l);
      }
    });
    return (l, u) => (E(), F("div", {
      class: de([{ enabled: !X(s).disabled, error: l.error }, "wrapper"])
    }, [
      yt(O("textarea", Mn({
        ref_key: "primitive",
        ref: i,
        "onUpdate:modelValue": u[0] || (u[0] = (d) => o.value = d),
        class: "textarea"
      }, l.$attrs), null, 16), [
        [_a, o.value]
      ])
    ], 2));
  }
});
const bM = /* @__PURE__ */ J(yM, [["__scopeId", "data-v-366ce596"]]), _M = { class: "rating" }, wM = /* @__PURE__ */ K({
  __name: "Rating",
  props: {
    ceil: { default: 5 },
    score: { default: 0 }
  },
  setup(n) {
    const e = n;
    return vf(() => {
      if (e.score > e.ceil)
        throw new Error(
          "The rating's ceil must be higher than or equal to the score."
        );
    }), (t, r) => (E(), F("div", _M, [
      (E(!0), F(ze, null, Je(t.ceil, (i) => (E(), F("i", {
        key: i,
        class: de(["star i-youcan-star", { active: i <= t.score }])
      }, null, 2))), 128))
    ]));
  }
});
const Af = /* @__PURE__ */ J(wM, [["__scopeId", "data-v-eabe9b85"]]), DM = { class: "rating" }, CM = ["onMousedown"], xM = /* @__PURE__ */ K({
  __name: "RatingInput",
  props: {
    ceil: { default: 5 },
    modelValue: { default: 0 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (o) => r("update:modelValue", o)
    }), s = (o) => {
      if (i.value === o) {
        i.value = 0;
        return;
      }
      i.value = o;
    };
    return vf(() => {
      if (t.modelValue > t.ceil)
        throw new Error(
          "The rating's ceil must be higher than or equal to the score."
        );
    }), vS(() => {
      if (t.modelValue > t.ceil)
        throw new Error(
          "The rating's ceil must be higher than or equal to the score."
        );
    }), (o, l) => (E(), F("div", DM, [
      (E(!0), F(ze, null, Je(o.ceil, (u) => (E(), F("i", {
        key: u,
        "i-youcan-star": "",
        class: de(["star", { active: u <= i.value }]),
        onMousedown: (d) => s(u)
      }, null, 42, CM))), 128))
    ]));
  }
});
const kM = /* @__PURE__ */ J(xM, [["__scopeId", "data-v-8c61dbb0"]]), SM = /* @__PURE__ */ K({
  __name: "Badge",
  props: {
    size: { default: 20 },
    state: { default: "neutral" }
  },
  setup(n) {
    return Zn((e) => ({
      "411ed155": `${e.size}px`
    })), (e, t) => (E(), F("span", {
      class: de(["badge", [`state-${e.state}`]])
    }, [
      fe(e.$slots, "default", {}, void 0, !0)
    ], 2));
  }
});
const Ef = /* @__PURE__ */ J(SM, [["__scopeId", "data-v-49d9eda0"]]), x0 = (n) => (Ye("data-v-df6339c9"), n = n(), Xe(), n), AM = ["data"], EM = /* @__PURE__ */ x0(() => /* @__PURE__ */ O("div", { class: "placeholder" }, [
  /* @__PURE__ */ O("i", { class: "i-youcan-image icon" })
], -1)), TM = [
  EM
], MM = {
  key: 1,
  class: "placeholder"
}, OM = /* @__PURE__ */ x0(() => /* @__PURE__ */ O("i", { class: "i-youcan-image icon" }, null, -1)), FM = [
  OM
], IM = /* @__PURE__ */ K({
  __name: "Thumbnail",
  props: {
    size: { default: "small" },
    src: {},
    alt: {},
    objectFit: { default: "cover" }
  },
  setup(n) {
    return Zn((e) => ({
      e0ab15be: e.objectFit
    })), (e, t) => (E(), F("div", {
      class: de(["thumbnail", [`size-${e.size}`]])
    }, [
      e.src ? (E(), F("object", {
        key: 0,
        data: e.src,
        type: "image/png",
        class: "image"
      }, TM, 8, AM)) : (E(), F("div", MM, FM))
    ], 2));
  }
});
const mo = /* @__PURE__ */ J(IM, [["__scopeId", "data-v-df6339c9"]]), RM = (n) => (Ye("data-v-4054e8aa"), n = n(), Xe(), n), NM = ["for"], BM = ["id", "multiple", "disabled"], $M = /* @__PURE__ */ RM(() => /* @__PURE__ */ O("span", { class: "input-shadow" }, null, -1)), LM = /* @__PURE__ */ K({
  __name: "BaseFileInput",
  props: {
    modelValue: {},
    limit: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "update:disabled"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(!1), s = pr.uid("input"), o = (l) => {
      var g;
      const u = l.target;
      let d = [];
      const { limit: f, modelValue: h, disabled: m } = t;
      if (!(!((g = u.files) != null && g.length) || h && h.length >= f || m)) {
        if (h && f > 1) {
          d = h;
          for (let y = 0; y < u.files.length; y++)
            d.push(u.files[y]);
          d = d.splice(0, f);
        } else
          d.push(u.files[0]);
        r("update:modelValue", d), u.value = "", i.value = !1;
      }
    };
    return (l, u) => (E(), F("label", {
      for: X(s),
      class: de(["dropzone", { disabled: t.disabled }])
    }, [
      O("input", {
        id: X(s),
        type: "file",
        multiple: t.limit > 1,
        class: de({ dragging: i.value }),
        disabled: t.disabled,
        onChange: o,
        onDragover: u[0] || (u[0] = ki((d) => i.value = !0, ["prevent"])),
        onDragleave: u[1] || (u[1] = ki((d) => i.value = !1, ["prevent"]))
      }, null, 42, BM),
      $M,
      O("div", null, [
        fe(l.$slots, "facade", {}, void 0, !0)
      ])
    ], 10, NM));
  }
});
const k0 = /* @__PURE__ */ J(LM, [["__scopeId", "data-v-4054e8aa"]]), S0 = (n) => (Ye("data-v-ba293819"), n = n(), Xe(), n), PM = {
  key: 1,
  class: "default-label-content"
}, zM = /* @__PURE__ */ S0(() => /* @__PURE__ */ O("i", { class: "i-youcan-upload-simple" }, null, -1)), VM = /* @__PURE__ */ S0(() => /* @__PURE__ */ O("div", null, "Browse your computer", -1)), HM = [
  zM,
  VM
], WM = /* @__PURE__ */ K({
  __name: "FileInput",
  props: {
    modelValue: {},
    limit: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (o) => {
        r("update:modelValue", o);
      }
    }), s = Kt();
    return (o, l) => (E(), ge(k0, {
      modelValue: i.value,
      "onUpdate:modelValue": l[0] || (l[0] = (u) => i.value = u),
      limit: o.limit,
      disabled: o.disabled
    }, {
      facade: ee(() => [
        O("div", {
          class: de(["label", { disabled: o.disabled }])
        }, [
          X(s).label ? fe(o.$slots, "label", { key: 0 }, void 0, !0) : (E(), F("div", PM, HM))
        ], 2)
      ]),
      _: 3
    }, 8, ["modelValue", "limit", "disabled"]));
  }
});
const UM = /* @__PURE__ */ J(WM, [["__scopeId", "data-v-ba293819"]]), jM = { class: "file-container" }, qM = { class: "file" }, KM = { class: "status-icon" }, GM = {
  key: 0,
  class: "icon-error i-youcan-warning-circle"
}, JM = {
  key: 1,
  class: "icon-loading i-youcan-circle-notch"
}, YM = {
  key: 2,
  class: "icon-success i-youcan-check-circle"
}, XM = { class: "name" }, ZM = { class: "actions" }, QM = {
  key: 0,
  class: "error"
}, eO = /* @__PURE__ */ K({
  __name: "UploadedFile",
  props: {
    file: {},
    progress: {},
    error: {}
  },
  emits: ["delete"],
  setup(n, { emit: e }) {
    const t = e;
    return (r, i) => (E(), F("div", jM, [
      O("div", qM, [
        O("div", KM, [
          r.error ? (E(), F("i", GM)) : r.progress ? (E(), F("i", JM)) : (E(), F("i", YM))
        ]),
        O("div", XM, re(r.file.name), 1),
        O("div", ZM, [
          O("i", {
            class: "icon-remove i-youcan-trash",
            onClick: i[0] || (i[0] = (s) => t("delete", r.file))
          })
        ])
      ]),
      r.error ? (E(), F("div", QM, re(r.error), 1)) : ne("", !0)
    ]));
  }
});
const tO = /* @__PURE__ */ J(eO, [["__scopeId", "data-v-46a5622a"]]), nO = (n) => (Ye("data-v-7babea95"), n = n(), Xe(), n), rO = /* @__PURE__ */ nO(() => /* @__PURE__ */ O("span", { class: "label-icon" }, [
  /* @__PURE__ */ O("i", { class: "i-youcan-upload-simple" })
], -1)), iO = { class: "label-text" }, sO = { class: "label-text-light" }, oO = {
  key: 0,
  class: "label-sub-text"
}, aO = /* @__PURE__ */ K({
  __name: "MediaInput",
  props: {
    modelValue: {},
    limit: { default: 1 },
    disabled: { type: Boolean, default: !1 },
    label: { default: "or drag and drop" },
    subLabel: {},
    highlightedLabel: { default: "Click to upload" }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (s) => {
        r("update:modelValue", s);
      }
    });
    return (s, o) => (E(), ge(k0, {
      modelValue: i.value,
      "onUpdate:modelValue": o[0] || (o[0] = (l) => i.value = l),
      limit: s.limit,
      disabled: s.disabled
    }, {
      facade: ee(() => [
        O("div", {
          class: de(["label", { disabled: s.disabled }])
        }, [
          rO,
          O("span", iO, [
            O("span", sO, re(s.highlightedLabel), 1),
            nn(),
            O("span", null, re(s.label), 1)
          ]),
          s.subLabel ? (E(), F("span", oO, re(s.subLabel), 1)) : ne("", !0)
        ], 2)
      ]),
      _: 1
    }, 8, ["modelValue", "limit", "disabled"]));
  }
});
const lO = /* @__PURE__ */ J(aO, [["__scopeId", "data-v-7babea95"]]), Tf = (n) => (Ye("data-v-a6ea7b71"), n = n(), Xe(), n), uO = {
  tabindex: "0",
  class: "file"
}, cO = { class: "actions" }, dO = /* @__PURE__ */ Tf(() => /* @__PURE__ */ O("i", { class: "i-youcan-eye" }, null, -1)), fO = /* @__PURE__ */ Tf(() => /* @__PURE__ */ O("i", { class: "i-youcan-trash" }, null, -1)), pO = { class: "popup" }, hO = /* @__PURE__ */ Tf(() => /* @__PURE__ */ O("i", { class: "i-youcan:x" }, null, -1)), mO = ["src", "alt"], gO = /* @__PURE__ */ K({
  __name: "UploadedMedia",
  props: {
    file: {},
    progress: {},
    error: {}
  },
  emits: ["delete"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue(() => t.file.type.startsWith("image/")), s = G(null), o = G(!1), l = (u = !o.value) => o.value = u;
    return bt(() => {
      pr.toDataUrl(t.file).then((u) => s.value = u).catch();
    }), (u, d) => (E(), F("div", uO, [
      O("div", null, [
        ce(X(mo), {
          class: "preview",
          alt: u.file.name,
          src: i.value && s.value ? s.value : void 0,
          size: "large"
        }, null, 8, ["alt", "src"])
      ]),
      O("div", cO, [
        ce(X(rn), {
          tabindex: "0",
          class: "action toggle-preview",
          size: "md",
          "icon-position": "only",
          "rounded-full": !0,
          type: "button",
          onClick: d[0] || (d[0] = (f) => l(!0))
        }, {
          icon: ee(() => [
            dO
          ]),
          _: 1
        }),
        ce(X(a0), {
          tabindex: "0",
          class: "action",
          size: "md",
          "icon-position": "only",
          "rounded-full": !0,
          type: "button",
          onClick: d[1] || (d[1] = (f) => r("delete", u.file))
        }, {
          icon: ee(() => [
            fO
          ]),
          _: 1
        })
      ]),
      o.value ? (E(), ge(Zv, {
        key: 0,
        to: "body"
      }, [
        O("div", pO, [
          ce(X(rn), {
            tabindex: "0",
            class: "action",
            size: "md",
            "icon-position": "only",
            "rounded-full": !0,
            type: "button",
            onClick: d[2] || (d[2] = (f) => l(!1))
          }, {
            icon: ee(() => [
              hO
            ]),
            _: 1
          }),
          O("img", {
            src: s.value ?? void 0,
            alt: u.file.name
          }, null, 8, mO)
        ])
      ])) : ne("", !0)
    ]));
  }
});
const vO = /* @__PURE__ */ J(gO, [["__scopeId", "data-v-a6ea7b71"]]), A0 = (n) => (Ye("data-v-5e0fc9f1"), n = n(), Xe(), n), yO = ["disabled"], bO = /* @__PURE__ */ A0(() => /* @__PURE__ */ O("i", { class: "i-youcan-minus" }, null, -1)), _O = ["id"], wO = /* @__PURE__ */ A0(() => /* @__PURE__ */ O("i", { class: "i-youcan-plus" }, null, -1)), DO = /* @__PURE__ */ K({
  __name: "Increment",
  props: {
    modelValue: { default: "1" },
    max: {},
    min: { default: 0 },
    step: { default: 1 },
    id: { default: pr.uid("increment_") },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (f) => {
        const h = Number(f);
        if (typeof t.max < "u" && h > t.max) {
          i.value = String(t.max);
          return;
        } else if (typeof t.min < "u" && h < t.min) {
          i.value = String(t.min);
          return;
        }
        r("update:modelValue", f);
      }
    }), s = G(), o = G(), l = () => {
      t.disabled || (i.value = String(Number(i.value) + t.step));
    }, u = () => {
      t.disabled || (i.value = String(Number(i.value) - t.step));
    }, d = (f) => {
      const h = parseInt(f.target.value);
      i.value = String(isNaN(h) ? 0 : h);
    };
    return bt(() => {
      var f, h, m;
      (f = s.value) == null || f.addEventListener("keypress", (g) => {
        (t.max && Number(i.value) >= t.max || t.min && Number(i.value) <= t.min) && g.preventDefault();
      }), (h = s.value) == null || h.addEventListener("keydown", (g) => {
        (g.key === "ArrowUp" || g.key === "ArrowDown") && g.preventDefault();
      }), (m = o.value) == null || m.addEventListener("keydown", (g) => {
        g.key === "ArrowUp" && (g.preventDefault(), l()), g.key === "ArrowDown" && (g.preventDefault(), u());
      });
    }), (f, h) => (E(), F("div", {
      ref_key: "container",
      ref: o,
      class: "increment",
      tabindex: "0",
      disabled: f.disabled
    }, [
      ce(rn, {
        size: "xs",
        "icon-position": "only",
        disabled: f.disabled,
        onClick: u
      }, {
        icon: ee(() => [
          bO
        ]),
        _: 1
      }, 8, ["disabled"]),
      yt(O("input", {
        id: f.id,
        ref_key: "input",
        ref: s,
        "onUpdate:modelValue": h[0] || (h[0] = (m) => i.value = m),
        class: "input",
        tabindex: "-1",
        onInput: d
      }, null, 40, _O), [
        [_a, i.value]
      ]),
      ce(rn, {
        size: "xs",
        "icon-position": "only",
        disabled: f.disabled,
        onClick: l
      }, {
        icon: ee(() => [
          wO
        ]),
        _: 1
      }, 8, ["disabled"])
    ], 8, yO));
  }
});
const E0 = /* @__PURE__ */ J(DO, [["__scopeId", "data-v-5e0fc9f1"]]), CO = { class: "tag-item" }, xO = {
  key: 1,
  class: "color-picker-container"
}, kO = { class: "text" }, SO = /* @__PURE__ */ K({
  __name: "TagItem",
  props: {
    modelValue: {},
    type: { default: "text" }
  },
  emits: ["update:modelValue", "remove"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (h) => r("update:modelValue", h)
    }), s = ue({
      get: () => i.value.hexColor || "#eb5685",
      set: (h) => i.value = Object.assign({}, i.value, { hexColor: h })
    }), o = G(!1), l = G(), u = (h = !o.value) => o.value = h, d = (h) => s.value = h.hexa, f = () => r("remove");
    return mr(l, () => u(!1)), (h, m) => (E(), F("div", CO, [
      h.type === "color" ? (E(), ge(w0, {
        key: 0,
        class: "preview",
        width: 15,
        height: 15,
        color: s.value,
        onClick: u
      }, null, 8, ["color"])) : ne("", !0),
      h.type === "color" ? (E(), F("div", xO, [
        yt(ce(_f, {
          ref_key: "colorPicker",
          ref: l,
          color: s.value,
          defaults: [],
          onSetcolor: d
        }, null, 8, ["color"]), [
          [Kn, o.value]
        ])
      ])) : ne("", !0),
      O("span", kO, re(i.value.label), 1),
      O("i", {
        class: "i-youcan-x icon",
        onClick: f
      })
    ]));
  }
});
const AO = /* @__PURE__ */ J(SO, [["__scopeId", "data-v-c275f1c2"]]), EO = ["disabled", "error"], TO = ["placeholder"], MO = /* @__PURE__ */ K({
  __name: "Tag",
  props: {
    modelValue: {},
    type: { default: "text" },
    max: {},
    placeholder: { default: "Add tag" },
    disabled: { type: Boolean, default: !1 },
    error: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(), s = G(), o = G(""), l = ue({
      get: () => t.modelValue,
      set: (f) => r("update:modelValue", f)
    }), u = (f, h) => {
      t.disabled || (l.value = pr.updateArray(l.value, f, h));
    }, d = (f) => {
      t.disabled || (l.value = pr.removeFromArray(l.value, f));
    };
    return bt(() => {
      var f, h;
      (f = i.value) == null || f.addEventListener("keydown", (m) => {
        if (m.key === "Enter") {
          if (m.preventDefault(), !o.value || typeof t.max == "number" && l.value.length >= t.max)
            return;
          l.value = l.value.concat({
            label: o.value
          }), o.value = "";
        }
        m.key === "Backspace" && !o.value && d(l.value.length - 1);
      }), (h = s.value) == null || h.addEventListener("click", (m) => {
        var g;
        m.target === s.value && ((g = i.value) == null || g.focus());
      });
    }), (f, h) => (E(), F("div", {
      ref_key: "tagsContainer",
      ref: s,
      class: "tag",
      tabindex: "0",
      disabled: f.disabled,
      error: f.error
    }, [
      (E(!0), F(ze, null, Je(l.value, (m, g) => (E(), ge(AO, {
        key: `${m.label}-${g}`,
        "model-value": l.value[g],
        type: f.type,
        "onUpdate:modelValue": (y) => u(g, y),
        onRemove: (y) => d(g)
      }, null, 8, ["model-value", "type", "onUpdate:modelValue", "onRemove"]))), 128)),
      yt(O("input", {
        ref_key: "tagInput",
        ref: i,
        "onUpdate:modelValue": h[0] || (h[0] = (m) => o.value = m),
        type: "text",
        class: "tag-input",
        placeholder: f.placeholder
      }, null, 8, TO), [
        [Kn, typeof f.max > "u" || l.value.length < f.max],
        [_a, o.value]
      ])
    ], 8, EO));
  }
});
const OO = /* @__PURE__ */ J(MO, [["__scopeId", "data-v-6110ca90"]]), FO = (n) => (Ye("data-v-9845c155"), n = n(), Xe(), n), IO = { class: "label" }, RO = /* @__PURE__ */ FO(() => /* @__PURE__ */ O("i", { class: "chevron i-youcan-carret-down" }, null, -1)), NO = /* @__PURE__ */ K({
  __name: "MultiselectDropdown",
  props: {
    icon: {},
    label: {},
    searchable: { type: Boolean, default: !1 },
    loading: { type: Boolean },
    modelValue: {},
    items: {}
  },
  emits: ["update:modelValue", "scrollEnd"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Kt(), s = G(), o = G(), l = G(!1), u = (f = !l.value) => l.value = f;
    mr(s, () => u(!1), { ignore: [o] });
    function d(f, h) {
      if (!h)
        return r(
          "update:modelValue",
          pr.removeFromArray(
            t.modelValue,
            t.modelValue.map((m) => m.value).indexOf(f.value)
          )
        );
      r("update:modelValue", [...t.modelValue, f]);
    }
    return (f, h) => (E(), F("div", null, [
      O("button", {
        ref_key: "button",
        ref: o,
        type: "button",
        class: "dropdown-input",
        onClick: h[0] || (h[0] = () => u())
      }, [
        f.icon ? (E(), F("i", {
          key: 0,
          class: de(["icon", f.icon])
        }, null, 2)) : ne("", !0),
        O("span", IO, [
          O("span", null, re(f.label), 1),
          ce(X(Ef), { state: "info" }, {
            default: ee(() => [
              nn(re(f.modelValue.length), 1)
            ]),
            _: 1
          })
        ]),
        RO
      ], 512),
      l.value ? (E(), F("div", {
        key: 0,
        ref_key: "list",
        ref: s,
        class: "dropdown-wrapper"
      }, [
        ce(Cu, Mn({ class: "dropdown-list" }, { items: f.items, selected: f.modelValue, searchable: f.searchable, multiple: !0 }, {
          loading: f.loading,
          onToggle: d,
          onScrollEnd: h[1] || (h[1] = () => r("scrollEnd"))
        }), Fr({ _: 2 }, [
          X(i).accessory ? {
            name: "accessory",
            fn: ee((m) => [
              fe(f.$slots, "accessory", $l(Ll(m)), void 0, !0)
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["loading"])
      ], 512)) : ne("", !0)
    ]));
  }
});
const BO = /* @__PURE__ */ J(NO, [["__scopeId", "data-v-9845c155"]]), $O = { class: "status" }, LO = /* @__PURE__ */ K({
  __name: "StaticStatus",
  props: {
    status: {}
  },
  setup(n) {
    Zn((t) => ({
      "4e900950": t.status.color,
      "30cde471": t.status.labelColor || "var(--base-white)"
    }));
    const e = n;
    return (t, r) => (E(), F("div", $O, re(e.status.label), 1));
  }
});
const T0 = /* @__PURE__ */ J(LO, [["__scopeId", "data-v-2a3832ff"]]), PO = (n) => (Ye("data-v-64bb98bb"), n = n(), Xe(), n), zO = { class: "wrapper" }, VO = { class: "static-status" }, HO = /* @__PURE__ */ PO(() => /* @__PURE__ */ O("i", { class: "icon i-youcan-caret-down" }, null, -1)), WO = { class: "status-list-wrapper" }, UO = ["onClick"], jO = { class: "label" }, qO = /* @__PURE__ */ K({
  __name: "EditableStatus",
  props: {
    statuses: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    Zn((d) => ({
      "24e41f2a": u.value.color,
      "18f29cc7": u.value.labelColor
    }));
    const t = n, r = e, i = G(), s = G(), o = G(!1), l = (d = !o.value) => o.value = d;
    mr(i, () => l(!1), { ignore: [s] });
    const u = ue({
      get: () => t.modelValue,
      set: (d) => {
        l(!1), r("update:modelValue", d);
      }
    });
    return (d, f) => (E(), F("div", zO, [
      O("button", {
        ref_key: "button",
        ref: s,
        type: "button",
        class: "editable-status",
        onClick: f[0] || (f[0] = () => l())
      }, [
        O("span", VO, re(u.value.label), 1),
        HO
      ], 512),
      O("div", WO, [
        yt(O("div", {
          ref_key: "list",
          ref: i,
          class: "status-list"
        }, [
          (E(!0), F(ze, null, Je(d.statuses, (h) => (E(), F("button", {
            key: h.value,
            type: "button",
            class: "status-list-item",
            onClick: (m) => u.value = h
          }, [
            O("span", {
              class: "color",
              style: Tn({ backgroundColor: h.color })
            }, null, 4),
            O("span", jO, re(h.label), 1)
          ], 8, UO))), 128))
        ], 512), [
          [Kn, o.value]
        ])
      ])
    ]));
  }
});
const M0 = /* @__PURE__ */ J(qO, [["__scopeId", "data-v-64bb98bb"]]), KO = ["disabled"], GO = { class: "text" }, JO = /* @__PURE__ */ K({
  __name: "Day",
  props: {
    edge: {},
    date: {},
    isToday: { type: Boolean },
    isSelected: { type: Boolean },
    inCurrentMonth: { type: Boolean, default: !0 },
    format: { default: "numeric" },
    disabled: { type: Boolean }
  },
  setup(n) {
    const { format: e, date: t } = n, r = () => e === "numeric" ? t.getDate() : Wt.getAlphabeticalWeekday(t);
    return (i, s) => (E(), F("button", {
      type: "button",
      disabled: i.disabled,
      class: de(["day", { "is-selected": i.isSelected, "is-today": i.isToday, [`edge--${i.edge}`]: !0, "out-of-month": !i.inCurrentMonth, [`format-${e}`]: !0 }])
    }, [
      O("span", GO, re(r()), 1)
    ], 10, KO));
  }
});
const sg = /* @__PURE__ */ J(JO, [["__scopeId", "data-v-cec3b68c"]]), O0 = (n) => (Ye("data-v-d01f2915"), n = n(), Xe(), n), YO = { class: "month-switcher" }, XO = /* @__PURE__ */ O0(() => /* @__PURE__ */ O("i", { class: "i-youcan-caret-left" }, null, -1)), ZO = { class: "text" }, QO = /* @__PURE__ */ O0(() => /* @__PURE__ */ O("i", { class: "i-youcan-caret-right" }, null, -1)), e2 = /* @__PURE__ */ K({
  __name: "MonthSwitcher",
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (o) => r("update:modelValue", o)
    }), s = (o) => {
      const l = new Date(i.value);
      l.setMonth(l.getMonth() + (o ? 1 : -1)), i.value = l;
    };
    return (o, l) => (E(), F("div", YO, [
      ce(rn, {
        "icon-position": "only",
        size: "xs",
        type: "button",
        onClick: l[0] || (l[0] = (u) => s(!1))
      }, {
        icon: ee(() => [
          XO
        ]),
        _: 1
      }),
      O("span", ZO, re(X(Wt).getAlphabeticalMonth(i.value)) + " " + re(i.value.getFullYear()), 1),
      ce(rn, {
        "icon-position": "only",
        size: "xs",
        type: "button",
        onClick: l[1] || (l[1] = (u) => s(!0))
      }, {
        icon: ee(() => [
          QO
        ]),
        _: 1
      })
    ]));
  }
});
const t2 = /* @__PURE__ */ J(e2, [["__scopeId", "data-v-d01f2915"]]), n2 = { class: "date-picker" }, r2 = { class: "days-container" }, i2 = /* @__PURE__ */ K({
  __name: "DatePicker",
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(new Date()), s = ue(() => i.value), o = ue({
      get: () => t.modelValue,
      set: (y) => r("update:modelValue", y)
    }), l = ue(() => Wt.getDaysForDateMonthCycle(s.value)), u = Wt.weekDays(), d = G(!1), f = (y) => {
      var b, w, T;
      if (d.value = !d.value, !((b = o.value) != null && b.start) || (w = o.value) != null && w.end) {
        if (!d.value)
          return;
        o.value = {
          start: y.date,
          end: void 0
        };
        return;
      }
      if (!((T = o.value) != null && T.end)) {
        const k = Wt.biggerThan(o.value.start, y.date);
        o.value = {
          start: k ? y.date : o.value.start,
          end: k ? o.value.start : y.date
        };
      }
    }, h = (y) => {
      var b, w;
      if (!(!((b = o.value) != null && b.start) || !d.value) && (!((w = o.value) != null && w.end) || d.value)) {
        if (Wt.isSameDay(y.date, o.value.start))
          return;
        const T = Wt.biggerThan(o.value.start, y.date);
        o.value = {
          start: T ? y.date : o.value.start,
          end: o.value.end && T ? o.value.end : T ? o.value.start : y.date
        };
      }
    }, m = (y) => {
      var b, w, T, k;
      if (!((b = o.value) != null && b.start) && !((w = o.value) != null && w.end))
        return y.isToday ? "both" : "none";
      if (o.value.start && o.value.end) {
        if (Wt.isSameDay(o.value.start, o.value.end))
          return "both";
        if (Wt.isBetween(y.date, o.value.start, o.value.end))
          return "middle";
      }
      return o.value.start && Wt.isSameDay(y.date, o.value.start) ? "start" : o.value.end && Wt.isSameDay(y.date, o.value.end) ? "end" : (T = o.value) != null && T.start && ((k = o.value) != null && k.end) && y.isToday ? "both" : "none";
    }, g = (y) => {
      var b, w, T, k;
      return (b = o.value) != null && b.start && Wt.isSameDay(y.date, o.value.start) || (w = o.value) != null && w.end && Wt.isSameDay(y.date, o.value.end) ? !0 : !((T = o.value) != null && T.start) || !((k = o.value) != null && k.end) ? !1 : Wt.isBetween(y.date, o.value.start, o.value.end);
    };
    return (y, b) => (E(), F("div", n2, [
      ce(t2, {
        modelValue: i.value,
        "onUpdate:modelValue": b[0] || (b[0] = (w) => i.value = w)
      }, null, 8, ["modelValue"]),
      O("div", r2, [
        (E(!0), F(ze, null, Je(X(u), (w) => (E(), ge(sg, {
          key: w.getTime(),
          date: w,
          edge: "none",
          "is-selected": !1,
          "is-today": !1,
          disabled: !0,
          "in-current-month": !1,
          format: "2-letters"
        }, null, 8, ["date"]))), 128)),
        (E(!0), F(ze, null, Je(l.value, (w) => (E(), ge(sg, {
          key: w.date.getTime(),
          date: w.date,
          edge: m(w),
          "is-selected": g(w),
          "is-today": w.isToday,
          disabled: !1,
          "in-current-month": w.inCurrentMonth,
          onClick: (T) => f(w),
          onMouseover: (T) => h(w)
        }, null, 8, ["date", "edge", "is-selected", "is-today", "in-current-month", "onClick", "onMouseover"]))), 128))
      ])
    ]));
  }
});
const F0 = /* @__PURE__ */ J(i2, [["__scopeId", "data-v-003e4b58"]]), s2 = (n) => (Ye("data-v-8a1415fb"), n = n(), Xe(), n), o2 = { class: "date-input" }, a2 = /* @__PURE__ */ s2(() => /* @__PURE__ */ O("i", { class: "i-youcan-calendar-blank" }, null, -1)), l2 = { class: "date-picker-container" }, u2 = /* @__PURE__ */ K({
  __name: "DateInput",
  props: {
    modelValue: {},
    disabled: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (u) => r("update:modelValue", u)
    }), s = G(!1), o = G(), l = (u = !s.value) => {
      t.disabled || (s.value = u);
    };
    return mr(o, () => l(!1)), (u, d) => (E(), F("div", o2, [
      ce(Zr, {
        size: "sm",
        "icon-position": "right",
        class: "input-trigger",
        disabled: u.disabled,
        type: "button",
        onClick: d[0] || (d[0] = (f) => l())
      }, {
        icon: ee(() => [
          a2
        ]),
        default: ee(() => [
          yt(O("span", null, re(X(Wt).getCalendarDay(i.value.start, "Start")) + " - " + re(X(Wt).getCalendarDay(i.value.end, "End")), 513), [
            [Kn, i.value.start || i.value.start]
          ]),
          yt(O("span", null, "Select date range", 512), [
            [Kn, !i.value.start && !i.value.start]
          ])
        ]),
        _: 1
      }, 8, ["disabled"]),
      O("div", l2, [
        yt(ce(F0, {
          ref_key: "datePicker",
          ref: o,
          modelValue: i.value,
          "onUpdate:modelValue": d[1] || (d[1] = (f) => i.value = f)
        }, null, 8, ["modelValue"]), [
          [Kn, s.value]
        ])
      ])
    ]));
  }
});
const c2 = /* @__PURE__ */ J(u2, [["__scopeId", "data-v-8a1415fb"]]), d2 = /* @__PURE__ */ K({
  __name: "Percentage",
  props: {
    percentage: {},
    type: { default: null }
  },
  setup(n) {
    return (e, t) => (E(), F("div", {
      class: de(["percentage", [e.type]])
    }, re(e.percentage) + "% ", 3));
  }
});
const I0 = /* @__PURE__ */ J(d2, [["__scopeId", "data-v-fa5ae7b5"]]), f2 = ["disabled"], p2 = { class: "label" }, h2 = /* @__PURE__ */ K({
  __name: "Tab",
  props: {
    label: {},
    active: { type: Boolean },
    disabled: { type: Boolean },
    errorCount: {}
  },
  setup(n) {
    return (e, t) => (E(), F("button", {
      disabled: e.disabled || e.active,
      class: de(["tab", { active: e.active, disabled: e.disabled, error: e.errorCount }])
    }, [
      O("div", p2, re(e.label), 1),
      e.errorCount ? (E(), ge(Ef, {
        key: 0,
        state: "danger",
        size: 20
      }, {
        default: ee(() => [
          nn(re(e.errorCount), 1)
        ]),
        _: 1
      })) : ne("", !0)
    ], 10, f2));
  }
});
const m2 = /* @__PURE__ */ J(h2, [["__scopeId", "data-v-e9da319b"]]);
const g2 = {}, v2 = { class: "list" };
function y2(n, e) {
  return E(), F("div", v2, [
    fe(n.$slots, "default", {}, void 0, !0)
  ]);
}
const b2 = /* @__PURE__ */ J(g2, [["render", y2], ["__scopeId", "data-v-1edfcf8e"]]), _2 = (n) => (Ye("data-v-d351503d"), n = n(), Xe(), n), w2 = { class: "sidebar-header" }, D2 = /* @__PURE__ */ _2(() => /* @__PURE__ */ O("i", { class: "i-youcan:list" }, null, -1)), C2 = [
  D2
], x2 = { class: "item-label" }, k2 = { class: "sidebar-items upper" }, S2 = { class: "sidebar-items lower" }, A2 = /* @__PURE__ */ K({
  __name: "Sidebar",
  props: {
    collapsed: { type: Boolean, default: !1 }
  },
  emits: ["collapse"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(t.collapsed), s = (o = !i.value) => {
      i.value = o, r("collapse", o);
    };
    return (o, l) => (E(), F("aside", {
      class: de(["sidebar", { collapsed: i.value }])
    }, [
      O("div", w2, [
        O("button", {
          class: "item-icon",
          onClick: l[0] || (l[0] = () => s())
        }, C2),
        O("div", x2, [
          fe(o.$slots, "header", {}, void 0, !0)
        ])
      ]),
      O("div", k2, [
        fe(o.$slots, "items", {}, void 0, !0)
      ]),
      O("div", S2, [
        fe(o.$slots, "lower-items", {}, void 0, !0)
      ])
    ], 2));
  }
});
const E2 = /* @__PURE__ */ J(A2, [["__scopeId", "data-v-d351503d"]]), T2 = (n) => (Ye("data-v-139be6ee"), n = n(), Xe(), n), M2 = { class: "item-icon" }, O2 = { class: "item-label" }, F2 = /* @__PURE__ */ T2(() => /* @__PURE__ */ O("i", { class: "icon i-youcan-caret-down" }, null, -1)), I2 = [
  F2
], R2 = /* @__PURE__ */ K({
  __name: "SidebarItem",
  props: {
    icon: {},
    label: {},
    count: {},
    active: { type: Boolean }
  },
  setup(n) {
    Zn((o) => ({
      "6260bb9e": t.value
    }));
    const e = n, t = G(1), r = G(), i = G(!!e.active), s = () => i.value = !i.value;
    return bt(() => {
      t.value = r.value ? r.value.children.length : 0;
    }), (o, l) => (E(), F("div", null, [
      O("button", {
        class: de([{ active: o.active }, "sidebar-item"]),
        onClick: l[0] || (l[0] = () => t.value && s())
      }, [
        O("div", M2, [
          O("i", {
            class: de(["icon", o.icon])
          }, null, 2)
        ]),
        O("div", O2, re(o.label), 1),
        t.value ? (E(), F("div", {
          key: 0,
          class: de(["expand-icon", { rotate: i.value }])
        }, I2, 2)) : ne("", !0)
      ], 2),
      ce(eo, { name: "toggle" }, {
        default: ee(() => [
          t.value && i.value ? (E(), F("div", {
            key: 0,
            ref_key: "subitems",
            ref: r,
            class: "subitems"
          }, [
            fe(o.$slots, "default", {}, void 0, !0)
          ], 512)) : ne("", !0)
        ]),
        _: 3
      })
    ]));
  }
});
const N2 = /* @__PURE__ */ J(R2, [["__scopeId", "data-v-139be6ee"]]), B2 = { class: "subitem-text" }, $2 = /* @__PURE__ */ K({
  __name: "SidebarSubitem",
  props: {
    label: {},
    active: { type: Boolean }
  },
  setup(n) {
    return (e, t) => (E(), F("button", {
      class: de(["sidebar-subitem", { active: e.active }])
    }, [
      O("span", B2, re(e.label), 1)
    ], 2));
  }
});
const L2 = /* @__PURE__ */ J($2, [["__scopeId", "data-v-c721a415"]]);
const P2 = {}, z2 = { class: "topbar" }, V2 = { class: "topbar-start" }, H2 = { class: "topbar-end" };
function W2(n, e) {
  return E(), F("div", z2, [
    O("div", V2, [
      fe(n.$slots, "start", {}, void 0, !0)
    ]),
    O("div", H2, [
      fe(n.$slots, "end", {}, void 0, !0)
    ])
  ]);
}
const U2 = /* @__PURE__ */ J(P2, [["render", W2], ["__scopeId", "data-v-f493dd23"]]);
const j2 = {}, q2 = { class: "action-bar" };
function K2(n, e) {
  return E(), F("div", q2, [
    fe(n.$slots, "default", {}, void 0, !0)
  ]);
}
const G2 = /* @__PURE__ */ J(j2, [["render", K2], ["__scopeId", "data-v-64c8a9dd"]]);
const J2 = {}, Y2 = { class: "settings-nav" }, X2 = { class: "header" }, Z2 = { class: "items" };
function Q2(n, e) {
  return E(), F("div", Y2, [
    O("div", X2, [
      fe(n.$slots, "header", {}, void 0, !0)
    ]),
    O("div", Z2, [
      fe(n.$slots, "items", {}, void 0, !0)
    ])
  ]);
}
const eF = /* @__PURE__ */ J(J2, [["render", Q2], ["__scopeId", "data-v-99649e7c"]]), tF = ["disabled"], nF = { class: "icon" }, rF = { class: "label" }, iF = /* @__PURE__ */ K({
  __name: "SettingsNavItem",
  props: {
    label: {},
    icon: {},
    active: { type: Boolean }
  },
  setup(n) {
    return (e, t) => (E(), F("button", {
      disabled: e.active,
      class: de([{ active: e.active }, "settings-nav-item"])
    }, [
      O("div", nF, [
        O("i", {
          class: de(e.icon)
        }, null, 2)
      ]),
      O("div", rF, re(e.label), 1)
    ], 10, tF));
  }
});
const sF = /* @__PURE__ */ J(iF, [["__scopeId", "data-v-a7859f70"]]), oF = ["href", "target"], aF = /* @__PURE__ */ K({
  __name: "Link",
  props: {
    href: {},
    label: {},
    target: { default: "_blank" }
  },
  setup(n) {
    return (e, t) => (E(), F("a", {
      href: e.href,
      target: e.target,
      class: "link",
      style: Tn({ font: "var(--text-sm-medium)", color: "var(--blue-600)", textDecoration: "none" })
    }, re(e.label), 13, oF));
  }
}), Bd = /* @__PURE__ */ K({
  __name: "Button",
  props: {
    label: {},
    iconName: {},
    size: { default: "sm" },
    disabled: { type: Boolean },
    iconPosition: {},
    roundedFull: { type: Boolean }
  },
  setup(n) {
    return (e, t) => (E(), ge(Zr, Mn(e.$props, { size: e.size }), Fr({
      default: ee(() => [
        nn(" " + re(e.label), 1)
      ]),
      _: 2
    }, [
      e.iconName ? {
        name: "icon",
        fn: ee(() => [
          O("i", {
            class: de(e.iconName)
          }, null, 2)
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["size"]));
  }
});
function lF(n) {
  switch (n) {
    case "thumbnail":
      return mo;
    case "link":
      return aF;
    case "status":
      return M0;
    case "static-status":
      return T0;
    case "percentage":
      return I0;
    case "button":
      return Bd;
    case "rating":
      return Af;
    case "toggle":
      return C0;
    case "counter":
      return E0;
    case "input":
      return ss;
    default:
      return;
  }
}
const R0 = (n, e, t, r = 6) => {
  const i = { top: 0, left: 0, currentPosition: t };
  if (n && e) {
    const s = e == null ? void 0 : e.getBoundingClientRect(), o = (n == null ? void 0 : n.clientHeight) || 0, l = (n == null ? void 0 : n.clientWidth) || 0, u = (e == null ? void 0 : e.clientHeight) || 0, d = (e == null ? void 0 : e.clientWidth) || 0, f = window.innerWidth, h = window.innerHeight, m = l + d + r > f;
    if (s) {
      let g = (l - d) / 2, y = s.top - (o + r), b = s.left - g;
      b = b < 0 ? r / 2 : b + l > f ? f - (l + r / 2) : b;
      const w = s.bottom + o + r, T = s.right + l + r;
      return i.currentPosition = "top", (t === "left" || t === "right") && !m ? (g = (o - u) / 2, y = s.top - g, y = y < 0 ? r / 2 : y + o > h ? h - (o + r / 2) : y, b = s.left - (l + r), i.currentPosition = "left", (t === "right" || b < 0) && T < f && (b = s.left + (d + r), i.currentPosition = "right")) : (t === "bottom" || y < 0) && w < h && (y = s.top + (u + r), i.currentPosition = "bottom"), i.top = y, i.left = b, i;
    }
    return i;
  }
  return i;
}, uF = /* @__PURE__ */ K({
  __name: "Tooltip",
  props: {
    label: {},
    position: { default: "top" }
  },
  setup(n) {
    const e = n, t = G(), r = G(), i = () => {
      var l;
      if (t.value && r.value) {
        const { left: u, top: d } = R0(t.value, r.value, e.position);
        (l = t.value) == null || l.setAttribute("style", `top:${d}px;left:${u}px`);
      }
    }, s = () => {
      var l, u;
      (l = t.value) != null && l.classList.contains("tooltip-trigger-hide") || (u = t.value) == null || u.classList.add("tooltip-trigger-hide");
    }, o = () => {
      var l;
      (l = t.value) == null || l.classList.remove("tooltip-trigger-hide"), i();
    };
    return bt(() => {
      var l;
      (l = t.value) == null || l.classList.remove("tooltip-trigger-hide"), i(), window.addEventListener("scroll", s);
    }), po(() => {
      window.removeEventListener("scroll", s);
    }), (l, u) => l.label ? (E(), F("div", {
      key: 0,
      ref_key: "tooltip",
      ref: r,
      class: de(["tooltip", l.position]),
      onMouseenter: o
    }, [
      O("span", {
        ref_key: "tooltipTrigger",
        ref: t,
        class: "tooltip-trigger"
      }, re(l.label), 513),
      fe(l.$slots, "default", {}, void 0, !0)
    ], 34)) : fe(l.$slots, "default", { key: 1 }, void 0, !0);
  }
});
const $d = /* @__PURE__ */ J(uF, [["__scopeId", "data-v-0e412f4b"]]), cF = {
  key: 0,
  class: "row-checker"
}, dF = { class: "text" }, fF = {
  key: 1,
  class: "text"
}, pF = {
  key: 3,
  class: "cell-actions"
}, hF = /* @__PURE__ */ K({
  __name: "TableRow",
  props: {
    row: {},
    columns: {},
    actions: {},
    index: {},
    selected: { type: Boolean },
    expended: { type: Boolean },
    isChild: { type: Boolean },
    data: {},
    originalRow: {}
  },
  emits: ["update:selected-rows", "update:expend", "update:sub-comp-model"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue(() => t.actions ? t.actions.map((f) => ({
      ...f,
      events: Object.assign(
        {},
        f.events,
        {
          click: () => {
            var h;
            (h = f.events) == null || h.click(t.originalRow ? t.originalRow : t.data[t.index].row);
          }
        }
      )
    })) : []), s = ue({
      get: () => t.selected || !1,
      set: (f) => {
        r("update:selected-rows", f);
      }
    }), o = ue({
      get: () => t.expended,
      set: (f) => {
        r("update:expend", f);
      }
    }), l = (f, h, m, g) => {
      r("update:sub-comp-model", {
        index: f,
        accessor: h,
        data: m,
        child: g
      });
    }, u = (f, h) => !f.criteria || f.criteria(h), d = (f) => f;
    return (f, h) => {
      const m = yS("TableRow", !0);
      return E(), F(ze, null, [
        O("tr", {
          class: de(["table-row", { selected: s.value, "expended-child": f.isChild, "expended-wrapper": f.expended }])
        }, [
          (E(!0), F(ze, null, Je(f.columns, (g) => {
            var y;
            return E(), F("td", {
              key: g.accessor,
              class: "table-cell"
            }, [
              g.accessor === "check" ? (E(), F("div", cF, [
                ce(ho, {
                  modelValue: s.value,
                  "onUpdate:modelValue": h[0] || (h[0] = (b) => s.value = b)
                }, null, 8, ["modelValue"])
              ])) : g.accessor === "_expand" && f.row.children && f.row.children.length > 0 ? (E(), ge(rn, {
                key: 1,
                size: "xs",
                "icon-position": "only",
                "rounded-full": "",
                onClick: h[1] || (h[1] = (b) => o.value = !o.value)
              }, {
                icon: ee(() => [
                  O("i", {
                    class: de(["", [o.value ? "i-youcan-carret-down" : "i-youcan-caret-right"]])
                  }, null, 2)
                ]),
                _: 1
              })) : f.row.row[g.accessor] ? (E(), F(ze, { key: 2 }, [
                f.row.row[g.accessor].isString ? (E(), F("div", {
                  key: 0,
                  class: de(["text-column", { na: f.row.row[g.accessor].value.toString().toLocaleLowerCase() === "n/a", "cell-full-width": g.fullContent }])
                }, [
                  g.tooltip ? (E(), ge($d, {
                    key: 0,
                    label: g.tooltip,
                    position: "top"
                  }, {
                    default: ee(() => [
                      O("span", dF, re(f.row.row[g.accessor].value), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"])) : (E(), F("span", fF, re(f.row.row[g.accessor].value), 1))
                ], 2)) : f.row.row[g.accessor].isString ? ne("", !0) : (E(), ge(bS(f.row.row[g.accessor].component), Mn({ key: 1 }, d(f.row.row[g.accessor].value).data, {
                  class: { "cell-full-width": g.fullContent },
                  "onUpdate:modelValue": (b) => l(f.index, g.accessor, b, b.child || !1)
                }, Zc(d(f.row.row[g.accessor].value).events || {})), null, 16, ["class", "onUpdate:modelValue"]))
              ], 64)) : ne("", !0),
              g.accessor === "actions" && ((y = f.actions) != null && y.length) ? (E(), F("div", pF, [
                (E(!0), F(ze, null, Je(i.value, (b) => (E(), F(ze, {
                  key: b.label
                }, [
                  b.tooltip && u(b, f.isChild && f.originalRow ? f.originalRow : f.data[f.index]) ? (E(), ge($d, {
                    key: 0,
                    label: b.tooltip,
                    position: "top"
                  }, {
                    default: ee(() => [
                      ce(Bd, Mn({
                        size: "xs",
                        data: f.data,
                        "icon-name": b.iconName,
                        label: b.label,
                        "rounded-full": !0,
                        "icon-position": "only"
                      }, Zc(b.events || {})), null, 16, ["data", "icon-name", "label"])
                    ]),
                    _: 2
                  }, 1032, ["label"])) : u(b, f.isChild && f.originalRow ? f.originalRow : f.data[f.index]) ? (E(), ge(Bd, Mn({
                    key: 1,
                    size: "xs",
                    data: f.data,
                    "icon-name": b.iconName,
                    label: b.label,
                    "rounded-full": !0,
                    "icon-position": "only"
                  }, Zc(b.events || {})), null, 16, ["data", "icon-name", "label"])) : ne("", !0)
                ], 64))), 128))
              ])) : ne("", !0)
            ]);
          }), 128))
        ], 2),
        o.value && f.row ? (E(!0), F(ze, { key: 0 }, Je(f.row.children, (g, y) => (E(), ge(m, {
          key: y,
          index: y,
          row: g,
          data: f.data,
          "is-child": "",
          columns: f.columns,
          actions: f.actions,
          "original-row": f.data[f.index].children[y],
          "onUpdate:subCompModel": (b) => l(y, b.accessor, b.data, !0)
        }, null, 8, ["index", "row", "data", "columns", "actions", "original-row", "onUpdate:subCompModel"]))), 128)) : ne("", !0)
      ], 64);
    };
  }
});
const mF = /* @__PURE__ */ J(hF, [["__scopeId", "data-v-bfb78bc9"]]), gF = { class: "table-container" }, vF = { class: "table" }, yF = { class: "table-head" }, bF = { key: 1 }, _F = ["onClick"], wF = { class: "table-body" }, DF = /* @__PURE__ */ K({
  __name: "Table",
  props: {
    columns: {},
    data: {},
    actions: {},
    selectable: { type: Boolean },
    selectedRows: {},
    actionsText: { default: "Actions" }
  },
  emits: ["sort", "update:data", "update:selected-rows", "check", "update:cell"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(Array(t.data.length).fill(!1)), s = ue(() => t.data.some((w) => w.children && w.children.length > 0)), o = ue(() => {
      const w = [
        t.selectable ? { accessor: "check", label: "Checkbox" } : null,
        s.value ? { accessor: "_expand", label: "Expand" } : null,
        ...t.columns
      ];
      return t.actions && t.actions.length > 0 && w.push({ accessor: "actions", label: t.actionsText }), w.filter((T) => T !== null);
    }), l = ue(
      () => t.data.map(({ row: w, children: T }) => {
        const k = {
          row: {},
          children: []
        };
        function S(C) {
          const R = {};
          return Object.keys(C).forEach((I) => {
            const P = C[I];
            if (typeof P > "u")
              return null;
            R[I] = {
              value: P,
              accessor: I,
              isString: typeof P != "object",
              component: typeof P == "object" ? lF(P.variant) : void 0
            };
          }), R;
        }
        return k.row = S(w), T && (k.children = T.map((C) => ({ row: S(C) }))), k;
      }).filter((w) => w !== null)
    ), u = (w) => w.sortable && w.sortable !== "none", d = (w, T) => {
      if (u(w) === !1)
        return !1;
      r("sort", w, T);
    };
    function f(w) {
      return t.data.map(({ row: T, children: k }, S) => {
        function C(L, q) {
          const oe = {};
          return Object.keys(L).forEach((ae) => {
            const ke = l.value[S].row[ae], Ee = L[ae];
            if (typeof ke > "u" || typeof Ee != "object")
              return oe[ae] = Ee;
            oe[ae] = q[ae].value;
          }), oe;
        }
        const R = w[S], I = k ? Fd(k) : [];
        return {
          row: C(T, R.row),
          children: I.map((L, q) => C(L, R.children ? R.children[q].row : {}))
        };
      });
    }
    function h(w, T, k, S) {
      if (typeof S > "u") {
        const C = Od(l.value), R = t.data[w].row[T];
        C.value[w].row[T].value = {
          variant: R.variant,
          data: {
            ...R.data,
            modelValue: k
          }
        };
        const I = f(C.value);
        r("update:cell", { row: I[w].row, accessor: T }), r("update:data", I);
      } else {
        const C = Od(l.value), R = t.data[S].children[w][T];
        C.value[S].children[w].row[T].value = {
          variant: R.variant,
          data: {
            ...R.data,
            modelValue: k
          }
        };
        const I = f(C.value);
        r("update:cell", { row: I[S].children[w], accessor: T }), r("update:data", I);
      }
    }
    const m = ue({
      get: () => t.selectedRows && t.selectedRows.length ? t.data.map((w) => t.selectedRows.some((T) => T.row.id === w.row.id)) : Array(t.data.length).fill(!1),
      set: (w) => {
        r("update:selected-rows", t.data.filter((k, S) => w[S]));
        const T = w.map((k, S) => k ? S : null).filter((k) => k !== null);
        r("check", T);
      }
    }), g = ue(() => m.value.every((w) => w)), y = (w) => m.value = Array(t.data.length).fill(w);
    function b(w, T) {
      m.value = m.value.map((k, S) => S === w ? T : k);
    }
    return (w, T) => (E(), F("div", gF, [
      O("table", vF, [
        O("thead", yF, [
          (E(!0), F(ze, null, Je(o.value, (k, S) => (E(), F("th", {
            key: k.accessor,
            class: "head-column",
            style: Tn({ width: k.size ?? void 0 })
          }, [
            k.accessor === "check" ? (E(), ge(ho, {
              key: 0,
              modelValue: g.value,
              "onUpdate:modelValue": [
                T[0] || (T[0] = (C) => g.value = C),
                y
              ]
            }, null, 8, ["modelValue"])) : k.accessor === "_expand" ? (E(), F("span", bF)) : (E(), F("span", {
              key: 2,
              class: de(["text", { "text-sortable": u(k) }]),
              onClick: (C) => d(k, S)
            }, [
              nn(re(k.label) + " ", 1),
              u(k) ? (E(), F("i", {
                key: 0,
                class: de(["i-youcan-caret-down", k.sortable]),
                tabindex: "1"
              }, null, 2)) : ne("", !0)
            ], 10, _F))
          ], 4))), 128))
        ]),
        O("tbody", wF, [
          (E(!0), F(ze, null, Je(l.value, (k, S) => (E(), ge(mF, {
            key: S,
            index: S,
            row: k,
            columns: o.value,
            selected: m.value[S],
            expended: i.value[S],
            actions: w.actions,
            data: w.data,
            "onUpdate:selectedRows": (C) => b(S, C),
            "onUpdate:expend": (C) => i.value[S] = C,
            "onUpdate:subCompModel": (C) => h(C.index, C.accessor, C.data, C.child ? S : void 0)
          }, null, 8, ["index", "row", "columns", "selected", "expended", "actions", "data", "onUpdate:selectedRows", "onUpdate:expend", "onUpdate:subCompModel"]))), 128))
        ])
      ])
    ]));
  }
});
const CF = /* @__PURE__ */ J(DF, [["__scopeId", "data-v-56b7c1ad"]]), xF = /* @__PURE__ */ K({
  __name: "NavigationButton",
  props: {
    current: {},
    index: {}
  },
  setup(n) {
    const e = n, t = ue(() => e.index === "...");
    return (r, i) => r.current !== r.index ? (E(), ge(Zr, {
      key: 0,
      size: "sm",
      class: de(["navigation-button", { active: r.current === r.index }]),
      disabled: t.value
    }, {
      default: ee(() => [
        nn(re(r.index), 1)
      ]),
      _: 1
    }, 8, ["class", "disabled"])) : (E(), ge(Ca, {
      key: 1,
      size: "sm",
      class: de(["navigation-button", { active: r.current === r.index }]),
      disabled: t.value
    }, {
      default: ee(() => [
        nn(re(r.index), 1)
      ]),
      _: 1
    }, 8, ["class", "disabled"]));
  }
});
const kF = /* @__PURE__ */ J(xF, [["__scopeId", "data-v-75cd9d57"]]), SF = { class: "pagination-bar" }, AF = {
  key: 0,
  class: "text"
}, EF = { class: "navigation" }, TF = /* @__PURE__ */ K({
  __name: "PaginationBar",
  props: {
    count: {},
    total: {},
    current: {},
    size: {},
    hidePerPage: { type: Boolean, default: !1 },
    previousLabel: { default: "Previous" },
    nextLabel: { default: "Next" },
    perPageLabel: { default: "Showing :count of :total results" }
  },
  emits: ["update:current"],
  setup(n, { emit: e }) {
    Zn((d) => ({
      "2abcc242": X(u)
    }));
    const t = n, r = e, i = ["count", "total"], s = ue(() => {
      let d = t.perPageLabel;
      for (const f of i)
        d = d.replace(`:${f}`, `${t[f]}`);
      return d;
    }), o = ue(() => {
      const d = [];
      if (t.size <= 3)
        for (let f = 1; f <= t.size; f++)
          d.push(f);
      else
        t.current === 1 || t.current === 2 ? d.push(1, 2, 3, "...", t.size) : t.current === t.size || t.current === t.size - 1 ? d.push(1, "...", t.size - 2, t.size - 1, t.size) : d.push(1, "...", t.current - 1, t.current, t.current + 1, "...", t.size);
      return d;
    });
    function l(d) {
      d !== t.current && r("update:current", d);
    }
    const u = t.hidePerPage ? "center" : "space-between";
    return (d, f) => (E(), F("div", SF, [
      d.hidePerPage ? ne("", !0) : (E(), F("span", AF, re(s.value), 1)),
      O("div", EF, [
        ce(Zr, {
          size: "sm",
          disabled: d.current === 1,
          onClick: f[0] || (f[0] = (h) => l(d.current - 1))
        }, {
          default: ee(() => [
            nn(re(d.previousLabel), 1)
          ]),
          _: 1
        }, 8, ["disabled"]),
        (E(!0), F(ze, null, Je(o.value, (h) => (E(), ge(kF, {
          key: h,
          current: d.current,
          index: h,
          onClick: (m) => l(h)
        }, null, 8, ["current", "index", "onClick"]))), 128)),
        ce(Zr, {
          size: "sm",
          disabled: d.current === d.size,
          onClick: f[1] || (f[1] = (h) => l(d.current + 1))
        }, {
          default: ee(() => [
            nn(re(d.nextLabel), 1)
          ]),
          _: 1
        }, 8, ["disabled"])
      ])
    ]));
  }
});
const MF = /* @__PURE__ */ J(TF, [["__scopeId", "data-v-2c3af869"]]), OF = {
  class: "result",
  type: "button"
}, FF = { class: "label" }, IF = {
  key: 1,
  class: "description"
}, RF = {
  key: 2,
  class: "suffix"
}, NF = /* @__PURE__ */ K({
  __name: "SearchResult",
  props: {
    result: {},
    thumbnail: { type: Boolean }
  },
  setup(n) {
    return (e, t) => (E(), F("button", OF, [
      e.thumbnail ? (E(), ge(X(mo), {
        key: 0,
        src: e.result.thumbnail,
        alt: e.result.label
      }, null, 8, ["src", "alt"])) : ne("", !0),
      O("div", FF, re(e.result.label), 1),
      e.result.description ? (E(), F("div", IF, re(e.result.description), 1)) : ne("", !0),
      e.result.suffix ? (E(), F("div", RF, [
        e.result.suffix.type === "rating" ? (E(), ge(X(Af), {
          key: 0,
          ceil: e.result.suffix.ceil,
          score: e.result.suffix.score
        }, null, 8, ["ceil", "score"])) : ne("", !0)
      ])) : ne("", !0)
    ]));
  }
});
const BF = /* @__PURE__ */ J(NF, [["__scopeId", "data-v-df127ea2"]]);
const $F = {}, N0 = (n) => (Ye("data-v-d3acecf9"), n = n(), Xe(), n), LF = { class: "loader" }, PF = /* @__PURE__ */ N0(() => /* @__PURE__ */ O("div", { class: "icon" }, [
  /* @__PURE__ */ O("i", { class: "i-youcan-arrows-clockwise" })
], -1)), zF = /* @__PURE__ */ N0(() => /* @__PURE__ */ O("div", { class: "label" }, " Fetching resuts... ", -1)), VF = [
  PF,
  zF
];
function HF(n, e) {
  return E(), F("div", LF, VF);
}
const WF = /* @__PURE__ */ J($F, [["render", HF], ["__scopeId", "data-v-d3acecf9"]]);
const UF = {}, B0 = (n) => (Ye("data-v-7da7efd8"), n = n(), Xe(), n), jF = { class: "wrapper" }, qF = /* @__PURE__ */ B0(() => /* @__PURE__ */ O("div", { class: "icon" }, [
  /* @__PURE__ */ O("i", { "i-youcan-prohibit": "" })
], -1)), KF = /* @__PURE__ */ B0(() => /* @__PURE__ */ O("div", { class: "label" }, " No results were found ", -1)), GF = [
  qF,
  KF
];
function JF(n, e) {
  return E(), F("div", jF, GF);
}
const YF = /* @__PURE__ */ J(UF, [["render", JF], ["__scopeId", "data-v-7da7efd8"]]), XF = (n) => (Ye("data-v-989642a1"), n = n(), Xe(), n), ZF = { class: "search-input-wrapper" }, QF = /* @__PURE__ */ XF(() => /* @__PURE__ */ O("i", { "i-youcan-magnifying-glass": "" }, null, -1)), eI = { class: "result-list-wrapper" }, tI = { class: "result-list" }, nI = {
  key: 2,
  class: "results"
}, rI = /* @__PURE__ */ K({
  __name: "SearchInput",
  props: {
    queryHandler: { type: Function },
    thumbnails: { type: Boolean }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(""), s = G(!0), o = G([]), [l] = pr.debounce(async () => {
      s.value = !0, o.value = await t.queryHandler(i.value), s.value = !1;
    }, 600);
    return En(i, () => l()), bt(async () => l()), (u, d) => (E(), F("div", ZF, [
      ce(ss, Mn({
        ref: "input",
        modelValue: i.value,
        "onUpdate:modelValue": d[0] || (d[0] = (f) => i.value = f),
        class: "search-input"
      }, u.$attrs, { type: "text" }), {
        icon: ee(() => [
          QF
        ]),
        _: 1
      }, 16, ["modelValue"]),
      O("div", eI, [
        O("div", tI, [
          s.value ? (E(), ge(WF, { key: 0 })) : o.value.length ? (E(), F("div", nI, [
            (E(!0), F(ze, null, Je(o.value, (f) => (E(), ge(BF, {
              key: X(pr).uid(f.label),
              class: "search-result",
              thumbnail: u.thumbnails,
              result: f,
              onClick: (h) => r("select", f)
            }, null, 8, ["thumbnail", "result", "onClick"]))), 128))
          ])) : (E(), ge(YF, { key: 1 }))
        ])
      ])
    ]));
  }
});
const iI = /* @__PURE__ */ J(rI, [["__scopeId", "data-v-989642a1"]]), sI = (n) => (Ye("data-v-53d31a45"), n = n(), Xe(), n), oI = { class: "main" }, aI = { class: "content-container" }, lI = {
  key: 0,
  class: "btn"
}, uI = /* @__PURE__ */ sI(() => /* @__PURE__ */ O("i", { class: "i-tabler:x" }, null, -1)), cI = /* @__PURE__ */ K({
  __name: "Alert",
  props: {
    type: { default: "warning" },
    closeAfterDuration: {},
    canClose: { type: Boolean, default: !0 }
  },
  emits: ["close"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue(() => {
      let d = "i-youcan-";
      switch (t.type) {
        case "success":
          d += "check-circle";
          break;
        case "info":
          d += "info-1";
          break;
        case "error":
          d += "warning-circle";
          break;
        default:
          d += "warning-circle";
          break;
      }
      return `${d} ${t.type}`;
    }), { title: s, description: o } = Kt(), l = () => {
      r("close");
    };
    let u;
    return t.closeAfterDuration && typeof t.closeAfterDuration == "number" && (u = setTimeout(() => {
      l();
    }, t.closeAfterDuration)), po(() => {
      clearTimeout(u);
    }), (d, f) => (E(), F("div", {
      class: de(["alert-block", [d.type]])
    }, [
      O("div", oI, [
        O("div", {
          class: de(["icon-block", [d.type]])
        }, [
          O("i", {
            class: de(["icon", i.value])
          }, null, 2)
        ], 2),
        O("div", aI, [
          X(s) ? (E(), F("span", {
            key: 0,
            class: de(["title", [d.type]])
          }, [
            fe(d.$slots, "title", {}, void 0, !0)
          ], 2)) : ne("", !0),
          X(o) ? (E(), F("span", {
            key: 1,
            class: de(["description", [d.type]])
          }, [
            fe(d.$slots, "description", {}, void 0, !0)
          ], 2)) : ne("", !0)
        ]),
        d.canClose ? (E(), F("div", lI, [
          ce(rn, {
            class: "close-button",
            size: "xs",
            "icon-position": "only",
            onClick: l
          }, {
            icon: ee(() => [
              uI
            ]),
            _: 1
          })
        ])) : ne("", !0)
      ])
    ], 2));
  }
});
const $0 = /* @__PURE__ */ J(cI, [["__scopeId", "data-v-53d31a45"]]), dI = /* @__PURE__ */ K({
  __name: "Toast",
  props: {
    show: { type: Boolean },
    position: { default: "top-right" },
    type: {},
    closeAfterDuration: {},
    canClose: { type: Boolean, default: !0 }
  },
  emits: ["close"],
  setup(n, { emit: e }) {
    const t = e, { title: r, description: i } = Kt();
    return (s, o) => (E(), ge(eo, { name: s.position }, {
      default: ee(() => [
        s.show ? (E(), F("div", {
          key: 0,
          class: de(["toast-block", s.position])
        }, [
          ce(X($0), {
            type: s.type,
            "can-close": s.canClose,
            "close-after-duration": s.closeAfterDuration,
            onClose: o[0] || (o[0] = (l) => t("close"))
          }, Fr({ _: 2 }, [
            X(r) ? {
              name: "title",
              fn: ee(() => [
                fe(s.$slots, "title", {}, void 0, !0)
              ]),
              key: "0"
            } : void 0,
            X(i) ? {
              name: "description",
              fn: ee(() => [
                fe(s.$slots, "description", {}, void 0, !0)
              ]),
              key: "1"
            } : void 0
          ]), 1032, ["type", "can-close", "close-after-duration"])
        ], 2)) : ne("", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
const fI = /* @__PURE__ */ J(dI, [["__scopeId", "data-v-6db5a96d"]]), pI = K({
  inject: ["manager"],
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {};
  },
  watch: {
    index(n) {
      this.$el && this.$el.sortableInfo && (this.$el.sortableInfo.index = n);
    },
    disabled(n) {
      n ? this.removeDraggable() : this.setDraggable(this.index);
    }
  },
  mounted() {
    const { disabled: n, index: e } = this.$props;
    n || this.setDraggable(e);
  },
  beforeUnmount() {
    this.disabled || this.removeDraggable();
  },
  methods: {
    setDraggable(n) {
      const e = this.$el;
      e.sortableInfo = {
        index: n,
        manager: this.manager
      }, this.ref = { node: e }, this.manager.add(this.ref);
    },
    removeDraggable() {
      this.manager.remove(this.ref);
    }
  }
});
class hI {
  constructor() {
    this.refs = [], this.active = null;
  }
  add(e) {
    this.refs || (this.refs = []), this.refs.push(e);
  }
  remove(e) {
    const t = this.getIndex(e);
    t !== -1 && this.refs.splice(t, 1);
  }
  isActive() {
    return !!this.active;
  }
  getActive() {
    return this.refs.find(({ node: e }) => {
      var t, r;
      return ((t = e == null ? void 0 : e.sortableInfo) === null || t === void 0 ? void 0 : t.index) == ((r = this === null || this === void 0 ? void 0 : this.active) === null || r === void 0 ? void 0 : r.index);
    }) || null;
  }
  getIndex(e) {
    return this.refs.indexOf(e);
  }
  getRefs() {
    return this.refs;
  }
  getOrderedRefs() {
    return this.refs.sort((e, t) => e.node.sortableInfo.index - t.node.sortableInfo.index);
  }
}
const ea = (n) => n.touches != null;
function Ld(n, e) {
  return !!n && Object.prototype.hasOwnProperty.call(n, e);
}
function mI(n, e, t) {
  const r = n.slice(0);
  if (t >= r.length) {
    let i = t - r.length;
    for (; i-- + 1; )
      r.push(void 0);
  }
  return r.splice(t, 0, r.splice(e, 1)[0]), r;
}
function gI(n, e) {
  const t = n.slice(0);
  return e >= t.length || t.splice(e, 1), t;
}
function vI(n, e, t) {
  const r = n.slice(0);
  return e === r.length ? r.push(t) : r.splice(e, 0, t), r;
}
const ci = {
  start: ["touchstart", "mousedown"],
  move: ["touchmove", "mousemove"],
  end: ["touchend", "mouseup"],
  cancel: ["touchcancel", "keyup"]
};
function og(n, e) {
  for (; n; ) {
    if (e(n))
      return n;
    n = n.parentNode;
  }
}
function ag(n, e, t) {
  return t < n ? n : t > e ? e : t;
}
function bl(n) {
  return n.substr(-2) === "px" ? parseFloat(n) : 0;
}
function lg(n) {
  const e = window.getComputedStyle(n);
  return {
    top: bl(e.marginTop),
    right: bl(e.marginRight),
    bottom: bl(e.marginBottom),
    left: bl(e.marginLeft)
  };
}
function _l(n, e = "page") {
  const t = `${e}X`, r = `${e}Y`;
  return {
    x: ea(n) ? n.touches[0][t] : n[t],
    y: ea(n) ? n.touches[0][r] : n[r]
  };
}
function ug(n) {
  const e = [n];
  for (; n; n = n.offsetParent)
    e.unshift(n);
  return e;
}
function yI(n, e) {
  const t = ug(n), r = ug(e);
  if (t[0] != r[0])
    throw "No common ancestor!";
  for (let i = 0; i < t.length; i++)
    if (t[i] != r[i])
      return t[i - 1];
}
function Ki(n, e, t = { top: 0, left: 0 }) {
  if (n) {
    const r = {
      top: t.top + n.offsetTop,
      left: t.left + n.offsetLeft
    };
    return n.offsetParent !== e.offsetParent ? Ki(n.offsetParent, e, r) : r;
  }
  return { top: 0, left: 0 };
}
function cg(n) {
  const e = n.querySelectorAll("input, textarea, select"), t = n.cloneNode(!0);
  return [...t.querySelectorAll("input, textarea, select")].forEach((i, s) => {
    i.type !== "file" && e[s] && (i.value = e[s].value);
  }), t;
}
function bI(n, e, t) {
  if (typeof n == "string" && (n = +n), Array.isArray(n) || (n = [n, n]), n.length !== 2)
    throw new Error(`lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given ${n}`);
  const [r, i] = n;
  return [dg(r, e, t), dg(i, e, t)];
}
function dg(n, e, t) {
  let r = n, i = n, s = "px";
  if (typeof n == "string") {
    const o = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(n);
    if (o === null)
      throw new Error(`lockOffset value should be a number or a string of a number followed by "px" or "%". Given ${n}`);
    r = i = parseFloat(n), s = o[1];
  }
  if (!isFinite(r) || !isFinite(i))
    throw new Error(`lockOffset value should be a finite. Given ${n}`);
  return s === "%" && (r = r * e / 100, i = i * t / 100), {
    x: r,
    y: i
  };
}
function fg(n = []) {
  for (let e = 0, t = n.length; e < t; e++) {
    const r = n[e], i = r.node;
    if (!i)
      return;
    r.edgeOffset = null, Pd(i);
  }
}
function Pd(n, e = "", t = "") {
  n && (n.style.transform = e, n.style.transitionDuration = t);
}
const ed = setTimeout, _I = K({
  inject: {
    SlicksortHub: {
      from: "SlicksortHub",
      default: null
    }
  },
  provide() {
    return {
      manager: this.manager
    };
  },
  props: {
    list: { type: Array, required: !0 },
    axis: { type: String, default: "y" },
    distance: { type: Number, default: 0 },
    pressDelay: { type: Number, default: 0 },
    pressThreshold: { type: Number, default: 5 },
    useDragHandle: { type: Boolean, default: !1 },
    useWindowAsScrollContainer: { type: Boolean, default: !1 },
    hideSortableGhost: { type: Boolean, default: !0 },
    lockToContainerEdges: { type: Boolean, default: !1 },
    lockOffset: { type: [String, Number, Array], default: "50%" },
    transitionDuration: { type: Number, default: 300 },
    appendTo: { type: String, default: "body" },
    draggedSettlingDuration: { type: Number, default: null },
    group: { type: String, default: "" },
    accept: { type: [Boolean, Array, Function], default: null },
    cancelKey: { type: String, default: "Escape" },
    block: { type: Array, default: () => [] },
    lockAxis: { type: String, default: "" },
    helperClass: { type: String, default: "" },
    contentWindow: { type: Object, default: null },
    shouldCancelStart: {
      type: Function,
      default: (n) => ["input", "textarea", "select", "option", "button"].indexOf(n.target.tagName.toLowerCase()) !== -1
    },
    getHelperDimensions: {
      type: Function,
      default: ({ node: n }) => ({
        width: n.offsetWidth,
        height: n.offsetHeight
      })
    }
  },
  emits: ["sort-start", "sort-move", "sort-end", "sort-cancel", "sort-insert", "sort-remove", "update:list"],
  data() {
    let n = !1;
    if (this.group) {
      if (this.SlicksortHub)
        n = !0;
      else if (process.env.NODE_ENV !== "production")
        throw new Error('Slicksort plugin required to use "group" prop');
    }
    return {
      sorting: !1,
      hub: n ? this.SlicksortHub : null,
      manager: new hI()
    };
  },
  mounted() {
    this.hub && (this.id = this.hub.getId()), this.container = this.$el, this.document = this.container.ownerDocument || document, this._window = this.contentWindow || window, this.scrollContainer = this.useWindowAsScrollContainer ? { scrollLeft: 0, scrollTop: 0 } : this.container, this.events = {
      start: this.handleStart,
      move: this.handleMove,
      end: this.handleEnd
    };
    for (const n in this.events)
      Ld(this.events, n) && ci[n].forEach((e) => this.container.addEventListener(e, this.events[n]));
    this.hub && this.hub.addContainer(this);
  },
  beforeUnmount() {
    for (const n in this.events)
      Ld(this.events, n) && ci[n].forEach((e) => this.container.removeEventListener(e, this.events[n]));
    this.hub && this.hub.removeContainer(this), this.dragendTimer && clearTimeout(this.dragendTimer), this.cancelTimer && clearTimeout(this.cancelTimer), this.pressTimer && clearTimeout(this.pressTimer), this.autoscrollInterval && clearInterval(this.autoscrollInterval);
  },
  methods: {
    handleStart(n) {
      const { distance: e, shouldCancelStart: t } = this.$props;
      if (!ea(n) && n.button === 2 || t(n))
        return !1;
      this._touched = !0, this._pos = _l(n);
      const r = n.target, i = og(r, (s) => s.sortableInfo != null);
      if (i && i.sortableInfo && this.nodeIsChild(i) && !this.sorting) {
        const { useDragHandle: s } = this.$props, { index: o } = i.sortableInfo;
        if (s && !og(r, (l) => l.sortableHandle != null))
          return;
        this.manager.active = { index: o }, r.tagName.toLowerCase() === "a" && n.preventDefault(), e || (this.pressDelay === 0 ? this.handlePress(n) : this.pressTimer = ed(() => this.handlePress(n), this.pressDelay));
      }
    },
    nodeIsChild(n) {
      return n.sortableInfo.manager === this.manager;
    },
    handleMove(n) {
      const { distance: e, pressThreshold: t } = this.$props;
      if (!this.sorting && this._touched) {
        const r = _l(n);
        this._delta = {
          x: this._pos.x - r.x,
          y: this._pos.y - r.y
        };
        const i = Math.abs(this._delta.x) + Math.abs(this._delta.y);
        !e && (!t || t && i >= t) ? (this.cancelTimer && clearTimeout(this.cancelTimer), this.cancelTimer = ed(this.cancel, 0)) : e && i >= e && this.manager.isActive() && this.handlePress(n);
      }
    },
    handleEnd() {
      if (!this._touched)
        return;
      const { distance: n } = this.$props;
      this._touched = !1, n || this.cancel();
    },
    cancel() {
      this.sorting || (this.pressTimer && clearTimeout(this.pressTimer), this.manager.active = null, this.hub && this.hub.cancel());
    },
    handleSortCancel(n) {
      (ea(n) || n.key === this.cancelKey) && (this.newIndex = this.index, this.canceling = !0, this.translate = { x: 0, y: 0 }, this.animateNodes(), this.handleSortEnd(n));
    },
    handlePress(n) {
      n.stopPropagation();
      const e = this.manager.getActive();
      if (e) {
        const { getHelperDimensions: t, helperClass: r, hideSortableGhost: i, appendTo: s } = this.$props, { node: o } = e, { index: l } = o.sortableInfo, u = lg(o), d = this.container.getBoundingClientRect(), f = t({ index: l, node: o });
        this.node = o, this.margin = u, this.width = f.width, this.height = f.height, this.marginOffset = {
          x: this.margin.left + this.margin.right,
          y: Math.max(this.margin.top, this.margin.bottom)
        }, this.boundingClientRect = o.getBoundingClientRect(), this.containerBoundingRect = d, this.index = l, this.newIndex = l;
        const h = cg(o);
        this.helper = this.document.querySelector(s).appendChild(h), this.helper.style.position = "fixed", this.helper.style.top = `${this.boundingClientRect.top - u.top}px`, this.helper.style.left = `${this.boundingClientRect.left - u.left}px`, this.helper.style.width = `${this.width}px`, this.helper.style.height = `${this.height}px`, this.helper.style.boxSizing = "border-box", this.helper.style.pointerEvents = "none", i && (this.sortableGhost = o, o.style.visibility = "hidden", o.style.opacity = "0"), this.hub && (this.hub.sortStart(this), this.hub.helper = this.helper, this.hub.ghost = this.sortableGhost), this.intializeOffsets(n, this.boundingClientRect), this.offsetEdge = Ki(o, this.container), r && this.helper.classList.add(...r.split(" ")), this.listenerNode = ea(n) ? o : this._window, ci.move.forEach((m) => this.listenerNode.addEventListener(m, this.handleSortMove)), ci.end.forEach((m) => this.listenerNode.addEventListener(m, this.handleSortEnd)), ci.cancel.forEach((m) => this.listenerNode.addEventListener(m, this.handleSortCancel)), this.sorting = !0, this.$emit("sort-start", { event: n, node: o, index: l });
      }
    },
    handleSortMove(n) {
      if (n.preventDefault(), this.updatePosition(n), this.hub) {
        const e = this.list[this.index];
        this.hub.handleSortMove(n, e);
      }
      (!this.hub || this.hub.isDest(this)) && (this.animateNodes(), this.autoscroll()), this.$emit("sort-move", { event: n });
    },
    handleDropOut() {
      const n = this.list[this.index], e = gI(this.list, this.index);
      return this.$emit("sort-remove", {
        oldIndex: this.index
      }), this.$emit("update:list", e), n;
    },
    handleDropIn(n) {
      const e = vI(this.list, this.newIndex, n);
      this.$emit("sort-insert", {
        newIndex: this.newIndex,
        value: n
      }), this.$emit("update:list", e), this.handleDragEnd();
    },
    handleDragOut() {
      this.autoscrollInterval && (clearInterval(this.autoscrollInterval), this.autoscrollInterval = null), this.hub.isSource(this) ? (this.translate = {
        x: 1e4,
        y: 1e4
      }, this.animateNodes()) : (this.manager.getRefs().forEach((n) => {
        n.node.style.transform = "";
      }), this.dragendTimer = ed(this.handleDragEnd, this.transitionDuration || 0));
    },
    handleDragEnd() {
      this.autoscrollInterval && (clearInterval(this.autoscrollInterval), this.autoscrollInterval = null), fg(this.manager.getRefs()), this.sortableGhost && (this.sortableGhost.remove(), this.sortableGhost = null), this.dragendTimer && (clearTimeout(this.dragendTimer), this.dragendTimer = null), this.manager.active = null, this._touched = !1, this.sorting = !1;
    },
    intializeOffsets(n, e) {
      const { useWindowAsScrollContainer: t, containerBoundingRect: r, _window: i } = this;
      this.marginOffset = {
        x: this.margin.left + this.margin.right,
        y: Math.max(this.margin.top, this.margin.bottom)
      }, this._axis = {
        x: this.axis.indexOf("x") >= 0,
        y: this.axis.indexOf("y") >= 0
      }, this.initialOffset = _l(n), this.initialScroll = {
        top: this.scrollContainer.scrollTop,
        left: this.scrollContainer.scrollLeft
      }, this.initialWindowScroll = {
        top: window.pageYOffset,
        left: window.pageXOffset
      }, this.translate = { x: 0, y: 0 }, this.minTranslate = {}, this.maxTranslate = {}, this._axis.x && (this.minTranslate.x = (t ? 0 : r.left) - e.left - this.width / 2, this.maxTranslate.x = (t ? i.innerWidth : r.left + r.width) - e.left - this.width / 2), this._axis.y && (this.minTranslate.y = (t ? 0 : r.top) - e.top - this.height / 2, this.maxTranslate.y = (t ? i.innerHeight : r.top + r.height) - e.top - this.height / 2);
    },
    handleDragIn(n, e, t) {
      if (this.hub.isSource(this))
        return;
      this.dragendTimer && (this.handleDragEnd(), clearTimeout(this.dragendTimer), this.dragendTimer = null);
      const r = this.manager.getRefs();
      this.index = r.length, this.manager.active = { index: this.index };
      const i = this.container.getBoundingClientRect(), s = t.getBoundingClientRect();
      this.containerBoundingRect = i, this.sortableGhost = cg(e), this.container.appendChild(this.sortableGhost);
      const o = this.sortableGhost.getBoundingClientRect();
      this.boundingClientRect = o, this.margin = lg(this.sortableGhost), this.width = o.width, this.height = o.height, this.offsetEdge = Ki(this.sortableGhost, this.container), this.intializeOffsets(n, o), this.initialOffset.x += o.x - s.x, this.initialOffset.y += o.y - s.y, this.sorting = !0;
    },
    handleSortEnd(n) {
      this.listenerNode && (ci.move.forEach((r) => this.listenerNode.removeEventListener(r, this.handleSortMove)), ci.end.forEach((r) => this.listenerNode.removeEventListener(r, this.handleSortEnd)), ci.cancel.forEach((r) => this.listenerNode.removeEventListener(r, this.handleSortCancel)));
      const e = this.manager.getRefs();
      this.helper && this.helperClass && this.helper.classList.remove(...this.helperClass.split(" ")), this.autoscrollInterval && clearInterval(this.autoscrollInterval), this.autoscrollInterval = null;
      const t = () => {
        this.helper && (this.helper.remove(), this.helper = null), this.hideSortableGhost && this.sortableGhost && (this.sortableGhost.style.visibility = "", this.sortableGhost.style.opacity = ""), fg(e), this.hub && !this.hub.isDest(this) ? this.canceling ? this.hub.cancel() : this.hub.handleSortEnd() : this.canceling ? this.$emit("sort-cancel", { event: n }) : (this.$emit("sort-end", {
          event: n,
          oldIndex: this.index,
          newIndex: this.newIndex
        }), this.$emit("update:list", mI(this.list, this.index, this.newIndex))), this.manager.active = null, this._touched = !1, this.canceling = !1, this.sorting = !1;
      };
      this.transitionDuration || this.draggedSettlingDuration ? this.transitionHelperIntoPlace(e, t) : t();
    },
    transitionHelperIntoPlace(n, e) {
      if (this.draggedSettlingDuration === 0 || n.length === 0 || !this.helper)
        return Promise.resolve();
      const t = n[this.index].node;
      let r = 0, i = 0;
      const s = {
        top: window.pageYOffset - this.initialWindowScroll.top,
        left: window.pageXOffset - this.initialWindowScroll.left
      };
      if (this.hub && !this.hub.isDest(this) && !this.canceling) {
        const d = this.hub.getDest();
        if (!d)
          return;
        const f = d.newIndex, h = d.manager.getOrderedRefs(), m = f < h.length ? h[f].node : d.sortableGhost, g = yI(t, m), y = Ki(t, g), b = Ki(m, g);
        r = b.left - y.left - s.left, i = b.top - y.top - s.top;
      } else {
        const d = n[this.newIndex].node, f = {
          left: this.scrollContainer.scrollLeft - this.initialScroll.left + s.left,
          top: this.scrollContainer.scrollTop - this.initialScroll.top + s.top
        };
        r = -f.left, this.translate && this.translate.x > 0 ? r += d.offsetLeft + d.offsetWidth - (t.offsetLeft + t.offsetWidth) : r += d.offsetLeft - t.offsetLeft, i = -f.top, this.translate && this.translate.y > 0 ? i += d.offsetTop + d.offsetHeight - (t.offsetTop + t.offsetHeight) : i += d.offsetTop - t.offsetTop;
      }
      const o = this.draggedSettlingDuration !== null ? this.draggedSettlingDuration : this.transitionDuration;
      Pd(this.helper, `translate3d(${r}px,${i}px, 0)`, `${o}ms`);
      const l = (d) => {
        (!d || d.propertyName === "transform") && (clearTimeout(u), Pd(this.helper), e());
      }, u = setTimeout(l, o + 10);
      this.helper.addEventListener("transitionend", l);
    },
    updatePosition(n) {
      const { lockAxis: e, lockToContainerEdges: t } = this.$props, r = _l(n), i = {
        x: r.x - this.initialOffset.x,
        y: r.y - this.initialOffset.y
      };
      if (i.y -= window.pageYOffset - this.initialWindowScroll.top, i.x -= window.pageXOffset - this.initialWindowScroll.left, this.translate = i, t) {
        const [s, o] = bI(this.lockOffset, this.height, this.width), l = {
          x: this.width / 2 - s.x,
          y: this.height / 2 - s.y
        }, u = {
          x: this.width / 2 - o.x,
          y: this.height / 2 - o.y
        };
        this.minTranslate.x && this.maxTranslate.x && (i.x = ag(this.minTranslate.x + l.x, this.maxTranslate.x - u.x, i.x)), this.minTranslate.y && this.maxTranslate.y && (i.y = ag(this.minTranslate.y + l.y, this.maxTranslate.y - u.y, i.y));
      }
      e === "x" ? i.y = 0 : e === "y" && (i.x = 0), this.helper && (this.helper.style.transform = `translate3d(${i.x}px,${i.y}px, 0)`);
    },
    animateNodes() {
      const { transitionDuration: n, hideSortableGhost: e } = this.$props, t = this.manager.getOrderedRefs(), r = {
        left: this.scrollContainer.scrollLeft - this.initialScroll.left,
        top: this.scrollContainer.scrollTop - this.initialScroll.top
      }, i = {
        left: this.offsetEdge.left + this.translate.x + r.left,
        top: this.offsetEdge.top + this.translate.y + r.top
      }, s = {
        top: window.pageYOffset - this.initialWindowScroll.top,
        left: window.pageXOffset - this.initialWindowScroll.left
      };
      this.newIndex = null;
      for (let o = 0, l = t.length; o < l; o++) {
        const { node: u } = t[o], d = u.sortableInfo.index, f = u.offsetWidth, h = u.offsetHeight, m = {
          width: this.width > f ? f / 2 : this.width / 2,
          height: this.height > h ? h / 2 : this.height / 2
        }, g = {
          x: 0,
          y: 0
        };
        let { edgeOffset: y } = t[o];
        y || (t[o].edgeOffset = y = Ki(u, this.container));
        const b = o < t.length - 1 && t[o + 1], w = o > 0 && t[o - 1];
        if (b && !b.edgeOffset && (b.edgeOffset = Ki(b.node, this.container)), d === this.index) {
          e && (this.sortableGhost = u, u.style.visibility = "hidden", u.style.opacity = "0");
          continue;
        }
        n && (u.style.transitionDuration = `${n}ms`), this._axis.x ? this._axis.y ? d < this.index && (i.left + s.left - m.width <= y.left && i.top + s.top <= y.top + m.height || i.top + s.top + m.height <= y.top) ? (g.x = this.width + this.marginOffset.x, y.left + g.x > this.containerBoundingRect.width - m.width && b && (g.x = b.edgeOffset.left - y.left, g.y = b.edgeOffset.top - y.top), this.newIndex === null && (this.newIndex = d)) : d > this.index && (i.left + s.left + m.width >= y.left && i.top + s.top + m.height >= y.top || i.top + s.top + m.height >= y.top + h) && (g.x = -(this.width + this.marginOffset.x), y.left + g.x < this.containerBoundingRect.left + m.width && w && (g.x = w.edgeOffset.left - y.left, g.y = w.edgeOffset.top - y.top), this.newIndex = d) : d > this.index && i.left + s.left + m.width >= y.left ? (g.x = -(this.width + this.marginOffset.x), this.newIndex = d) : d < this.index && i.left + s.left <= y.left + m.width && (g.x = this.width + this.marginOffset.x, this.newIndex == null && (this.newIndex = d)) : this._axis.y && (d > this.index && i.top + s.top + m.height >= y.top ? (g.y = -(this.height + this.marginOffset.y), this.newIndex = d) : d < this.index && i.top + s.top <= y.top + m.height && (g.y = this.height + this.marginOffset.y, this.newIndex == null && (this.newIndex = d))), u.style.transform = `translate3d(${g.x}px,${g.y}px,0)`;
      }
      this.newIndex == null && (this.newIndex = this.index);
    },
    autoscroll() {
      const n = this.translate, e = {
        x: 0,
        y: 0
      }, t = {
        x: 1,
        y: 1
      }, r = {
        x: 10,
        y: 10
      };
      n.y >= this.maxTranslate.y - this.height / 2 ? (e.y = 1, t.y = r.y * Math.abs((this.maxTranslate.y - this.height / 2 - n.y) / this.height)) : n.x >= this.maxTranslate.x - this.width / 2 ? (e.x = 1, t.x = r.x * Math.abs((this.maxTranslate.x - this.width / 2 - n.x) / this.width)) : n.y <= this.minTranslate.y + this.height / 2 ? (e.y = -1, t.y = r.y * Math.abs((n.y - this.height / 2 - this.minTranslate.y) / this.height)) : n.x <= this.minTranslate.x + this.width / 2 && (e.x = -1, t.x = r.x * Math.abs((n.x - this.width / 2 - this.minTranslate.x) / this.width)), this.autoscrollInterval && (clearInterval(this.autoscrollInterval), this.autoscrollInterval = null), (e.x !== 0 || e.y !== 0) && (this.autoscrollInterval = window.setInterval(() => {
        const i = {
          left: 1 * t.x * e.x,
          top: 1 * t.y * e.y
        };
        this.useWindowAsScrollContainer ? this._window.scrollBy(i.left, i.top) : (this.scrollContainer.scrollTop += i.top, this.scrollContainer.scrollLeft += i.left), this.translate.x += i.left, this.translate.y += i.top, this.animateNodes();
      }, 5));
    }
  }
}), L0 = K({
  name: "SlickItem",
  mixins: [pI],
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  render() {
    var n, e;
    return Gn(this.tag, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n));
  }
}), wI = K({
  name: "SlickList",
  mixins: [_I],
  props: {
    tag: {
      type: String,
      default: "div"
    },
    itemKey: {
      type: [String, Function],
      default: "id"
    }
  },
  render() {
    var n, e;
    return this.$slots.item ? Gn(this.tag, this.list.map((t, r) => {
      let i;
      if (t != null) {
        if (typeof this.itemKey == "function")
          i = this.itemKey(t);
        else if (typeof t == "object" && Ld(t, this.itemKey) && typeof t[this.itemKey] == "string")
          i = t[this.itemKey];
        else if (typeof t == "string")
          i = t;
        else
          throw new Error("Cannot find key for item, use the item-key prop and pass a function or string");
        return Gn(L0, {
          key: i,
          index: r
        }, {
          default: () => {
            var s, o;
            return (o = (s = this.$slots).item) === null || o === void 0 ? void 0 : o.call(s, { item: t, index: r });
          }
        });
      }
    })) : Gn(this.tag, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n));
  }
}), DI = K({
  props: {
    tag: {
      type: String,
      default: "span"
    }
  },
  mounted() {
    this.$el.sortableHandle = !0;
  },
  render() {
    var n, e;
    return Gn(this.tag, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n));
  }
}), CI = (n) => (Ye("data-v-bcc72c7a"), n = n(), Xe(), n), xI = { class: "draggable-item" }, kI = /* @__PURE__ */ CI(() => /* @__PURE__ */ O("i", { class: "handle i-youcan-dots-six-vertical" }, null, -1)), SI = { class: "label" }, AI = /* @__PURE__ */ K({
  __name: "DraggableItem",
  props: {
    modelValue: {},
    canCheck: { type: Boolean }
  },
  emits: ["update:model-value", "check"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => ({ ...t.modelValue, checked: t.modelValue.checked || !1 }),
      set: (o) => r("update:model-value", o)
    });
    function s(o) {
      r("check", i.value, o), i.value = { ...i.value, checked: o };
    }
    return (o, l) => (E(), F("li", xI, [
      ce(X(DI), null, {
        default: ee(() => [
          kI
        ]),
        _: 1
      }),
      O("span", SI, re(i.value.label), 1),
      o.canCheck ? (E(), ge(ho, {
        key: 0,
        modelValue: i.value.checked,
        "onUpdate:modelValue": [
          l[0] || (l[0] = (u) => i.value.checked = u),
          s
        ]
      }, null, 8, ["modelValue"])) : ne("", !0)
    ]));
  }
});
const P0 = /* @__PURE__ */ J(AI, [["__scopeId", "data-v-bcc72c7a"]]), EI = /* @__PURE__ */ K({
  __name: "Draggable",
  props: {
    modelValue: {},
    canCheck: { type: Boolean }
  },
  emits: ["update:model-value", "check"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (l) => r("update:model-value", l)
    }), s = (l, u) => {
      r("check", l, u);
    };
    function o(l) {
      return i.value.findIndex((u) => u.value === l);
    }
    return (l, u) => (E(), ge(X(wI), {
      list: i.value,
      "onUpdate:list": u[0] || (u[0] = (d) => i.value = d),
      axis: "y",
      class: "draggable",
      "use-drag-handle": !0
    }, {
      default: ee(() => [
        (E(!0), F(ze, null, Je(i.value, (d, f) => (E(), ge(X(L0), {
          key: d.value,
          index: f
        }, {
          default: ee(() => [
            ce(P0, {
              modelValue: i.value[o(d.value)],
              "onUpdate:modelValue": (h) => i.value[o(d.value)] = h,
              class: "draggable-item",
              "can-check": l.canCheck,
              onCheck: s
            }, null, 8, ["modelValue", "onUpdate:modelValue", "can-check"])
          ]),
          _: 2
        }, 1032, ["index"]))), 128))
      ]),
      _: 1
    }, 8, ["list"]));
  }
});
const TI = /* @__PURE__ */ J(EI, [["__scopeId", "data-v-5aadcc94"]]), MI = { class: "radio" }, OI = ["id", "name", "checked"], FI = ["for"], II = /* @__PURE__ */ K({
  __name: "Radio",
  props: {
    modelValue: { type: Boolean },
    name: {}
  },
  emits: ["update:model-value"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Kt(), s = ue({
      get: () => t.modelValue || !1,
      set: (l) => r("update:model-value", l)
    }), o = pr.uid("radio_");
    return (l, u) => (E(), F("div", MI, [
      yt(O("input", {
        id: X(o),
        "onUpdate:modelValue": u[0] || (u[0] = (d) => s.value = d),
        type: "radio",
        name: l.name,
        class: "trigger",
        checked: s.value
      }, null, 8, OI), [
        [Qv, s.value]
      ]),
      X(i).default ? (E(), F("label", {
        key: 0,
        class: "label",
        for: X(o)
      }, [
        fe(l.$slots, "default", {}, void 0, !0)
      ], 8, FI)) : ne("", !0)
    ]));
  }
});
const z0 = /* @__PURE__ */ J(II, [["__scopeId", "data-v-226f35d2"]]), RI = {
  role: "radiogroup",
  class: "radio-group"
}, NI = /* @__PURE__ */ K({
  __name: "RadioGroup",
  props: {
    items: {},
    name: {},
    modelValue: {}
  },
  emits: ["update:model-value"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (o) => {
        typeof o < "u" && r("update:model-value", o);
      }
    }), s = (o) => i.value = o.value;
    return (o, l) => (E(), F("fieldset", RI, [
      (E(!0), F(ze, null, Je(o.items, (u, d) => (E(), ge(z0, {
        key: d,
        "model-value": u.value === i.value,
        name: o.name,
        "onUpdate:modelValue": () => s(u)
      }, {
        default: ee(() => [
          nn(re(u.label), 1)
        ]),
        _: 2
      }, 1032, ["model-value", "name", "onUpdate:modelValue"]))), 128))
    ]));
  }
});
const BI = /* @__PURE__ */ J(NI, [["__scopeId", "data-v-0cc55f95"]]), $I = { class: "radio-list" }, LI = ["for"], PI = ["id", "name", "value"], zI = { class: "name" }, VI = { class: "suffix" }, HI = /* @__PURE__ */ K({
  __name: "RadioList",
  props: {
    modelValue: {},
    options: {}
  },
  emits: ["update:model-value"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (s) => r("update:model-value", s)
    });
    return (s, o) => (E(), F("div", $I, [
      (E(!0), F(ze, null, Je(s.options, (l) => (E(), F("label", {
        key: l.label,
        class: "radio-item",
        for: l.label
      }, [
        yt(O("input", {
          id: l.label,
          "onUpdate:modelValue": o[0] || (o[0] = (u) => i.value = u),
          name: l.label,
          value: l.label,
          type: "radio",
          class: "trigger"
        }, null, 8, PI), [
          [Qv, i.value]
        ]),
        O("span", zI, re(l.label), 1),
        O("span", VI, re(l.suffix), 1)
      ], 8, LI))), 128))
    ]));
  }
});
const WI = /* @__PURE__ */ J(HI, [["__scopeId", "data-v-c0bb160e"]]);
function Rt(n) {
  this.content = n;
}
Rt.prototype = {
  constructor: Rt,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n)
        return e;
    return -1;
  },
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new Rt(s);
  },
  remove: function(n) {
    var e = this.find(n);
    if (e == -1)
      return this;
    var t = this.content.slice();
    return t.splice(e, 2), new Rt(t);
  },
  addToStart: function(n, e) {
    return new Rt([n, e].concat(this.remove(n).content));
  },
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new Rt(t);
  },
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new Rt(i);
  },
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  prepend: function(n) {
    return n = Rt.from(n), n.size ? new Rt(n.content.concat(this.subtract(n).content)) : this;
  },
  append: function(n) {
    return n = Rt.from(n), n.size ? new Rt(this.subtract(n).content.concat(n.content)) : this;
  },
  subtract: function(n) {
    var e = this;
    n = Rt.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  get size() {
    return this.content.length >> 1;
  }
};
Rt.from = function(n) {
  if (n instanceof Rt)
    return n;
  var e = [];
  if (n)
    for (var t in n)
      e.push(t, n[t]);
  return new Rt(e);
};
function V0(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = V0(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function H0(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), l = e.child(--s), u = o.nodeSize;
    if (o == l) {
      t -= u, r -= u;
      continue;
    }
    if (!o.sameMarkup(l))
      return { a: t, b: r };
    if (o.isText && o.text != l.text) {
      let d = 0, f = Math.min(o.text.length, l.text.length);
      for (; d < f && o.text[o.text.length - d - 1] == l.text[l.text.length - d - 1]; )
        d++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || l.content.size) {
      let d = H0(o.content, l.content, t - 1, r - 1);
      if (d)
        return d;
    }
    t -= u, r -= u;
  }
}
class U {
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, l = 0; l < t; o++) {
      let u = this.content[o], d = l + u.nodeSize;
      if (d > e && r(u, i + l, s || null, o) !== !1 && u.content.size) {
        let f = l + 1;
        u.nodesBetween(Math.max(0, e - f), Math.min(u.content.size, t - f), r, i + f);
      }
      l = d;
    }
  }
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (l, u) => {
      l.isText ? (s += l.text.slice(Math.max(e, u) - u, t - u), o = !r) : l.isLeaf ? (i ? s += typeof i == "function" ? i(l) : i : l.type.spec.leafText && (s += l.type.spec.leafText(l)), o = !r) : !o && l.isBlock && (s += r, o = !0);
    }, 0), s;
  }
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new U(i, this.size + e.size);
  }
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let l = this.content[s], u = o + l.nodeSize;
        u > e && ((o < e || u > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = u;
      }
    return new U(r, i);
  }
  cutByIndex(e, t) {
    return e == t ? U.empty : e == 0 && t == this.content.length ? this : new U(this.content.slice(e, t));
  }
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new U(i, s);
  }
  addToStart(e) {
    return new U([e].concat(this.content), this.size + e.nodeSize);
  }
  addToEnd(e) {
    return new U(this.content.concat(e), this.size + e.nodeSize);
  }
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  maybeChild(e) {
    return this.content[e] || null;
  }
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  findDiffStart(e, t = 0) {
    return V0(this, e, t);
  }
  findDiffEnd(e, t = this.size, r = e.size) {
    return H0(this, e, t, r);
  }
  findIndex(e, t = -1) {
    if (e == 0)
      return wl(0, e);
    if (e == this.size)
      return wl(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || t > 0 ? wl(r + 1, o) : wl(r, i);
      i = o;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  static fromJSON(e, t) {
    if (!t)
      return U.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new U(t.map(e.nodeFromJSON));
  }
  static fromArray(e) {
    if (!e.length)
      return U.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new U(t || e, r);
  }
  static from(e) {
    if (!e)
      return U.empty;
    if (e instanceof U)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new U([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
U.empty = new U([], 0);
const td = { index: 0, offset: 0 };
function wl(n, e) {
  return td.index = n, td.offset = e, td;
}
function zl(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!zl(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !zl(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
let Ue = class {
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  eq(e) {
    return this == e || this.type == e.type && zl(this.attrs, e.attrs);
  }
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    return r.create(t.attrs);
  }
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Ue.none;
    if (e instanceof Ue)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
};
Ue.none = [];
class Vl extends Error {
}
class Z {
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(e, t) {
    let r = U0(this.content, e + this.openStart, t);
    return r && new Z(r, this.openStart, this.openEnd);
  }
  removeBetween(e, t) {
    return new Z(W0(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  static fromJSON(e, t) {
    if (!t)
      return Z.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Z(U.fromJSON(e, t.content), r, i);
  }
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new Z(e, r, i);
  }
}
Z.empty = new Z(U.empty, 0, 0);
function W0(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t);
  if (i == e || s.isText) {
    if (l != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(W0(s.content, e - i - 1, t - i - 1)));
}
function U0(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = U0(o.content, e - s - 1, t);
  return l && n.replaceChild(i, o.copy(l));
}
function UI(n, e, t) {
  if (t.openStart > n.depth)
    throw new Vl("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new Vl("Inconsistent open depths");
  return j0(n, e, t, 0);
}
function j0(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = j0(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, l = o.content;
      return ns(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: o, end: l } = jI(t, n);
      return ns(s, K0(n, o, l, e, r));
    }
  else
    return ns(s, Hl(n, e, r));
}
function q0(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new Vl("Cannot join " + e.type.name + " onto " + n.type.name);
}
function zd(n, e, t) {
  let r = n.node(t);
  return q0(r, e.node(t)), r;
}
function ts(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function ta(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (ts(n.nodeAfter, r), s++));
  for (let l = s; l < o; l++)
    ts(i.child(l), r);
  e && e.depth == t && e.textOffset && ts(e.nodeBefore, r);
}
function ns(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function K0(n, e, t, r, i) {
  let s = n.depth > i && zd(n, e, i + 1), o = r.depth > i && zd(t, r, i + 1), l = [];
  return ta(null, n, i, l), s && o && e.index(i) == t.index(i) ? (q0(s, o), ts(ns(s, K0(n, e, t, r, i + 1)), l)) : (s && ts(ns(s, Hl(n, e, i + 1)), l), ta(e, t, i, l), o && ts(ns(o, Hl(t, r, i + 1)), l)), ta(r, null, i, l), new U(l);
}
function Hl(n, e, t) {
  let r = [];
  if (ta(null, n, t, r), n.depth > t) {
    let i = zd(n, e, t + 1);
    ts(ns(i, Hl(n, e, t + 1)), r);
  }
  return ta(e, null, t, r), new U(r);
}
function jI(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(U.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class fa {
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return Ue.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new Wl(this, e, r);
    return null;
  }
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: l, offset: u } = o.content.findIndex(s), d = s - u;
      if (r.push(o, l, i + u), !d || (o = o.child(l), o.isText))
        break;
      s = d - 1, i += u + 1;
    }
    return new fa(t, r, s);
  }
  static resolveCached(e, t) {
    for (let i = 0; i < nd.length; i++) {
      let s = nd[i];
      if (s.pos == t && s.doc == e)
        return s;
    }
    let r = nd[rd] = fa.resolve(e, t);
    return rd = (rd + 1) % qI, r;
  }
}
let nd = [], rd = 0, qI = 12;
class Wl {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const KI = /* @__PURE__ */ Object.create(null);
let Yr = class {
  constructor(e, t, r, i = Ue.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || U.empty;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(e) {
    return this.content.child(e);
  }
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  forEach(e) {
    this.content.forEach(e);
  }
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  hasMarkup(e, t, r) {
    return this.type == e && zl(this.attrs, t || e.defaultAttrs || KI) && Ue.sameSet(this.marks, r || Ue.none);
  }
  copy(e = null) {
    return e == this.content ? this : new Yr(this.type, this.attrs, e, this.marks);
  }
  mark(e) {
    return e == this.marks ? this : new Yr(this.type, this.attrs, this.content, e);
  }
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return Z.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), d = i.node(o).content.cut(i.pos - l, s.pos - l);
    return new Z(d, i.depth - o, s.depth - o);
  }
  replace(e, t, r) {
    return UI(this.resolve(e), this.resolve(t), r);
  }
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  resolve(e) {
    return fa.resolveCached(this, e);
  }
  resolveNoCache(e) {
    return fa.resolve(this, e);
  }
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), G0(this.marks, e);
  }
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  canReplace(e, t, r = U.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let u = i; u < s; u++)
      if (!this.type.allowsMarks(r.child(u).marks))
        return !1;
    return !0;
  }
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  check() {
    this.type.checkContent(this.content);
    let e = Ue.none;
    for (let t = 0; t < this.marks.length; t++)
      e = this.marks[t].addToSet(e);
    if (!Ue.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r = null;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = U.fromJSON(e, t.content);
    return e.nodeType(t.type).create(t.attrs, i, r);
  }
};
Yr.prototype.text = void 0;
class Ul extends Yr {
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : G0(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Ul(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Ul(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function G0(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class ls {
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  static parse(e, t) {
    let r = new GI(e, t);
    if (r.next == null)
      return ls.empty;
    let i = J0(r);
    r.next && r.err("Unexpected trailing text");
    let s = tR(eR(i));
    return nR(s, r), s;
  }
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, l) {
      let u = o.matchFragment(e, r);
      if (u && (!t || u.validEnd))
        return U.from(l.map((d) => d.createAndFill()));
      for (let d = 0; d < o.next.length; d++) {
        let { type: f, next: h } = o.next[d];
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let m = s(h, l.concat(f));
          if (m)
            return m;
        }
      }
      return null;
    }
    return s(this, []);
  }
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let l = i; l.type; l = l.via)
          o.push(l.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: l, next: u } = s.next[o];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || u.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
ls.empty = new ls(!0);
class GI {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function J0(n) {
  let e = [];
  do
    e.push(JI(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function JI(n) {
  let e = [];
  do
    e.push(YI(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function YI(n) {
  let e = QI(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = XI(n, e);
    else
      break;
  return e;
}
function pg(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function XI(n, e) {
  let t = pg(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = pg(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function ZI(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.groups.indexOf(e) > -1 && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function QI(n) {
  if (n.eat("(")) {
    let e = J0(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = ZI(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function eR(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, l, u) {
    let d = { term: u, to: l };
    return e[o].push(d), d;
  }
  function i(o, l) {
    o.forEach((u) => u.to = l);
  }
  function s(o, l) {
    if (o.type == "choice")
      return o.exprs.reduce((u, d) => u.concat(s(d, l)), []);
    if (o.type == "seq")
      for (let u = 0; ; u++) {
        let d = s(o.exprs[u], l);
        if (u == o.exprs.length - 1)
          return d;
        i(d, l = t());
      }
    else if (o.type == "star") {
      let u = t();
      return r(l, u), i(s(o.expr, u), u), [r(u)];
    } else if (o.type == "plus") {
      let u = t();
      return i(s(o.expr, l), u), i(s(o.expr, u), u), [r(u)];
    } else {
      if (o.type == "opt")
        return [r(l)].concat(s(o.expr, l));
      if (o.type == "range") {
        let u = l;
        for (let d = 0; d < o.min; d++) {
          let f = t();
          i(s(o.expr, u), f), u = f;
        }
        if (o.max == -1)
          i(s(o.expr, u), u);
        else
          for (let d = o.min; d < o.max; d++) {
            let f = t();
            r(u, f), i(s(o.expr, u), f), u = f;
          }
        return [r(u)];
      } else {
        if (o.type == "name")
          return [r(l, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function Y0(n, e) {
  return e - n;
}
function hg(n, e) {
  let t = [];
  return r(e), t.sort(Y0);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: l, to: u } = s[o];
      !l && t.indexOf(u) == -1 && r(u);
    }
  }
}
function tR(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(hg(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: l, to: u }) => {
        if (!l)
          return;
        let d;
        for (let f = 0; f < i.length; f++)
          i[f][0] == l && (d = i[f][1]);
        hg(n, u).forEach((f) => {
          d || i.push([l, d = []]), d.indexOf(f) == -1 && d.push(f);
        });
      });
    });
    let s = e[r.join(",")] = new ls(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let l = i[o][1].sort(Y0);
      s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) });
    }
    return s;
  }
}
function nR(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: u, next: d } = i.next[l];
      o.push(u.name), s && !(u.isText || u.hasRequiredAttrs()) && (s = !1), r.indexOf(d) == -1 && r.push(d);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function X0(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function Z0(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function Q0(n) {
  let e = /* @__PURE__ */ Object.create(null);
  if (n)
    for (let t in n)
      e[t] = new rR(n[t]);
  return e;
}
let Vd = class {
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = Q0(r.attrs), this.defaultAttrs = X0(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == ls.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : Z0(this.attrs, e);
  }
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Yr(this, this.computeAttrs(e), U.from(t), Ue.setFrom(r));
  }
  createChecked(e = null, t, r) {
    return t = U.from(t), this.checkContent(t), new Yr(this, this.computeAttrs(e), t, Ue.setFrom(r));
  }
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = U.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(U.empty, !0);
    return s ? new Yr(this, e, t.append(s), Ue.setFrom(r)) : null;
  }
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : Ue.none : e;
  }
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new Vd(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
class rR {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Au {
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = Q0(i.attrs), this.excluded = null;
    let s = X0(this.attrs);
    this.instance = s ? new Ue(this, s) : null;
  }
  create(e = null) {
    return !e && this.instance ? this.instance : new Ue(this, Z0(this.attrs, e));
  }
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new Au(s, i++, t, o)), r;
  }
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class iR {
  constructor(e) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = Rt.from(e.nodes), t.marks = Rt.from(e.marks || {}), this.nodes = Vd.compile(this.spec.nodes, this), this.marks = Au.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks;
      s.contentMatch = r[o] || (r[o] = ls.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.markSet = l == "_" ? null : l ? mg(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : mg(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Vd) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  text(e, t) {
    let r = this.nodes.text;
    return new Ul(r, r.defaultAttrs, e, Ue.setFrom(t));
  }
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  nodeFromJSON(e) {
    return Yr.fromJSON(this, e);
  }
  markFromJSON(e) {
    return Ue.fromJSON(this, e);
  }
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function mg(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let l in n.marks) {
        let u = n.marks[l];
        (i == "_" || u.spec.group && u.spec.group.split(" ").indexOf(i) > -1) && t.push(o = u);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
class so {
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [], t.forEach((r) => {
      r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  parse(e, t = {}) {
    let r = new vg(this, t, !1);
    return r.addAll(e, t.from, t.to), r.finish();
  }
  parseSlice(e, t = {}) {
    let r = new vg(this, t, !0);
    return r.addAll(e, t.from, t.to), Z.maxOpen(r.finish());
  }
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (aR(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], l = o.style;
      if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let u = o.getAttrs(t);
          if (u === !1)
            continue;
          o.attrs = u || void 0;
        }
        return o;
      }
    }
  }
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let l = t[o];
        if ((l.priority == null ? 50 : l.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = yg(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = yg(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new so(e, so.schemaRules(e)));
  }
}
const ey = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, sR = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, ty = { ol: !0, ul: !0 }, jl = 1, ql = 2, na = 4;
function gg(n, e, t) {
  return e != null ? (e ? jl : 0) | (e === "full" ? ql : 0) : n && n.whitespace == "pre" ? jl | ql : t & ~na;
}
class Dl {
  constructor(e, t, r, i, s, o, l) {
    this.type = e, this.attrs = t, this.marks = r, this.pendingMarks = i, this.solid = s, this.options = l, this.content = [], this.activeMarks = Ue.none, this.stashMarks = [], this.match = o || (l & na ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(U.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & jl)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = U.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(U.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  popFromStashMark(e) {
    for (let t = this.stashMarks.length - 1; t >= 0; t--)
      if (e.eq(this.stashMarks[t]))
        return this.stashMarks.splice(t, 1)[0];
  }
  applyPending(e) {
    for (let t = 0, r = this.pendingMarks; t < r.length; t++) {
      let i = r[t];
      (this.type ? this.type.allowsMarkType(i.type) : uR(i.type, e)) && !i.isInSet(this.activeMarks) && (this.activeMarks = i.addToSet(this.activeMarks), this.pendingMarks = i.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !ey.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class vg {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0;
    let i = t.topNode, s, o = gg(null, t.preserveWhitespace, 0) | (r ? na : 0);
    i ? s = new Dl(i.type, i.attrs, Ue.none, Ue.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new Dl(null, null, Ue.none, Ue.none, !0, null, o) : s = new Dl(e.schema.topNodeType, null, Ue.none, Ue.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(e) {
    if (e.nodeType == 3)
      this.addTextNode(e);
    else if (e.nodeType == 1) {
      let t = e.getAttribute("style");
      if (!t)
        this.addElement(e);
      else {
        let r = this.readStyles(lR(t));
        if (!r)
          return;
        let [i, s] = r, o = this.top;
        for (let l = 0; l < s.length; l++)
          this.removePendingMark(s[l], o);
        for (let l = 0; l < i.length; l++)
          this.addPendingMark(i[l]);
        this.addElement(e);
        for (let l = 0; l < i.length; l++)
          this.removePendingMark(i[l], o);
        for (let l = 0; l < s.length; l++)
          this.addPendingMark(s[l]);
      }
    }
  }
  addTextNode(e) {
    let t = e.nodeValue, r = this.top;
    if (r.options & ql || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(t)) {
      if (r.options & jl)
        r.options & ql ? t = t.replace(/\r\n?/g, `
`) : t = t.replace(/\r?\n|\r/g, " ");
      else if (t = t.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(t) && this.open == this.nodes.length - 1) {
        let i = r.content[r.content.length - 1], s = e.previousSibling;
        (!i || s && s.nodeName == "BR" || i.isText && /[ \t\r\n\u000c]$/.test(i.text)) && (t = t.slice(1));
      }
      t && this.insertNode(this.parser.schema.text(t)), this.findInText(e);
    } else
      this.findInside(e);
  }
  addElement(e, t) {
    let r = e.nodeName.toLowerCase(), i;
    ty.hasOwnProperty(r) && this.parser.normalizeLists && oR(e);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, t));
    if (s ? s.ignore : sR.hasOwnProperty(r))
      this.findInside(e), this.ignoreFallback(e);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
      let o, l = this.top, u = this.needsBlock;
      if (ey.hasOwnProperty(r))
        l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), o = !0, l.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      this.addAll(e), o && this.sync(l), this.needsBlock = u;
    } else
      this.addElementByRule(e, s, s.consuming === !1 ? i : void 0);
  }
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  readStyles(e) {
    let t = Ue.none, r = Ue.none;
    e:
      for (let i = 0; i < e.length; i += 2)
        for (let s = void 0; ; ) {
          let o = this.parser.matchStyle(e[i], e[i + 1], this, s);
          if (!o)
            continue e;
          if (o.ignore)
            return null;
          if (o.clearMark ? this.top.pendingMarks.forEach((l) => {
            o.clearMark(l) && (r = l.addToSet(r));
          }) : t = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(t), o.consuming === !1)
            s = o;
          else
            break;
        }
    return [t, r];
  }
  addElementByRule(e, t, r) {
    let i, s, o;
    t.node ? (s = this.parser.schema.nodes[t.node], s.isLeaf ? this.insertNode(s.create(t.attrs)) || this.leafFallback(e) : i = this.enter(s, t.attrs || null, t.preserveWhitespace)) : (o = this.parser.schema.marks[t.mark].create(t.attrs), this.addPendingMark(o));
    let l = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, r);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((u) => this.insertNode(u));
    else {
      let u = e;
      typeof t.contentElement == "string" ? u = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? u = t.contentElement(e) : t.contentElement && (u = t.contentElement), this.findAround(e, u, !0), this.addAll(u);
    }
    i && this.sync(l) && this.open--, o && this.removePendingMark(o, l);
  }
  addAll(e, t, r) {
    let i = t || 0;
    for (let s = t ? e.childNodes[t] : e.firstChild, o = r == null ? null : e.childNodes[r]; s != o; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s);
    this.findAtPoint(e, i);
  }
  findPlace(e) {
    let t, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], o = s.findWrapping(e);
      if (o && (!t || t.length > o.length) && (t = o, r = s, !o.length) || s.solid)
        break;
    }
    if (!t)
      return !1;
    this.sync(r);
    for (let i = 0; i < t.length; i++)
      this.enterInner(t[i], null, !1);
    return !0;
  }
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let t = this.textblockFromContext();
      t && this.enterInner(t);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let t = this.top;
      t.applyPending(e.type), t.match && (t.match = t.match.matchType(e.type));
      let r = t.activeMarks;
      for (let i = 0; i < e.marks.length; i++)
        (!t.type || t.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
      return t.content.push(e.mark(r)), !0;
    }
    return !1;
  }
  enter(e, t, r) {
    let i = this.findPlace(e.create(t));
    return i && this.enterInner(e, t, !0, r), i;
  }
  enterInner(e, t = null, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.applyPending(e), s.match = s.match && s.match.matchType(e);
    let o = gg(e, i, s.options);
    s.options & na && s.content.length == 0 && (o |= na), this.nodes.push(new Dl(e, t, s.activeMarks, s.pendingMarks, r, null, o)), this.open++;
  }
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--)
      if (this.nodes[t] == e)
        return this.open = t, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, u) => {
      for (; l >= 0; l--) {
        let d = t[l];
        if (d == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; u >= s; u--)
            if (o(l - 1, u))
              return !0;
          return !1;
        } else {
          let f = u > 0 || u == 0 && i ? this.nodes[u].type : r && u >= s ? r.node(u - s).type : null;
          if (!f || f.name != d && f.groups.indexOf(d) == -1)
            return !1;
          u--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
  addPendingMark(e) {
    let t = cR(e, this.top.pendingMarks);
    t && this.top.stashMarks.push(t), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, t) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r];
      if (i.pendingMarks.lastIndexOf(e) > -1)
        i.pendingMarks = e.removeFromSet(i.pendingMarks);
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks);
        let o = i.popFromStashMark(e);
        o && i.type && i.type.allowsMarkType(o.type) && (i.activeMarks = o.addToSet(i.activeMarks));
      }
      if (i == t)
        break;
    }
  }
}
function oR(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && ty.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function aR(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function lR(n) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, t, r = [];
  for (; t = e.exec(n); )
    r.push(t[1], t[2].trim());
  return r;
}
function yg(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function uR(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (l) => {
      s.push(l);
      for (let u = 0; u < l.edgeCount; u++) {
        let { type: d, next: f } = l.edge(u);
        if (d == e || s.indexOf(f) < 0 && o(f))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
function cR(n, e) {
  for (let t = 0; t < e.length; t++)
    if (n.eq(e[t]))
      return e[t];
}
class Ar {
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  serializeFragment(e, t = {}, r) {
    r || (r = id(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let l = 0, u = 0;
        for (; l < s.length && u < o.marks.length; ) {
          let d = o.marks[u];
          if (!this.marks[d.type.name]) {
            u++;
            continue;
          }
          if (!d.eq(s[l][0]) || d.type.spec.spanning === !1)
            break;
          l++, u++;
        }
        for (; l < s.length; )
          i = s.pop()[1];
        for (; u < o.marks.length; ) {
          let d = o.marks[u++], f = this.serializeMark(d, o.isInline, t);
          f && (s.push([d, i]), i.appendChild(f.dom), i = f.contentDOM || f.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = Ar.renderSpec(id(t), this.nodes[e.type.name](e));
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && Ar.renderSpec(id(r), i(e, t));
  }
  static renderSpec(e, t, r = null) {
    if (typeof t == "string")
      return { dom: e.createTextNode(t) };
    if (t.nodeType != null)
      return { dom: t };
    if (t.dom && t.dom.nodeType != null)
      return t;
    let i = t[0], s = i.indexOf(" ");
    s > 0 && (r = i.slice(0, s), i = i.slice(s + 1));
    let o, l = r ? e.createElementNS(r, i) : e.createElement(i), u = t[1], d = 1;
    if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
      d = 2;
      for (let f in u)
        if (u[f] != null) {
          let h = f.indexOf(" ");
          h > 0 ? l.setAttributeNS(f.slice(0, h), f.slice(h + 1), u[f]) : l.setAttribute(f, u[f]);
        }
    }
    for (let f = d; f < t.length; f++) {
      let h = t[f];
      if (h === 0) {
        if (f < t.length - 1 || f > d)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: l, contentDOM: l };
      } else {
        let { dom: m, contentDOM: g } = Ar.renderSpec(e, h, r);
        if (l.appendChild(m), g) {
          if (o)
            throw new RangeError("Multiple content holes");
          o = g;
        }
      }
    }
    return { dom: l, contentDOM: o };
  }
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Ar(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  static nodesFromSchema(e) {
    let t = bg(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  static marksFromSchema(e) {
    return bg(e.marks);
  }
}
function bg(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function id(n) {
  return n.document || window.document;
}
const ny = 65535, ry = Math.pow(2, 16);
function dR(n, e) {
  return n + e * ry;
}
function _g(n) {
  return n & ny;
}
function fR(n) {
  return (n - (n & ny)) / ry;
}
const iy = 1, sy = 2, Ol = 4, oy = 8;
class Hd {
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  get deleted() {
    return (this.delInfo & oy) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (iy | Ol)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (sy | Ol)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & Ol) > 0;
  }
}
class jn {
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && jn.empty)
      return jn.empty;
  }
  recover(e) {
    let t = 0, r = _g(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + fR(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let u = this.ranges[l] - (this.inverted ? i : 0);
      if (u > e)
        break;
      let d = this.ranges[l + s], f = this.ranges[l + o], h = u + d;
      if (e <= h) {
        let m = d ? e == u ? -1 : e == h ? 1 : t : t, g = u + i + (m < 0 ? 0 : f);
        if (r)
          return g;
        let y = e == (t < 0 ? u : h) ? null : dR(l / 3, e - u), b = e == u ? sy : e == h ? iy : Ol;
        return (t < 0 ? e != u : e != h) && (b |= oy), new Hd(g, b, y);
      }
      i += f - d;
    }
    return r ? e + i : new Hd(e + i, 0, null);
  }
  touches(e, t) {
    let r = 0, i = _g(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let u = this.ranges[l] - (this.inverted ? r : 0);
      if (u > e)
        break;
      let d = this.ranges[l + s], f = u + d;
      if (e <= f && l == i * 3)
        return !0;
      r += this.ranges[l + o] - d;
    }
    return !1;
  }
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], l = o - (this.inverted ? s : 0), u = o + (this.inverted ? 0 : s), d = this.ranges[i + t], f = this.ranges[i + r];
      e(l, l + d, u, u + f), s += f - d;
    }
  }
  invert() {
    return new jn(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(e) {
    return e == 0 ? jn.empty : new jn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
jn.empty = new jn([]);
class Ys {
  constructor(e = [], t, r = 0, i = e.length) {
    this.maps = e, this.mirror = t, this.from = r, this.to = i;
  }
  slice(e = 0, t = this.maps.length) {
    return new Ys(this.maps, this.mirror, e, t);
  }
  copy() {
    return new Ys(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  appendMap(e, t) {
    this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
  }
  appendMapping(e) {
    for (let t = 0, r = this.maps.length; t < e.maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this.maps.length + e.maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  invert() {
    let e = new Ys();
    return e.appendMappingInverted(this), e;
  }
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, t);
    return e;
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], l = o.mapResult(e, t);
      if (l.recover != null) {
        let u = this.getMirror(s);
        if (u != null && u > s && u < this.to) {
          s = u, e = this.maps[u].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new Hd(e, i, null);
  }
}
const sd = /* @__PURE__ */ Object.create(null);
class yn {
  getMap() {
    return jn.empty;
  }
  merge(e) {
    return null;
  }
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = sd[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  static jsonID(e, t) {
    if (e in sd)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return sd[e] = t, t.prototype.jsonID = e, t;
  }
}
class xt {
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  static ok(e) {
    return new xt(e, null);
  }
  static fail(e) {
    return new xt(null, e);
  }
  static fromReplace(e, t, r, i) {
    try {
      return xt.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof Vl)
        return xt.fail(s.message);
      throw s;
    }
  }
}
function Mf(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(Mf(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return U.fromArray(r);
}
class bi extends yn {
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new Z(Mf(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return xt.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Er(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new bi(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof bi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new bi(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new bi(t.from, t.to, e.markFromJSON(t.mark));
  }
}
yn.jsonID("addMark", bi);
class Er extends yn {
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new Z(Mf(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return xt.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new bi(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Er(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Er && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Er(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Er(t.from, t.to, e.markFromJSON(t.mark));
  }
}
yn.jsonID("removeMark", Er);
class _i extends yn {
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return xt.fromReplace(e, this.pos, this.pos + 1, new Z(U.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new _i(this.pos, t.marks[i]);
        return new _i(this.pos, this.mark);
      }
    }
    return new oo(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new _i(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _i(t.pos, e.markFromJSON(t.mark));
  }
}
yn.jsonID("addNodeMark", _i);
class oo extends yn {
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return xt.fromReplace(e, this.pos, this.pos + 1, new Z(U.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new _i(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new oo(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new oo(t.pos, e.markFromJSON(t.mark));
  }
}
yn.jsonID("removeNodeMark", oo);
class jt extends yn {
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Wd(e, this.from, this.to) ? xt.fail("Structure replace would overwrite content") : xt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new jn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new jt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new jt(t.pos, Math.max(t.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof jt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? Z.empty : new Z(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new jt(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? Z.empty : new Z(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new jt(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new jt(t.from, t.to, Z.fromJSON(e, t.slice), !!t.structure);
  }
}
yn.jsonID("replace", jt);
class Tt extends yn {
  constructor(e, t, r, i, s, o, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l;
  }
  apply(e) {
    if (this.structure && (Wd(e, this.from, this.gapFrom) || Wd(e, this.gapTo, this.to)))
      return xt.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return xt.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? xt.fromReplace(e, this.from, this.to, r) : xt.fail("Content does not fit in gap");
  }
  getMap() {
    return new jn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Tt(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = e.map(this.gapFrom, -1), s = e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new Tt(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Tt(t.from, t.to, t.gapFrom, t.gapTo, Z.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
yn.jsonID("replaceAround", Tt);
function Wd(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function pR(n, e, t, r) {
  let i = [], s = [], o, l;
  n.doc.nodesBetween(e, t, (u, d, f) => {
    if (!u.isInline)
      return;
    let h = u.marks;
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      let m = Math.max(d, e), g = Math.min(d + u.nodeSize, t), y = r.addToSet(h);
      for (let b = 0; b < h.length; b++)
        h[b].isInSet(y) || (o && o.to == m && o.mark.eq(h[b]) ? o.to = g : i.push(o = new Er(m, g, h[b])));
      l && l.to == m ? l.to = g : s.push(l = new bi(m, g, r));
    }
  }), i.forEach((u) => n.step(u)), s.forEach((u) => n.step(u));
}
function hR(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (!o.isInline)
      return;
    s++;
    let u = null;
    if (r instanceof Au) {
      let d = o.marks, f;
      for (; f = r.isInSet(d); )
        (u || (u = [])).push(f), d = f.removeFromSet(d);
    } else
      r ? r.isInSet(o.marks) && (u = [r]) : u = o.marks;
    if (u && u.length) {
      let d = Math.min(l + o.nodeSize, t);
      for (let f = 0; f < u.length; f++) {
        let h = u[f], m;
        for (let g = 0; g < i.length; g++) {
          let y = i[g];
          y.step == s - 1 && h.eq(i[g].style) && (m = y);
        }
        m ? (m.to = d, m.step = s) : i.push({ style: h, from: Math.max(l, e), to: d, step: s });
      }
    }
  }), i.forEach((o) => n.step(new Er(o.from, o.to, o.style)));
}
function mR(n, e, t, r = t.contentMatch) {
  let i = n.doc.nodeAt(e), s = [], o = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let u = i.child(l), d = o + u.nodeSize, f = r.matchType(u.type);
    if (!f)
      s.push(new jt(o, d, Z.empty));
    else {
      r = f;
      for (let h = 0; h < u.marks.length; h++)
        t.allowsMarkType(u.marks[h].type) || n.step(new Er(o, d, u.marks[h]));
    }
    o = d;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(U.empty, !0);
    n.replace(o, o, new Z(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    n.step(s[l]);
}
function gR(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function go(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !gR(i, s, o))
      break;
  }
  return null;
}
function vR(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), u = o, d = l, f = U.empty, h = 0;
  for (let y = s, b = !1; y > t; y--)
    b || r.index(y) > 0 ? (b = !0, f = U.from(r.node(y).copy(f)), h++) : u--;
  let m = U.empty, g = 0;
  for (let y = s, b = !1; y > t; y--)
    b || i.after(y + 1) < i.end(y) ? (b = !0, m = U.from(i.node(y).copy(m)), g++) : d++;
  n.step(new Tt(u, d, o, l, new Z(f.append(m), h, g), f.size - h, !0));
}
function Of(n, e, t = null, r = n) {
  let i = yR(n, e), s = i && bR(r, e);
  return s ? i.map(wg).concat({ type: e, attrs: t }).concat(s.map(wg)) : null;
}
function wg(n) {
  return { type: n, attrs: null };
}
function yR(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function bR(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let u = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let d = r; u && d < i; d++)
    u = u.matchType(t.child(d).type);
  return !u || !u.validEnd ? null : o;
}
function _R(n, e, t) {
  let r = U.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let l = t[o].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = U.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new Tt(i, s, i, s, new Z(r, 0, 0), t.length, !0));
}
function wR(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (o.isTextblock && !o.hasMarkup(r, i) && DR(n.doc, n.mapping.slice(s).map(l), r)) {
      n.clearIncompatible(n.mapping.slice(s).map(l, 1), r);
      let u = n.mapping.slice(s), d = u.map(l, 1), f = u.map(l + o.nodeSize, 1);
      return n.step(new Tt(d, f, d + 1, f - 1, new Z(U.from(r.create(i, null, o.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function DR(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function CR(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Tt(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new Z(U.from(o), 0, 0), 1, !0));
}
function Xs(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let d = i.depth - 1, f = t - 2; d > s; d--, f--) {
    let h = i.node(d), m = i.index(d);
    if (h.type.spec.isolating)
      return !1;
    let g = h.content.cutByIndex(m, h.childCount), y = r && r[f] || h;
    if (y != h && (g = g.replaceChild(0, y.type.create(y.attrs))), !h.canReplace(m + 1, h.childCount) || !y.type.validContent(g))
      return !1;
  }
  let l = i.indexAfter(s), u = r && r[0];
  return i.node(s).canReplaceWith(l, l, u ? u.type : i.node(s + 1).type);
}
function xR(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = U.empty, o = U.empty;
  for (let l = i.depth, u = i.depth - t, d = t - 1; l > u; l--, d--) {
    s = U.from(i.node(l).copy(s));
    let f = r && r[d];
    o = U.from(f ? f.type.create(f.attrs, o) : i.node(l).copy(o));
  }
  n.step(new jt(e, e, new Z(s.append(o), t, t), !0));
}
function Mi(n, e) {
  let t = n.resolve(e), r = t.index();
  return ay(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function ay(n, e) {
  return !!(n && e && !n.isLeaf && n.canAppend(e));
}
function ly(n, e, t = -1) {
  let r = n.resolve(e);
  for (let i = r.depth; ; i--) {
    let s, o, l = r.index(i);
    if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : t > 0 ? (s = r.node(i + 1), l++, o = r.node(i).maybeChild(l)) : (s = r.node(i).maybeChild(l - 1), o = r.node(i + 1)), s && !s.isTextblock && ay(s, o) && r.node(i).canReplace(l, l + 1))
      return e;
    if (i == 0)
      break;
    e = t < 0 ? r.before(i) : r.after(i);
  }
}
function kR(n, e, t) {
  let r = new jt(e - t, e + t, Z.empty, !0);
  n.step(r);
}
function SR(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function uy(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, u = r.index(o) + (l > 0 ? 1 : 0), d = r.node(o), f = !1;
      if (s == 1)
        f = d.canReplace(u, u, i);
      else {
        let h = d.contentMatchAt(u).findWrapping(i.firstChild.type);
        f = h && d.canReplaceWith(u, u, h[0]);
      }
      if (f)
        return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function Ff(n, e, t = e, r = Z.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return cy(i, s, r) ? new jt(e, t, r) : new AR(i, s, r).fit();
}
function cy(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class AR {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = U.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = U.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let d = this.findFittable();
      d ? this.placeNodes(d) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, l = i.depth;
    for (; o && l && s.childCount == 1; )
      s = s.firstChild.content, o--, l--;
    let u = new Z(s, o, l);
    return e > -1 ? new Tt(r.pos, e, this.$to.pos, this.$to.end(), u, t) : u.size || r.pos != this.$to.pos ? new jt(r.pos, i.pos, u) : null;
  }
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = od(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: u, match: d } = this.frontier[l], f, h = null;
          if (t == 1 && (o ? d.matchType(o.type) || (h = d.fillBefore(U.from(o), !1)) : s && u.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, inject: h };
          if (t == 2 && o && (f = d.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, wrap: f };
          if (s && d.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = od(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Z(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = od(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new Z(Jo(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new Z(Jo(e, t, 1), t, r);
  }
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let b = 0; b < s.length; b++)
        this.openFrontierNode(s[b]);
    let o = this.unplaced, l = r ? r.content : o.content, u = o.openStart - e, d = 0, f = [], { match: h, type: m } = this.frontier[t];
    if (i) {
      for (let b = 0; b < i.childCount; b++)
        f.push(i.child(b));
      h = h.matchFragment(i);
    }
    let g = l.size + e - (o.content.size - o.openEnd);
    for (; d < l.childCount; ) {
      let b = l.child(d), w = h.matchType(b.type);
      if (!w)
        break;
      d++, (d > 1 || u == 0 || b.content.size) && (h = w, f.push(dy(b.mark(m.allowedMarks(b.marks)), d == 1 ? u : 0, d == l.childCount ? g : -1)));
    }
    let y = d == l.childCount;
    y || (g = -1), this.placed = Yo(this.placed, t, U.from(f)), this.frontier[t].match = h, y && g < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let b = 0, w = l; b < g; b++) {
      let T = w.lastChild;
      this.frontier.push({ type: T.type, match: T.contentMatchAt(T.childCount) }), w = T.content;
    }
    this.unplaced = y ? e == 0 ? Z.empty : new Z(Jo(o.content, e - 1, 1), e - 1, g < 0 ? o.openEnd : e - 1) : new Z(Jo(o.content, e, d), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !ad(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
        let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = ad(e, t, i, r, s);
        if (o) {
          for (let l = t - 1; l >= 0; l--) {
            let { match: u, type: d } = this.frontier[l], f = ad(e, l, d, u, !0);
            if (!f || f.childCount)
              continue e;
          }
          return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
        }
      }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Yo(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Yo(this.placed, this.depth, U.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(U.empty, !0);
    t.childCount && (this.placed = Yo(this.placed, this.frontier.length, t));
  }
}
function Jo(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(Jo(n.firstChild.content, e - 1, t)));
}
function Yo(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Yo(n.lastChild.content, e - 1, t)));
}
function od(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function dy(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, dy(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(U.empty, !0)))), n.copy(r);
}
function ad(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let l = r.fillBefore(s.content, !0, o);
  return l && !ER(t, s.content, o) ? l : null;
}
function ER(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function TR(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function MR(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (cy(i, s, r))
    return n.step(new jt(e, t, r));
  let o = py(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let l = -(i.depth + 1);
  o.unshift(l);
  for (let m = i.depth, g = i.pos - 1; m > 0; m--, g--) {
    let y = i.node(m).type.spec;
    if (y.defining || y.definingAsContext || y.isolating)
      break;
    o.indexOf(m) > -1 ? l = m : i.before(m) == g && o.splice(1, 0, -m);
  }
  let u = o.indexOf(l), d = [], f = r.openStart;
  for (let m = r.content, g = 0; ; g++) {
    let y = m.firstChild;
    if (d.push(y), g == r.openStart)
      break;
    m = y.content;
  }
  for (let m = f - 1; m >= 0; m--) {
    let g = d[m].type, y = TR(g);
    if (y && i.node(u).type != g)
      f = m;
    else if (y || !g.isTextblock)
      break;
  }
  for (let m = r.openStart; m >= 0; m--) {
    let g = (m + f + 1) % (r.openStart + 1), y = d[g];
    if (y)
      for (let b = 0; b < o.length; b++) {
        let w = o[(b + u) % o.length], T = !0;
        w < 0 && (T = !1, w = -w);
        let k = i.node(w - 1), S = i.index(w - 1);
        if (k.canReplaceWith(S, S, y.type, y.marks))
          return n.replace(i.before(w), T ? s.after(w) : t, new Z(fy(r.content, 0, r.openStart, g), g, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let m = o.length - 1; m >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); m--) {
    let g = o[m];
    g < 0 || (e = i.before(g), t = s.after(g));
  }
}
function fy(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(fy(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(U.empty, !0));
  }
  return n;
}
function OR(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = SR(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new Z(U.from(r), 0, 0));
}
function FR(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = py(r, i);
  for (let o = 0; o < s.length; o++) {
    let l = s[o], u = o == s.length - 1;
    if (u && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (u || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o)
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function py(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class Zs extends yn {
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xt.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return xt.fromReplace(e, this.pos, this.pos + 1, new Z(U.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return jn.empty;
  }
  invert(e) {
    return new Zs(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Zs(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Zs(t.pos, t.attr, t.value);
  }
}
yn.jsonID("attr", Zs);
let ao = class extends Error {
};
ao = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
ao.prototype = Object.create(Error.prototype);
ao.prototype.constructor = ao;
ao.prototype.name = "TransformError";
class If {
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Ys();
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new ao(t.failed);
    return this;
  }
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  replace(e, t = e, r = Z.empty) {
    let i = Ff(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  replaceWith(e, t, r) {
    return this.replace(e, t, new Z(U.from(r), 0, 0));
  }
  delete(e, t) {
    return this.replace(e, t, Z.empty);
  }
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  replaceRange(e, t, r) {
    return MR(this, e, t, r), this;
  }
  replaceRangeWith(e, t, r) {
    return OR(this, e, t, r), this;
  }
  deleteRange(e, t) {
    return FR(this, e, t), this;
  }
  lift(e, t) {
    return vR(this, e, t), this;
  }
  join(e, t = 1) {
    return kR(this, e, t), this;
  }
  wrap(e, t) {
    return _R(this, e, t), this;
  }
  setBlockType(e, t = e, r, i = null) {
    return wR(this, e, t, r, i), this;
  }
  setNodeMarkup(e, t, r = null, i) {
    return CR(this, e, t, r, i), this;
  }
  setNodeAttribute(e, t, r) {
    return this.step(new Zs(e, t, r)), this;
  }
  addNodeMark(e, t) {
    return this.step(new _i(e, t)), this;
  }
  removeNodeMark(e, t) {
    if (!(t instanceof Ue)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (t = t.isInSet(r.marks), !t)
        return this;
    }
    return this.step(new oo(e, t)), this;
  }
  split(e, t = 1, r) {
    return xR(this, e, t, r), this;
  }
  addMark(e, t, r) {
    return pR(this, e, t, r), this;
  }
  removeMark(e, t, r) {
    return hR(this, e, t, r), this;
  }
  clearIncompatible(e, t, r) {
    return mR(this, e, t, r), this;
  }
}
const ld = /* @__PURE__ */ Object.create(null);
class _e {
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new hy(e.min(t), e.max(t))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  replace(e, t = Z.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      let { $from: u, $to: d } = o[l], f = e.mapping.slice(s);
      e.replaceRange(f.map(u.pos), f.map(d.pos), l ? Z.empty : t), l == 0 && xg(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: l } = i[s], u = e.mapping.slice(r), d = u.map(o.pos), f = u.map(l.pos);
      s ? e.deleteRange(d, f) : (e.replaceRangeWith(d, f, t), xg(e, r, t.isInline ? -1 : 1));
    }
  }
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new we(e) : Bs(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? Bs(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : Bs(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new dr(e.node(0));
  }
  static atStart(e) {
    return Bs(e, e, 0, 0, 1) || new dr(e);
  }
  static atEnd(e) {
    return Bs(e, e, e.content.size, e.childCount, -1) || new dr(e);
  }
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = ld[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  static jsonID(e, t) {
    if (e in ld)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return ld[e] = t, t.prototype.jsonID = e, t;
  }
  getBookmark() {
    return we.between(this.$anchor, this.$head).getBookmark();
  }
}
_e.prototype.visible = !0;
class hy {
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let Dg = !1;
function Cg(n) {
  !Dg && !n.parent.inlineContent && (Dg = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class we extends _e {
  constructor(e, t = e) {
    Cg(e), Cg(t), super(e, t);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return _e.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new we(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = Z.empty) {
    if (super.replace(e, t), t == Z.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof we && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Eu(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new we(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = _e.findFrom(t, r, !0) || _e.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return _e.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (_e.findFrom(e, -r, !0) || _e.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new we(e, t);
  }
}
_e.jsonID("text", we);
class Eu {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new Eu(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return we.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ve extends _e {
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? _e.near(s) : new ve(s);
  }
  content() {
    return new Z(U.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ve && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Rf(this.anchor);
  }
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ve(e.resolve(t.anchor));
  }
  static create(e, t) {
    return new ve(e.resolve(t));
  }
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ve.prototype.visible = !1;
_e.jsonID("node", ve);
class Rf {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new Eu(r, r) : new Rf(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && ve.isSelectable(r) ? new ve(t) : _e.near(t);
  }
}
class dr extends _e {
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = Z.empty) {
    if (t == Z.empty) {
      e.delete(0, e.doc.content.size);
      let r = _e.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(e) {
    return new dr(e);
  }
  map(e) {
    return new dr(e);
  }
  eq(e) {
    return e instanceof dr;
  }
  getBookmark() {
    return IR;
  }
}
_e.jsonID("all", dr);
const IR = {
  map() {
    return this;
  },
  resolve(n) {
    return new dr(n);
  }
};
function Bs(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return we.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let l = e.child(o);
    if (l.isAtom) {
      if (!s && ve.isSelectable(l))
        return ve.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let u = Bs(n, l, t + i, i < 0 ? l.childCount : 0, i, s);
      if (u)
        return u;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function xg(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof jt || i instanceof Tt))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((l, u, d, f) => {
    o == null && (o = f);
  }), n.setSelection(_e.near(n.doc.resolve(o), t));
}
const kg = 1, Cl = 2, Sg = 4;
class RR extends If {
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | kg) & ~Cl, this.storedMarks = null, this;
  }
  get selectionSet() {
    return (this.updated & kg) > 0;
  }
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Cl, this;
  }
  ensureMarks(e) {
    return Ue.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  get storedMarksSet() {
    return (this.updated & Cl) > 0;
  }
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Cl, this.storedMarks = null;
  }
  setTime(e) {
    return this.time = e, this;
  }
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Ue.none))), r.replaceWith(this, e), this;
  }
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(_e.near(this.selection.$to)), this;
    }
  }
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  scrollIntoView() {
    return this.updated |= Sg, this;
  }
  get scrolledIntoView() {
    return (this.updated & Sg) > 0;
  }
}
function Ag(n, e) {
  return !e || !n ? n : n.bind(e);
}
class Xo {
  constructor(e, t, r) {
    this.name = e, this.init = Ag(t.init, r), this.apply = Ag(t.apply, r);
  }
}
const NR = [
  new Xo("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new Xo("selection", {
    init(n, e) {
      return n.selection || _e.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new Xo("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new Xo("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class ud {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = NR.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Xo(r.key, r.spec.state, r));
    });
  }
}
class Ps {
  constructor(e) {
    this.config = e;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(e) {
    return this.applyTransaction(e).state;
  }
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let l = this.config.plugins[o];
        if (l.spec.appendTransaction) {
          let u = i ? i[o].n : 0, d = i ? i[o].state : this, f = u < t.length && l.spec.appendTransaction.call(l, u ? t.slice(u) : t, d, r);
          if (f && r.filterTransaction(f, o)) {
            if (f.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(f), r = r.applyInner(f), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Ps(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  get tr() {
    return new RR(this);
  }
  static create(e) {
    let t = new ud(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Ps(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  reconfigure(e) {
    let t = new ud(this.schema, e.plugins), r = t.fields, i = new Ps(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new ud(e.schema, e.plugins), s = new Ps(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Yr.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = _e.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let u = r[l], d = u.spec.state;
            if (u.key == o.name && d && d.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              s[o.name] = d.fromJSON.call(u, e, t[l], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function my(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = my(i, e, {})), t[r] = i;
  }
  return t;
}
class kt {
  constructor(e) {
    this.spec = e, this.props = {}, e.props && my(e.props, this, this.props), this.key = e.key ? e.key.key : gy("plugin");
  }
  getState(e) {
    return e[this.key];
  }
}
const cd = /* @__PURE__ */ Object.create(null);
function gy(n) {
  return n in cd ? n + "$" + ++cd[n] : (cd[n] = 0, n + "$");
}
class Gt {
  constructor(e = "key") {
    this.key = gy(e);
  }
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  getState(e) {
    return e[this.key];
  }
}
const Sn = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, pa = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Eg = null;
const jr = function(n, e, t) {
  let r = Eg || (Eg = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, us = function(n, e, t, r) {
  return t && (Tg(n, e, t, r, -1) || Tg(n, e, t, r, 1));
}, BR = /^(img|br|input|textarea|hr)$/i;
function Tg(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Sr(n))) {
      let s = n.parentNode;
      if (!s || s.nodeType != 1 || LR(n) || BR.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = Sn(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.contentEditable == "false")
        return !1;
      e = i < 0 ? Sr(n) : 0;
    } else
      return !1;
  }
}
function Sr(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function $R(n, e, t) {
  for (let r = e == 0, i = e == Sr(n); r || i; ) {
    if (n == t)
      return !0;
    let s = Sn(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == Sr(n);
  }
}
function LR(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const Tu = function(n) {
  return n.focusNode && us(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Ji(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function PR(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
const Si = typeof navigator < "u" ? navigator : null, Mg = typeof document < "u" ? document : null, hs = Si && Si.userAgent || "", Ud = /Edge\/(\d+)/.exec(hs), vy = /MSIE \d/.exec(hs), jd = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(hs), vn = !!(vy || jd || Ud), Di = vy ? document.documentMode : jd ? +jd[1] : Ud ? +Ud[1] : 0, Mr = !vn && /gecko\/(\d+)/i.test(hs), qd = !vn && /Chrome\/(\d+)/.exec(hs), tn = !!qd, zR = qd ? +qd[1] : 0, sn = !vn && !!Si && /Apple Computer/.test(Si.vendor), lo = sn && (/Mobile\/\w+/.test(hs) || !!Si && Si.maxTouchPoints > 2), Un = lo || (Si ? /Mac/.test(Si.platform) : !1), lr = /Android \d/.test(hs), Mu = !!Mg && "webkitFontSmoothing" in Mg.documentElement.style, VR = Mu ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function HR(n) {
  return {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function di(n, e) {
  return typeof n == "number" ? n : n[e];
}
function WR(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function Og(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; o = pa(o)) {
    if (o.nodeType != 1)
      continue;
    let l = o, u = l == s.body, d = u ? HR(s) : WR(l), f = 0, h = 0;
    if (e.top < d.top + di(r, "top") ? h = -(d.top - e.top + di(i, "top")) : e.bottom > d.bottom - di(r, "bottom") && (h = e.bottom - d.bottom + di(i, "bottom")), e.left < d.left + di(r, "left") ? f = -(d.left - e.left + di(i, "left")) : e.right > d.right - di(r, "right") && (f = e.right - d.right + di(i, "right")), f || h)
      if (u)
        s.defaultView.scrollBy(f, h);
      else {
        let m = l.scrollLeft, g = l.scrollTop;
        h && (l.scrollTop += h), f && (l.scrollLeft += f);
        let y = l.scrollLeft - m, b = l.scrollTop - g;
        e = { left: e.left - y, top: e.top - b, right: e.right - y, bottom: e.bottom - b };
      }
    if (u)
      break;
  }
}
function UR(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let l = n.root.elementFromPoint(s, o);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let u = l.getBoundingClientRect();
    if (u.top >= t - 20) {
      r = l, i = u.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: yy(n.dom) };
}
function yy(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = pa(r))
    ;
  return e;
}
function jR({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  by(t, r == 0 ? 0 : r - e);
}
function by(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Rs = null;
function qR(n) {
  if (n.setActive)
    return n.setActive();
  if (Rs)
    return n.focus(Rs);
  let e = yy(n);
  n.focus(Rs == null ? {
    get preventScroll() {
      return Rs = { preventScroll: !0 }, !0;
    }
  } : void 0), Rs || (Rs = !1, by(e, 0));
}
function _y(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, l = e.top;
  for (let u = n.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = jr(u).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let m = f[h];
      if (m.top <= o && m.bottom >= l) {
        o = Math.max(m.bottom, o), l = Math.min(m.top, l);
        let g = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (g < r) {
          t = u, r = g, i = g && t.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, u.nodeType == 1 && g && (s = d + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      }
      !t && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (s = d + 1);
    }
  }
  return t && t.nodeType == 3 ? KR(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : _y(t, i);
}
function KR(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = fi(r, 1);
    if (s.top != s.bottom && Nf(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function Nf(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function GR(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function JR(n, e, t) {
  let { node: r, offset: i } = _y(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function YR(n, e, t, r) {
  let i = -1;
  for (let s = e; s != n.dom; ) {
    let o = n.docView.nearestDesc(s, !0);
    if (!o)
      return null;
    if (o.dom.nodeType == 1 && (o.node.isBlock && o.parent || !o.contentDOM)) {
      let l = o.dom.getBoundingClientRect();
      if (o.node.isBlock && o.parent && (l.left > r.left || l.top > r.top ? i = o.posBefore : (l.right < r.left || l.bottom < r.top) && (i = o.posAfter)), !o.contentDOM && i < 0)
        return (o.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? o.posBefore : o.posAfter;
    }
    s = o.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function wy(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let l = o.getClientRects();
        for (let u = 0; u < l.length; u++) {
          let d = l[u];
          if (Nf(e, d))
            return wy(o, e, d);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function XR(n, e) {
  let t = n.dom.ownerDocument, r, i = 0;
  if (t.caretPositionFromPoint)
    try {
      let u = t.caretPositionFromPoint(e.left, e.top);
      u && ({ offsetNode: r, offset: i } = u);
    } catch {
    }
  if (!r && t.caretRangeFromPoint) {
    let u = t.caretRangeFromPoint(e.left, e.top);
    u && ({ startContainer: r, startOffset: i } = u);
  }
  let s = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), o;
  if (!s || !n.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = n.dom.getBoundingClientRect();
    if (!Nf(e, u) || (s = wy(n.dom, e, u), !s))
      return null;
  }
  if (sn)
    for (let u = s; r && u; u = pa(u))
      u.draggable && (r = void 0);
  if (s = GR(s, e), r) {
    if (Mr && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++;
    }
    r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? o = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (o = YR(n, r, i, e));
  }
  o == null && (o = JR(n, s, e));
  let l = n.docView.nearestDesc(s, !0);
  return { pos: o, inside: l ? l.posAtStart - l.border : -1 };
}
function fi(n, e) {
  let t = n.getClientRects();
  return t.length ? t[e < 0 ? 0 : t.length - 1] : n.getBoundingClientRect();
}
const ZR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Dy(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = Mu || Mr;
  if (r.nodeType == 3)
    if (o && (ZR.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let u = fi(jr(r, i, i), t);
      if (Mr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let d = fi(jr(r, i - 1, i - 1), -1);
        if (d.top == u.top) {
          let f = fi(jr(r, i, i + 1), -1);
          if (f.top != u.top)
            return Wo(f, f.left < d.left);
        }
      }
      return u;
    } else {
      let u = i, d = i, f = t < 0 ? 1 : -1;
      return t < 0 && !i ? (d++, f = -1) : t >= 0 && i == r.nodeValue.length ? (u--, f = 1) : t < 0 ? u-- : d++, Wo(fi(jr(r, u, d), 1), f < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == Sr(r))) {
      let u = r.childNodes[i - 1];
      if (u.nodeType == 1)
        return dd(u.getBoundingClientRect(), !1);
    }
    if (s == null && i < Sr(r)) {
      let u = r.childNodes[i];
      if (u.nodeType == 1)
        return dd(u.getBoundingClientRect(), !0);
    }
    return dd(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == Sr(r))) {
    let u = r.childNodes[i - 1], d = u.nodeType == 3 ? jr(u, Sr(u) - (o ? 0 : 1)) : u.nodeType == 1 && (u.nodeName != "BR" || !u.nextSibling) ? u : null;
    if (d)
      return Wo(fi(d, 1), !1);
  }
  if (s == null && i < Sr(r)) {
    let u = r.childNodes[i];
    for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords; )
      u = u.nextSibling;
    let d = u ? u.nodeType == 3 ? jr(u, 0, o ? 0 : 1) : u.nodeType == 1 ? u : null : null;
    if (d)
      return Wo(fi(d, -1), !0);
  }
  return Wo(fi(r.nodeType == 3 ? jr(r) : r, -t), t >= 0);
}
function Wo(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function dd(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function Cy(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function QR(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return Cy(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(s, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        s = l.contentDOM || l.dom;
        break;
      }
      s = l.dom.parentNode;
    }
    let o = Dy(n, i.pos, 1);
    for (let l = s.firstChild; l; l = l.nextSibling) {
      let u;
      if (l.nodeType == 1)
        u = l.getClientRects();
      else if (l.nodeType == 3)
        u = jr(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let d = 0; d < u.length; d++) {
        let f = u[d];
        if (f.bottom > f.top + 1 && (t == "up" ? o.top - f.top > (f.bottom - o.top) * 2 : f.bottom - o.bottom > (o.bottom - f.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const eN = /[\u0590-\u08ac]/;
function tN(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection();
  return !eN.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : Cy(n, e, () => {
    let { focusNode: u, focusOffset: d, anchorNode: f, anchorOffset: h } = n.domSelectionRange(), m = l.caretBidiLevel;
    l.modify("move", t, "character");
    let g = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: y, focusOffset: b } = n.domSelectionRange(), w = y && !g.contains(y.nodeType == 1 ? y : y.parentNode) || u == y && d == b;
    try {
      l.collapse(f, h), u && (u != f || d != h) && l.extend && l.extend(u, d);
    } catch {
    }
    return m != null && (l.caretBidiLevel = m), w;
  });
}
let Fg = null, Ig = null, Rg = !1;
function nN(n, e, t) {
  return Fg == e && Ig == t ? Rg : (Fg = e, Ig = t, Rg = t == "up" || t == "down" ? QR(n, e, t) : tN(n, e, t));
}
const fr = 0, Ng = 1, zs = 2, Or = 3;
class Sa {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = fr, r.pmViewDesc = this;
  }
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  parseRule() {
    return null;
  }
  stopEvent(e) {
    return !1;
  }
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > Sn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], l = s + o.size;
      if (l > e || o instanceof ky) {
        i = e - s;
        break;
      }
      s = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof xy && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? Sn(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? Sn(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, l = 0; ; l++) {
      let u = this.children[l], d = o + u.size;
      if (i == -1 && e <= d) {
        let f = o + u.border;
        if (e >= f && t <= d - u.border && u.node && u.contentDOM && this.contentDOM.contains(u.contentDOM))
          return u.parseRange(e, t, f);
        e = o;
        for (let h = l; h > 0; h--) {
          let m = this.children[h - 1];
          if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
            i = Sn(m.dom) + 1;
            break;
          }
          e -= m.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (d > t || l == this.children.length - 1)) {
        t = d;
        for (let f = l + 1; f < this.children.length; f++) {
          let h = this.children[f];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = Sn(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = d;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let m = 0, g = 0; m < this.children.length; m++) {
      let y = this.children[m], b = g + y.size;
      if (s > g && o < b)
        return y.setSelection(e - g - y.border, t - g - y.border, r, i);
      g = b;
    }
    let l = this.domFromPos(e, e ? -1 : 1), u = t == e ? l : this.domFromPos(t, t ? -1 : 1), d = r.getSelection(), f = !1;
    if ((Mr || sn) && e == t) {
      let { node: m, offset: g } = l;
      if (m.nodeType == 3) {
        if (f = !!(g && m.nodeValue[g - 1] == `
`), f && g == m.nodeValue.length)
          for (let y = m, b; y; y = y.parentNode) {
            if (b = y.nextSibling) {
              b.nodeName == "BR" && (l = u = { node: b.parentNode, offset: Sn(b) + 1 });
              break;
            }
            let w = y.pmViewDesc;
            if (w && w.node && w.node.isBlock)
              break;
          }
      } else {
        let y = m.childNodes[g - 1];
        f = y && (y.nodeName == "BR" || y.contentEditable == "false");
      }
    }
    if (Mr && d.focusNode && d.focusNode != u.node && d.focusNode.nodeType == 1) {
      let m = d.focusNode.childNodes[d.focusOffset];
      m && m.contentEditable == "false" && (i = !0);
    }
    if (!(i || f && sn) && us(l.node, l.offset, d.anchorNode, d.anchorOffset) && us(u.node, u.offset, d.focusNode, d.focusOffset))
      return;
    let h = !1;
    if ((d.extend || e == t) && !f) {
      d.collapse(l.node, l.offset);
      try {
        e != t && d.extend(u.node, u.offset), h = !0;
      } catch {
      }
    }
    if (!h) {
      if (e > t) {
        let g = l;
        l = u, u = g;
      }
      let m = document.createRange();
      m.setEnd(u.node, u.offset), m.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(m);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let l = r + s.border, u = o - s.border;
        if (e >= l && t <= u) {
          this.dirty = e == r || t == o ? zs : Ng, e == l && t == u && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Or : s.markDirty(e - l, t - l);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? zs : Or;
      }
      r = o;
    }
    this.dirty = zs;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? zs : Ng;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class xy extends Sa {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(o), o = l;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == fr && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class rN extends Sa {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class cs extends Sa {
  constructor(e, t, r, i) {
    super(e, [], r, i), this.mark = t;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = Ar.renderSpec(document, t.type.spec.toDOM(t, r))), new cs(e, t, o.dom, o.contentDOM || o.dom);
  }
  parseRule() {
    return this.dirty & Or || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(e) {
    return this.dirty != Or && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != fr) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = fr;
    }
  }
  slice(e, t, r) {
    let i = cs.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = Jd(s, t, o, r)), e > 0 && (s = Jd(s, 0, e, r));
    for (let l = 0; l < s.length; l++)
      s[l].parent = i;
    return i.children = s, i;
  }
}
class ds extends Sa {
  constructor(e, t, r, i, s, o, l, u, d) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l, o && this.updateChildren(u, d);
  }
  static create(e, t, r, i, s, o) {
    let l = s.nodeViews[t.type.name], u, d = l && l(t, s, () => {
      if (!u)
        return o;
      if (u.parent)
        return u.parent.posBeforeChild(u);
    }, r, i), f = d && d.dom, h = d && d.contentDOM;
    if (t.isText) {
      if (!f)
        f = document.createTextNode(t.text);
      else if (f.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      f || ({ dom: f, contentDOM: h } = Ar.renderSpec(document, t.type.spec.toDOM(t)));
    !h && !t.isText && f.nodeName != "BR" && (f.hasAttribute("contenteditable") || (f.contentEditable = "false"), t.type.spec.draggable && (f.draggable = !0));
    let m = f;
    return f = Ey(f, r, t), d ? u = new iN(e, t, r, i, f, h || null, m, d, s, o + 1) : t.isText ? new Ou(e, t, r, i, f, m, s) : new ds(e, t, r, i, f, h || null, m, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => U.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == fr && e.eq(this.node) && Gd(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, u = new oN(this, o && o.node, e);
    uN(this.node, this.innerDeco, (d, f, h) => {
      d.spec.marks ? u.syncToMarks(d.spec.marks, r, e) : d.type.side >= 0 && !h && u.syncToMarks(f == this.node.childCount ? Ue.none : this.node.child(f).marks, r, e), u.placeWidget(d, e, i);
    }, (d, f, h, m) => {
      u.syncToMarks(d.marks, r, e);
      let g;
      u.findNodeMatch(d, f, h, m) || l && e.state.selection.from > i && e.state.selection.to < i + d.nodeSize && (g = u.findIndexWithChild(s.node)) > -1 && u.updateNodeAt(d, f, h, g, e) || u.updateNextNode(d, f, h, e, m) || u.addNode(d, f, h, e, i), i += d.nodeSize;
    }), u.syncToMarks([], r, e), this.node.isTextblock && u.addTextblockHacks(), u.destroyRest(), (u.changed || this.dirty == zs) && (o && this.protectLocalComposition(e, o), Sy(this.contentDOM, this.children, e), lo && cN(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof we) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.domSelectionRange(), o = dN(s.focusNode, s.focusOffset);
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let l = o.nodeValue, u = fN(this.node.content, l, r - t, i - t);
      return u < 0 ? null : { node: o, pos: u, text: l };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new rN(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = Jd(this.children, r, r + i.length, e, o);
  }
  update(e, t, r, i) {
    return this.dirty == Or || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = fr;
  }
  updateOuterDeco(e) {
    if (Gd(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = Ay(this.dom, this.nodeDOM, Kd(this.outerDeco, this.node, t), Kd(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Bg(n, e, t, r, i) {
  return Ey(r, e, n), new ds(void 0, n, e, t, r, r, r, i, 0);
}
class Ou extends ds {
  constructor(e, t, r, i, s, o, l) {
    super(e, t, r, i, s, null, o, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == Or || this.dirty != fr && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != fr || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = fr, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new Ou(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Or);
  }
  get domAtom() {
    return !1;
  }
}
class ky extends Sa {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == fr && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class iN extends ds {
  constructor(e, t, r, i, s, o, l, u, d, f) {
    super(e, t, r, i, s, o, l, d, f), this.spec = u;
  }
  update(e, t, r, i) {
    if (this.dirty == Or)
      return !1;
    if (this.spec.update) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function Sy(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], l = o.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = $g(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (o instanceof cs) {
      let u = r ? r.previousSibling : n.lastChild;
      Sy(o.contentDOM, o.children, t), r = u ? u.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = $g(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const ra = function(n) {
  n && (this.nodeName = n);
};
ra.prototype = /* @__PURE__ */ Object.create(null);
const Qi = [new ra()];
function Kd(n, e, t) {
  if (n.length == 0)
    return Qi;
  let r = t ? Qi[0] : new ra(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new ra(o.nodeName));
      for (let l in o) {
        let u = o[l];
        u != null && (t && i.length == 1 && i.push(r = new ra(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + u : l == "style" ? r.style = (r.style ? r.style + ";" : "") + u : l != "nodeName" && (r[l] = u));
      }
    }
  }
  return i;
}
function Ay(n, e, t, r) {
  if (t == Qi && r == Qi)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], l = t[s];
    if (s) {
      let u;
      l && l.nodeName == o.nodeName && i != n && (u = i.parentNode) && u.nodeName.toLowerCase() == o.nodeName || (u = document.createElement(o.nodeName), u.pmIsDeco = !0, u.appendChild(i), l = Qi[0]), i = u;
    }
    sN(i, l || Qi[0], o);
  }
  return i;
}
function sN(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function Ey(n, e, t) {
  return Ay(n, n, Qi, Kd(e, t, n.nodeType != 1));
}
function Gd(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function $g(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class oN {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = aN(e.node.content, e);
  }
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = fr, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let u = this.index; u < Math.min(this.index + 3, this.top.children.length); u++) {
        let d = this.top.children[u];
        if (d.matchesMark(e[s]) && !this.isLocked(d.dom)) {
          l = u;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let u = cs.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, u), this.top = u, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let l = this.index, u = Math.min(this.top.children.length, l + 5); l < u; l++) {
        let d = this.top.children[l];
        if (d.matchesNode(e, t, r) && !this.preMatch.matched.has(d)) {
          s = l;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == Or && o.dom == o.contentDOM && (o.dirty = zs), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  updateNextNode(e, t, r, i, s) {
    for (let o = this.index; o < this.top.children.length; o++) {
      let l = this.top.children[o];
      if (l instanceof ds) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != s)
          return !1;
        let d = l.dom;
        if (!(this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Or && Gd(t, l.outerDeco))) && l.update(e, t, r, i))
          return this.destroyBetween(this.index, o), l.dom != d && (this.changed = !0), this.index++, !0;
        break;
      }
    }
    return !1;
  }
  addNode(e, t, r, i, s) {
    this.top.children.splice(this.index++, 0, ds.create(this.top, e, t, r, i, s)), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new xy(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof cs; )
      t = e, e = t.children[t.children.length - 1];
    (!e || !(e instanceof Ou) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((sn || tn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new ky(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function aN(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e:
    for (; i > 0; ) {
      let l;
      for (; ; )
        if (r) {
          let d = t.children[r - 1];
          if (d instanceof cs)
            t = d, r = d.children.length;
          else {
            l = d, r--;
            break;
          }
        } else {
          if (t == e)
            break e;
          r = t.parent.children.indexOf(t), t = t.parent;
        }
      let u = l.node;
      if (u) {
        if (u != n.child(i - 1))
          break;
        --i, s.set(l, i), o.push(l);
      }
    }
  return { index: i, matched: s, matches: o.reverse() };
}
function lN(n, e) {
  return n.type.side - e.type.side;
}
function uN(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let d = 0; d < n.childCount; d++) {
      let f = n.child(d);
      r(f, i, e.forChild(s, f), d), s += f.nodeSize;
    }
    return;
  }
  let o = 0, l = [], u = null;
  for (let d = 0; ; ) {
    if (o < i.length && i[o].to == s) {
      let y = i[o++], b;
      for (; o < i.length && i[o].to == s; )
        (b || (b = [y])).push(i[o++]);
      if (b) {
        b.sort(lN);
        for (let w = 0; w < b.length; w++)
          t(b[w], d, !!u);
      } else
        t(y, d, !!u);
    }
    let f, h;
    if (u)
      h = -1, f = u, u = null;
    else if (d < n.childCount)
      h = d, f = n.child(d++);
    else
      break;
    for (let y = 0; y < l.length; y++)
      l[y].to <= s && l.splice(y--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      l.push(i[o++]);
    let m = s + f.nodeSize;
    if (f.isText) {
      let y = m;
      o < i.length && i[o].from < y && (y = i[o].from);
      for (let b = 0; b < l.length; b++)
        l[b].to < y && (y = l[b].to);
      y < m && (u = f.cut(y - s), f = f.cut(0, y - s), m = y, h = -1);
    }
    let g = f.isInline && !f.isLeaf ? l.filter((y) => !y.inline) : l.slice();
    r(f, g, e.forChild(s, f), h), s = m;
  }
}
function cN(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function dN(n, e) {
  for (; ; ) {
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.childNodes.length > e && n.childNodes[e].nodeType == 3)
        return n.childNodes[e];
      n = n.childNodes[e - 1], e = Sr(n);
    } else if (n.nodeType == 1 && e < n.childNodes.length)
      n = n.childNodes[e], e = 0;
    else
      return null;
  }
}
function fN(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), l = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let u = o.text;
    for (; i < n.childCount; ) {
      let d = n.child(i++);
      if (s += d.nodeSize, !d.isText)
        break;
      u += d.text;
    }
    if (s >= t) {
      let d = l < r ? u.lastIndexOf(e, r - l - 1) : -1;
      if (d >= 0 && d + e.length + l >= t)
        return l + d;
      if (t == r && u.length >= r + e.length - l && u.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Jd(n, e, t, r, i) {
  let s = [];
  for (let o = 0, l = 0; o < n.length; o++) {
    let u = n[o], d = l, f = l += u.size;
    d >= t || f <= e ? s.push(u) : (d < e && s.push(u.slice(0, e - d, r)), i && (s.push(i), i = void 0), f > t && s.push(u.slice(t - d, u.size, r)));
  }
  return s;
}
function Bf(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let l = r.resolve(o), u, d;
  if (Tu(t)) {
    for (u = l; i && !i.node; )
      i = i.parent;
    let f = i.node;
    if (i && f.isAtom && ve.isSelectable(f) && i.parent && !(f.isInline && $R(t.focusNode, t.focusOffset, i.dom))) {
      let h = i.posBefore;
      d = new ve(o == h ? l : r.resolve(h));
    }
  } else {
    let f = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (f < 0)
      return null;
    u = r.resolve(f);
  }
  if (!d) {
    let f = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1;
    d = $f(n, u, l, f);
  }
  return d;
}
function Ty(n) {
  return n.editable ? n.hasFocus() : Oy(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function Xr(n, e = !1) {
  let t = n.state.selection;
  if (My(n, t), !!Ty(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && tn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && us(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      hN(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      Lg && !(t instanceof we) && (t.$from.parent.inlineContent || (s = Pg(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = Pg(n, t.to))), n.docView.setSelection(r, i, n.root, e), Lg && (s && zg(s), o && zg(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && pN(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const Lg = sn || tn && zR < 63;
function Pg(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (sn && i && i.contentEditable == "false")
    return fd(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return fd(i);
    if (s)
      return fd(s);
  }
}
function fd(n) {
  return n.contentEditable = "true", sn && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function zg(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function pN(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!Ty(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function hN(n) {
  let e = n.domSelection(), t = document.createRange(), r = n.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? t.setEnd(r.parentNode, Sn(r) + 1) : t.setEnd(r, 0), t.collapse(!1), e.removeAllRanges(), e.addRange(t), !i && !n.state.selection.visible && vn && Di <= 11 && (r.disabled = !0, r.disabled = !1);
}
function My(n, e) {
  if (e instanceof ve) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (Vg(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    Vg(n);
}
function Vg(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function $f(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || we.between(e, t, r);
}
function Hg(n) {
  return n.editable && !n.hasFocus() ? !1 : Oy(n);
}
function Oy(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function mN(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return us(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Yd(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && _e.findFrom(s, e);
}
function Yi(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Wg(n, e, t) {
  let r = n.state.selection;
  if (r instanceof we) {
    if (!r.empty || t.indexOf("s") > -1)
      return !1;
    if (n.endOfTextblock(e > 0 ? "right" : "left")) {
      let i = Yd(n.state, e);
      return i && i instanceof ve ? Yi(n, i) : !1;
    } else if (!(Un && t.indexOf("m") > -1)) {
      let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
      if (!s || s.isText)
        return !1;
      let l = e < 0 ? i.pos - s.nodeSize : i.pos;
      return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? ve.isSelectable(s) ? Yi(n, new ve(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : Mu ? Yi(n, new we(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1;
    }
  } else {
    if (r instanceof ve && r.node.isInline)
      return Yi(n, new we(e > 0 ? r.$to : r.$from));
    {
      let i = Yd(n.state, e);
      return i ? Yi(n, i) : !1;
    }
  }
}
function Kl(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function ia(n) {
  let e = n.pmViewDesc;
  return e && e.size == 0 && (n.nextSibling || n.nodeName != "BR");
}
function pd(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (Mr && t.nodeType == 1 && r < Kl(t) && ia(t.childNodes[r]) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (ia(l))
          i = t, s = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (Fy(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && ia(l); )
          i = t.parentNode, s = Sn(l), l = l.previousSibling;
        if (l)
          t = l, r = Kl(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? Xd(n, t, r) : i && Xd(n, i, s);
}
function hd(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = Kl(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (ia(l))
        s = t, o = ++r;
      else
        break;
    } else {
      if (Fy(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && ia(l); )
          s = l.parentNode, o = Sn(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = Kl(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && Xd(n, s, o);
}
function Fy(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Xd(n, e, t) {
  let r = n.domSelection();
  if (Tu(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else
    r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && Xr(n);
  }, 50);
}
function Ug(n, e, t) {
  let r = n.state.selection;
  if (r instanceof we && !r.empty || t.indexOf("s") > -1 || Un && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Yd(n.state, e);
    if (o && o instanceof ve)
      return Yi(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, l = r instanceof dr ? _e.near(o, e) : _e.findFrom(o, e);
    return l ? Yi(n, l) : !1;
  }
  return !1;
}
function jg(n, e) {
  if (!(n.state.selection instanceof we))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function qg(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function gN(n) {
  if (!sn || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    qg(n, r, "true"), setTimeout(() => qg(n, r, "false"), 20);
  }
  return !1;
}
function vN(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function yN(n, e) {
  let t = e.keyCode, r = vN(e);
  return t == 8 || Un && t == 72 && r == "c" ? jg(n, -1) || pd(n) : t == 46 || Un && t == 68 && r == "c" ? jg(n, 1) || hd(n) : t == 13 || t == 27 ? !0 : t == 37 || Un && t == 66 && r == "c" ? Wg(n, -1, r) || pd(n) : t == 39 || Un && t == 70 && r == "c" ? Wg(n, 1, r) || hd(n) : t == 38 || Un && t == 80 && r == "c" ? Ug(n, -1, r) || pd(n) : t == 40 || Un && t == 78 && r == "c" ? gN(n) || Ug(n, 1, r) || hd(n) : r == (Un ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90);
}
function Iy(n, e) {
  n.someProp("transformCopied", (g) => {
    e = g(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let g = r.firstChild;
    t.push(g.type.name, g.attrs != g.type.defaultAttrs ? g.attrs : null), r = g.content;
  }
  let o = n.someProp("clipboardSerializer") || Ar.fromSchema(n.state.schema), l = Py(), u = l.createElement("div");
  u.appendChild(o.serializeFragment(r, { document: l }));
  let d = u.firstChild, f, h = 0;
  for (; d && d.nodeType == 1 && (f = Ly[d.nodeName.toLowerCase()]); ) {
    for (let g = f.length - 1; g >= 0; g--) {
      let y = l.createElement(f[g]);
      for (; u.firstChild; )
        y.appendChild(u.firstChild);
      u.appendChild(y), h++;
    }
    d = u.firstChild;
  }
  d && d.nodeType == 1 && d.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let m = n.someProp("clipboardTextSerializer", (g) => g(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: u, text: m };
}
function Ry(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l;
  if (!t && !e)
    return null;
  let u = e && (r || s || !t);
  if (u) {
    if (n.someProp("transformPastedText", (m) => {
      e = m(e, s || r, n);
    }), s)
      return e ? new Z(U.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Z.empty;
    let h = n.someProp("clipboardTextParser", (m) => m(e, i, r, n));
    if (h)
      l = h;
    else {
      let m = i.marks(), { schema: g } = n.state, y = Ar.fromSchema(g);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((b) => {
        let w = o.appendChild(document.createElement("p"));
        b && w.appendChild(y.serializeNode(g.text(b, m)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = wN(t), Mu && DN(o);
  let d = o && o.querySelector("[data-pm-slice]"), f = d && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(d.getAttribute("data-pm-slice") || "");
  if (f && f[3])
    for (let h = +f[3]; h > 0; h--) {
      let m = o.firstChild;
      for (; m && m.nodeType != 1; )
        m = m.nextSibling;
      if (!m)
        break;
      o = m;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || so.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(u || f),
    context: i,
    ruleFromNode(m) {
      return m.nodeName == "BR" && !m.nextSibling && m.parentNode && !bN.test(m.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), f)
    l = CN(Kg(l, +f[1], +f[2]), f[4]);
  else if (l = Z.maxOpen(_N(l.content, i), !0), l.openStart || l.openEnd) {
    let h = 0, m = 0;
    for (let g = l.content.firstChild; h < l.openStart && !g.type.spec.isolating; h++, g = g.firstChild)
      ;
    for (let g = l.content.lastChild; m < l.openEnd && !g.type.spec.isolating; m++, g = g.lastChild)
      ;
    l = Kg(l, h, m);
  }
  return n.someProp("transformPasted", (h) => {
    l = h(l, n);
  }), l;
}
const bN = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function _N(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((l) => {
      if (!o)
        return;
      let u = i.findWrapping(l.type), d;
      if (!u)
        return o = null;
      if (d = o.length && s.length && By(u, s, l, o[o.length - 1], 0))
        o[o.length - 1] = d;
      else {
        o.length && (o[o.length - 1] = $y(o[o.length - 1], s.length));
        let f = Ny(l, u);
        o.push(f), i = i.matchType(f.type), s = u;
      }
    }), o)
      return U.from(o);
  }
  return n;
}
function Ny(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, U.from(n));
  return n;
}
function By(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = By(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(U.from(Ny(t, n, i + 1))));
  }
}
function $y(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, $y(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(U.empty, !0);
  return n.copy(t.append(r));
}
function Zd(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, l = o.content;
  return i < r - 1 && (l = Zd(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, n.childCount > 1 || s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(U.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l));
}
function Kg(n, e, t) {
  return e < n.openStart && (n = new Z(Zd(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new Z(Zd(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const Ly = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Gg = null;
function Py() {
  return Gg || (Gg = document.implementation.createHTMLDocument("title"));
}
function wN(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = Py().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && Ly[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = n, i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function DN(n) {
  let e = n.querySelectorAll(tn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function CN(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let u = t.nodes[r[l]];
    if (!u || u.hasRequiredAttrs())
      break;
    i = U.from(u.create(r[l + 1], i)), s++, o++;
  }
  return new Z(i, s, o);
}
const on = {}, an = {}, xN = { touchstart: !0, touchmove: !0 };
class kN {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function SN(n) {
  for (let e in on) {
    let t = on[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      EN(n, r) && !Lf(n, r) && (n.editable || !(r.type in an)) && t(n, r);
    }, xN[e] ? { passive: !0 } : void 0);
  }
  sn && n.dom.addEventListener("input", () => null), Qd(n);
}
function wi(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function AN(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Qd(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => Lf(n, r));
  });
}
function Lf(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function EN(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function TN(n, e) {
  !Lf(n, e) && on[e.type] && (n.editable || !(e.type in an)) && on[e.type](n, e);
}
an.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !Vy(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(lr && tn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), lo && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Ji(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else
      n.someProp("handleKeyDown", (r) => r(n, t)) || yN(n, t) ? t.preventDefault() : wi(n, "key");
};
an.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
an.keypress = (n, e) => {
  let t = e;
  if (Vy(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Un && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof we) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode);
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (s) => s(n, r.$from.pos, r.$to.pos, i)) && n.dispatch(n.state.tr.insertText(i).scrollIntoView()), t.preventDefault();
  }
};
function Fu(n) {
  return { left: n.clientX, top: n.clientY };
}
function MN(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function Pf(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (l) => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function Qs(n, e, t) {
  n.focused || n.focus();
  let r = n.state.tr.setSelection(e);
  t == "pointer" && r.setMeta("pointer", !0), n.dispatch(r);
}
function ON(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && ve.isSelectable(r) ? (Qs(n, new ve(t), "pointer"), !0) : !1;
}
function FN(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof ve && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let l = o > s.depth ? s.nodeAfter : s.node(o);
    if (ve.isSelectable(l)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (Qs(n, ve.create(n.state.doc, i), "pointer"), !0) : !1;
}
function IN(n, e, t, r, i) {
  return Pf(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? FN(n, t) : ON(n, t));
}
function RN(n, e, t, r) {
  return Pf(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function NN(n, e, t, r) {
  return Pf(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || BN(n, t, r);
}
function BN(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (Qs(n, we.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s);
    if (o.inlineContent)
      Qs(n, we.create(r, l + 1, l + 1 + o.content.size), "pointer");
    else if (ve.isSelectable(o))
      Qs(n, ve.create(r, l), "pointer");
    else
      continue;
    return !0;
  }
}
function zf(n) {
  return Gl(n);
}
const zy = Un ? "metaKey" : "ctrlKey";
on.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = zf(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && MN(t, n.input.lastClick) && !t[zy] && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s };
  let o = n.posAtCoords(Fu(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new $N(n, o, t, !!r)) : (s == "doubleClick" ? RN : NN)(n, o.pos, o.inside, t) ? t.preventDefault() : wi(n, "pointer"));
};
class $N {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[zy], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let f = e.state.doc.resolve(t.pos);
      s = f.parent, o = f.depth ? f.before() : 0;
    }
    const l = i ? null : r.target, u = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = u ? u.dom : null;
    let { selection: d } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || d instanceof ve && d.from <= o && d.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Mr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), wi(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Xr(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Fu(e))), this.updateAllowDefault(e), this.allowDefault || !t ? wi(this.view, "pointer") : IN(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || sn && this.mightDrag && !this.mightDrag.node.isAtom || tn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Qs(this.view, _e.near(this.view.state.doc.resolve(t.pos)), "pointer"), e.preventDefault()) : wi(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), wi(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
on.touchstart = (n) => {
  n.input.lastTouch = Date.now(), zf(n), wi(n, "pointer");
};
on.touchmove = (n) => {
  n.input.lastTouch = Date.now(), wi(n, "pointer");
};
on.contextmenu = (n) => zf(n);
function Vy(n, e) {
  return n.composing ? !0 : sn && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const LN = lr ? 5e3 : -1;
an.compositionstart = an.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), Gl(n, !0), n.markCursor = null;
    else if (Gl(n), Mr && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          n.domSelection().collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  Hy(n, LN);
};
an.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, Hy(n, 20));
};
function Hy(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => Gl(n), e));
}
function Wy(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = PN()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function PN() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function Gl(n, e = !1) {
  if (!(lr && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), Wy(n), e || n.docView && n.docView.dirty) {
      let t = Bf(n);
      return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function zN(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const uo = vn && Di < 15 || lo && VR < 604;
on.copy = an.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = uo ? null : t.clipboardData, o = r.content(), { dom: l, text: u } = Iy(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", u)) : zN(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function VN(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function HN(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? ha(n, r.value, null, n.input.shiftKey, e) : ha(n, r.textContent, r.innerHTML, n.input.shiftKey, e);
  }, 50);
}
function ha(n, e, t, r, i) {
  let s = Ry(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (u) => u(n, i, s || Z.empty)))
    return !0;
  if (!s)
    return !1;
  let o = VN(s), l = o ? n.state.tr.replaceSelectionWith(o, n.input.shiftKey) : n.state.tr.replaceSelection(s);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
an.paste = (n, e) => {
  let t = e;
  if (n.composing && !lr)
    return;
  let r = uo ? null : t.clipboardData;
  r && ha(n, r.getData("text/plain"), r.getData("text/html"), n.input.shiftKey, t) ? t.preventDefault() : HN(n, t);
};
class WN {
  constructor(e, t) {
    this.slice = e, this.move = t;
  }
}
const Uy = Un ? "altKey" : "ctrlKey";
on.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(Fu(t));
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ve ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      n.dispatch(n.state.tr.setSelection(ve.create(n.state.doc, r.mightDrag.pos)));
    else if (t.target && t.target.nodeType == 1) {
      let d = n.docView.nearestDesc(t.target, !0);
      d && d.node.type.spec.draggable && d != n.docView && n.dispatch(n.state.tr.setSelection(ve.create(n.state.doc, d.posBefore)));
    }
  }
  let o = n.state.selection.content(), { dom: l, text: u } = Iy(n, o);
  t.dataTransfer.clearData(), t.dataTransfer.setData(uo ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", uo || t.dataTransfer.setData("text/plain", u), n.dragging = new WN(o, !t[Uy]);
};
on.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
an.dragover = an.dragenter = (n, e) => e.preventDefault();
an.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(Fu(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (y) => {
    o = y(o, n);
  }) : o = Ry(n, t.dataTransfer.getData(uo ? "Text" : "text/plain"), uo ? null : t.dataTransfer.getData("text/html"), !1, s);
  let l = !!(r && !t[Uy]);
  if (n.someProp("handleDrop", (y) => y(n, t, o || Z.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let u = o ? uy(n.state.doc, s.pos, o) : s.pos;
  u == null && (u = s.pos);
  let d = n.state.tr;
  l && d.deleteSelection();
  let f = d.mapping.map(u), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, m = d.doc;
  if (h ? d.replaceRangeWith(f, f, o.content.firstChild) : d.replaceRange(f, f, o), d.doc.eq(m))
    return;
  let g = d.doc.resolve(f);
  if (h && ve.isSelectable(o.content.firstChild) && g.nodeAfter && g.nodeAfter.sameMarkup(o.content.firstChild))
    d.setSelection(new ve(g));
  else {
    let y = d.mapping.map(u);
    d.mapping.maps[d.mapping.maps.length - 1].forEach((b, w, T, k) => y = k), d.setSelection($f(n, g, d.doc.resolve(y)));
  }
  n.focus(), n.dispatch(d.setMeta("uiEvent", "drop"));
};
on.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && Xr(n);
  }, 20));
};
on.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
on.beforeinput = (n, e) => {
  if (tn && lr && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Ji(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in an)
  on[n] = an[n];
function ma(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Vf {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || rs, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new hn(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Vf && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && ma(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Ci {
  constructor(e, t) {
    this.attrs = e, this.spec = t || rs;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new hn(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Ci && ma(this.attrs, e.attrs) && ma(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ci;
  }
  destroy() {
  }
}
class Hf {
  constructor(e, t) {
    this.attrs = e, this.spec = t || rs;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new hn(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof Hf && ma(this.attrs, e.attrs) && ma(this.spec, e.spec);
  }
  destroy() {
  }
}
class hn {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  copy(e, t) {
    return new hn(e, t, this.type);
  }
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  static widget(e, t, r) {
    return new hn(e, e, new Vf(t, r));
  }
  static inline(e, t, r, i) {
    return new hn(e, t, new Ci(r, i));
  }
  static node(e, t, r, i) {
    return new hn(e, t, new Hf(r, i));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof Ci;
  }
}
const $s = [], rs = {};
class ct {
  constructor(e, t) {
    this.local = e.length ? e : $s, this.children = t.length ? t : $s;
  }
  static create(e, t) {
    return t.length ? Jl(t, e, 0, rs) : Ut;
  }
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let l = this.local[o];
      l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let l = this.children[o] + 1;
        this.children[o + 2].findInner(e - l, t - l, r, i + l, s);
      }
  }
  map(e, t, r) {
    return this == Ut || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || rs);
  }
  mapInner(e, t, r, i, s) {
    let o;
    for (let l = 0; l < this.local.length; l++) {
      let u = this.local[l].map(e, r, i);
      u && u.type.valid(t, u) ? (o || (o = [])).push(u) : s.onRemove && s.onRemove(this.local[l].spec);
    }
    return this.children.length ? UN(this.children, o || [], e, t, r, i, s) : o ? new ct(o.sort(is), $s) : Ut;
  }
  add(e, t) {
    return t.length ? this == Ut ? ct.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((l, u) => {
      let d = u + r, f;
      if (f = qy(t, l, d)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < u; )
          s += 3;
        i[s] == u ? i[s + 2] = i[s + 2].addInner(l, f, d + 1) : i.splice(s, 0, u, u + l.nodeSize, Jl(f, l, d + 1, rs)), s += 3;
      }
    });
    let o = jy(s ? Ky(t) : t, -r);
    for (let l = 0; l < o.length; l++)
      o[l].type.valid(e, o[l]) || o.splice(l--, 1);
    return new ct(o.length ? this.local.concat(o).sort(is) : this.local, i || this.children);
  }
  remove(e) {
    return e.length == 0 || this == Ut ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, l = r[s] + t, u = r[s + 1] + t;
      for (let f = 0, h; f < e.length; f++)
        (h = e[f]) && h.from > l && h.to < u && (e[f] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let d = r[s + 2].removeInner(o, l + 1);
      d != Ut ? r[s + 2] = d : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let l = 0; l < i.length; l++)
            i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new ct(i, r) : Ut;
  }
  forChild(e, t) {
    if (this == Ut)
      return this;
    if (t.isLeaf)
      return ct.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let u = this.local[l];
      if (u.from < o && u.to > s && u.type instanceof Ci) {
        let d = Math.max(s, u.from) - s, f = Math.min(o, u.to) - s;
        d < f && (i || (i = [])).push(u.copy(d, f));
      }
    }
    if (i) {
      let l = new ct(i.sort(is), $s);
      return r ? new gi([l, r]) : l;
    }
    return r || Ut;
  }
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof ct) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  locals(e) {
    return Wf(this.localsInner(e));
  }
  localsInner(e) {
    if (this == Ut)
      return $s;
    if (e.inlineContent || !this.local.some(Ci.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Ci || t.push(this.local[r]);
    return t;
  }
}
ct.empty = new ct([], []);
ct.removeOverlap = Wf;
const Ut = ct.empty;
class gi {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, rs));
    return gi.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return ct.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != Ut && (s instanceof gi ? r = r.concat(s.members) : r.push(s));
    }
    return gi.from(r);
  }
  eq(e) {
    if (!(e instanceof gi) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? Wf(r ? t : t.sort(is)) : $s;
  }
  static from(e) {
    switch (e.length) {
      case 0:
        return Ut;
      case 1:
        return e[0];
      default:
        return new gi(e.every((t) => t instanceof ct) ? e : e.reduce((t, r) => t.concat(r instanceof ct ? r : r.members), []));
    }
  }
}
function UN(n, e, t, r, i, s, o) {
  let l = n.slice();
  for (let d = 0, f = s; d < t.maps.length; d++) {
    let h = 0;
    t.maps[d].forEach((m, g, y, b) => {
      let w = b - y - (g - m);
      for (let T = 0; T < l.length; T += 3) {
        let k = l[T + 1];
        if (k < 0 || m > k + f - h)
          continue;
        let S = l[T] + f - h;
        g >= S ? l[T + 1] = m <= S ? -2 : -1 : y >= i && w && (l[T] += w, l[T + 1] += w);
      }
      h += w;
    }), f = t.maps[d].map(f, -1);
  }
  let u = !1;
  for (let d = 0; d < l.length; d += 3)
    if (l[d + 1] < 0) {
      if (l[d + 1] == -2) {
        u = !0, l[d + 1] = -1;
        continue;
      }
      let f = t.map(n[d] + s), h = f - i;
      if (h < 0 || h >= r.content.size) {
        u = !0;
        continue;
      }
      let m = t.map(n[d + 1] + s, -1), g = m - i, { index: y, offset: b } = r.content.findIndex(h), w = r.maybeChild(y);
      if (w && b == h && b + w.nodeSize == g) {
        let T = l[d + 2].mapInner(t, w, f + 1, n[d] + s + 1, o);
        T != Ut ? (l[d] = h, l[d + 1] = g, l[d + 2] = T) : (l[d + 1] = -2, u = !0);
      } else
        u = !0;
    }
  if (u) {
    let d = jN(l, n, e, t, i, s, o), f = Jl(d, r, 0, o);
    e = f.local;
    for (let h = 0; h < l.length; h += 3)
      l[h + 1] < 0 && (l.splice(h, 3), h -= 3);
    for (let h = 0, m = 0; h < f.children.length; h += 3) {
      let g = f.children[h];
      for (; m < l.length && l[m] < g; )
        m += 3;
      l.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
    }
  }
  return new ct(e.sort(is), l);
}
function jy(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new hn(i.from + e, i.to + e, i.type));
  }
  return t;
}
function jN(n, e, t, r, i, s, o) {
  function l(u, d) {
    for (let f = 0; f < u.local.length; f++) {
      let h = u.local[f].map(r, i, d);
      h ? t.push(h) : o.onRemove && o.onRemove(u.local[f].spec);
    }
    for (let f = 0; f < u.children.length; f += 3)
      l(u.children[f + 2], u.children[f] + d + 1);
  }
  for (let u = 0; u < n.length; u += 3)
    n[u + 1] == -1 && l(n[u + 2], e[u] + s + 1);
  return t;
}
function qy(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function Ky(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function Jl(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((l, u) => {
    let d = qy(n, l, u + t);
    if (d) {
      s = !0;
      let f = Jl(d, l, t + u + 1, r);
      f != Ut && i.push(u, u + l.nodeSize, f);
    }
  });
  let o = jy(s ? Ky(n) : n, -t).sort(is);
  for (let l = 0; l < o.length; l++)
    o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1));
  return o.length || i.length ? new ct(o, i) : Ut;
}
function is(n, e) {
  return n.from - e.from || n.to - e.to;
}
function Wf(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), Jg(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), Jg(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Jg(n, e, t) {
  for (; e < n.length && is(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function md(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != Ut && e.push(r);
  }), n.cursorWrapper && e.push(ct.create(n.state.doc, [n.cursorWrapper.deco])), gi.from(e);
}
const qN = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, KN = vn && Di <= 11;
class GN {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class JN {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new GN(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      vn && Di <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), KN && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, qN)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Hg(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Xr(this.view);
      if (vn && Di <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && us(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = pa(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = pa(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.observer ? this.observer.takeRecords() : [];
    this.queue.length && (t = this.queue.concat(t), this.queue.length = 0);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Hg(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, u = [];
    if (e.editable)
      for (let f = 0; f < t.length; f++) {
        let h = this.registerMutation(t[f], u);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (l = !0));
      }
    if (Mr && u.length > 1) {
      let f = u.filter((h) => h.nodeName == "BR");
      if (f.length == 2) {
        let h = f[0], m = f[1];
        h.parentNode && h.parentNode.parentNode == m.parentNode ? m.remove() : h.remove();
      }
    }
    let d = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Tu(r) && (d = Bf(e)) && d.eq(_e.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Xr(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), YN(e)), this.handleDOMChange(s, o, l, u), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Xr(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let f = 0; f < e.addedNodes.length; f++)
        t.push(e.addedNodes[f]);
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (vn && Di <= 11 && e.addedNodes.length)
        for (let f = 0; f < e.addedNodes.length; f++) {
          let { previousSibling: h, nextSibling: m } = e.addedNodes[f];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!m || Array.prototype.indexOf.call(e.addedNodes, m) < 0) && (s = m);
        }
      let o = i && i.parentNode == e.target ? Sn(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), u = s && s.parentNode == e.target ? Sn(s) : e.target.childNodes.length, d = r.localPosFromDOM(e.target, u, 1);
      return { from: l, to: d };
    } else
      return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : {
        from: r.posAtStart,
        to: r.posAtEnd,
        typeOver: e.target.nodeValue == e.oldValue
      };
  }
}
let Yg = /* @__PURE__ */ new WeakMap(), Xg = !1;
function YN(n) {
  if (!Yg.has(n) && (Yg.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Mr, Xg)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Xg = !0;
  }
}
function XN(n) {
  let e;
  function t(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  n.dom.addEventListener("beforeinput", t, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", t, !0);
  let r = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, l = n.domAtPos(n.state.selection.anchor);
  return us(l.node, l.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };
}
function ZN(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), u = n.domSelectionRange(), d, f = u.anchorNode;
  if (f && n.dom.contains(f.nodeType == 1 ? f : f.parentNode) && (d = [{ node: f, offset: u.anchorOffset }], Tu(u) || d.push({ node: u.focusNode, offset: u.focusOffset })), tn && n.input.lastKeyCode === 8)
    for (let w = s; w > i; w--) {
      let T = r.childNodes[w - 1], k = T.pmViewDesc;
      if (T.nodeName == "BR" && !k) {
        s = w;
        break;
      }
      if (!k || k.size)
        break;
    }
  let h = n.state.doc, m = n.someProp("domParser") || so.fromSchema(n.state.schema), g = h.resolve(o), y = null, b = m.parse(r, {
    topNode: g.parent,
    topMatch: g.parent.contentMatchAt(g.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: g.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: d,
    ruleFromNode: QN,
    context: g
  });
  if (d && d[0].pos != null) {
    let w = d[0].pos, T = d[1] && d[1].pos;
    T == null && (T = w), y = { anchor: w + o, head: T + o };
  }
  return { doc: b, sel: y, from: o, to: l };
}
function QN(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (sn && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || sn && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
function eB(n, e, t, r, i) {
  if (e < 0) {
    let L = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, q = Bf(n, L);
    if (q && !n.state.selection.eq(q)) {
      if (tn && lr && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (ae) => ae(n, Ji(13, "Enter"))))
        return;
      let oe = n.state.tr.setSelection(q);
      L == "pointer" ? oe.setMeta("pointer", !0) : L == "key" && oe.scrollIntoView(), n.dispatch(oe);
    }
    return;
  }
  let s = n.state.doc.resolve(e), o = s.sharedDepth(t);
  e = s.before(o + 1), t = n.state.doc.resolve(t).after(o + 1);
  let l = n.state.selection, u = ZN(n, e, t), d = n.state.doc, f = d.slice(u.from, u.to), h, m;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (h = n.state.selection.to, m = "end") : (h = n.state.selection.from, m = "start"), n.input.lastKeyCode = null;
  let g = rB(f.content, u.doc.content, u.from, h, m);
  if ((lo && n.input.lastIOSEnter > Date.now() - 225 || lr) && i.some((L) => L.nodeName == "DIV" || L.nodeName == "P" || L.nodeName == "LI") && (!g || g.endA >= g.endB) && n.someProp("handleKeyDown", (L) => L(n, Ji(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!g)
    if (r && l instanceof we && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(u.sel && u.sel.anchor != u.sel.head))
      g = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let L = Zg(n, n.state.doc, u.sel);
        L && !L.eq(n.state.selection) && n.dispatch(n.state.tr.setSelection(L));
      }
      return;
    }
  if (tn && n.cursorWrapper && u.sel && u.sel.anchor == n.cursorWrapper.deco.from && u.sel.head == u.sel.anchor) {
    let L = g.endB - g.start;
    u.sel = { anchor: u.sel.anchor + L, head: u.sel.anchor + L };
  }
  n.input.domChangeCount++, n.state.selection.from < n.state.selection.to && g.start == g.endB && n.state.selection instanceof we && (g.start > n.state.selection.from && g.start <= n.state.selection.from + 2 && n.state.selection.from >= u.from ? g.start = n.state.selection.from : g.endA < n.state.selection.to && g.endA >= n.state.selection.to - 2 && n.state.selection.to <= u.to && (g.endB += n.state.selection.to - g.endA, g.endA = n.state.selection.to)), vn && Di <= 11 && g.endB == g.start + 1 && g.endA == g.start && g.start > u.from && u.doc.textBetween(g.start - u.from - 1, g.start - u.from + 1) == " " && (g.start--, g.endA--, g.endB--);
  let y = u.doc.resolveNoCache(g.start - u.from), b = u.doc.resolveNoCache(g.endB - u.from), w = d.resolve(g.start), T = y.sameParent(b) && y.parent.inlineContent && w.end() >= g.endA, k;
  if ((lo && n.input.lastIOSEnter > Date.now() - 225 && (!T || i.some((L) => L.nodeName == "DIV" || L.nodeName == "P")) || !T && y.pos < u.doc.content.size && (k = _e.findFrom(u.doc.resolve(y.pos + 1), 1, !0)) && k.head == b.pos) && n.someProp("handleKeyDown", (L) => L(n, Ji(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > g.start && nB(d, g.start, g.endA, y, b) && n.someProp("handleKeyDown", (L) => L(n, Ji(8, "Backspace")))) {
    lr && tn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  tn && lr && g.endB == g.start && (n.input.lastAndroidDelete = Date.now()), lr && !T && y.start() != b.start() && b.parentOffset == 0 && y.depth == b.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == g.endA && (g.endB -= 2, b = u.doc.resolveNoCache(g.endB - u.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(L) {
      return L(n, Ji(13, "Enter"));
    });
  }, 20));
  let S = g.start, C = g.endA, R, I, P;
  if (T) {
    if (y.pos == b.pos)
      vn && Di <= 11 && y.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => Xr(n), 20)), R = n.state.tr.delete(S, C), I = d.resolve(g.start).marksAcross(d.resolve(g.endA));
    else if (g.endA == g.endB && (P = tB(y.parent.content.cut(y.parentOffset, b.parentOffset), w.parent.content.cut(w.parentOffset, g.endA - w.start()))))
      R = n.state.tr, P.type == "add" ? R.addMark(S, C, P.mark) : R.removeMark(S, C, P.mark);
    else if (y.parent.child(y.index()).isText && y.index() == b.index() - (b.textOffset ? 0 : 1)) {
      let L = y.parent.textBetween(y.parentOffset, b.parentOffset);
      if (n.someProp("handleTextInput", (q) => q(n, S, C, L)))
        return;
      R = n.state.tr.insertText(L, S, C);
    }
  }
  if (R || (R = n.state.tr.replace(S, C, u.doc.slice(g.start - u.from, g.endB - u.from))), u.sel) {
    let L = Zg(n, R.doc, u.sel);
    L && !(tn && lr && n.composing && L.empty && (g.start != g.endB || n.input.lastAndroidDelete < Date.now() - 100) && (L.head == S || L.head == R.mapping.map(C) - 1) || vn && L.empty && L.head == S) && R.setSelection(L);
  }
  I && R.ensureMarks(I), n.dispatch(R.scrollIntoView());
}
function Zg(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : $f(n, e.resolve(t.anchor), e.resolve(t.head));
}
function tB(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, u;
  for (let f = 0; f < r.length; f++)
    i = r[f].removeFromSet(i);
  for (let f = 0; f < t.length; f++)
    s = t[f].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    l = i[0], o = "add", u = (f) => f.mark(l.addToSet(f.marks));
  else if (i.length == 0 && s.length == 1)
    l = s[0], o = "remove", u = (f) => f.mark(l.removeFromSet(f.marks));
  else
    return null;
  let d = [];
  for (let f = 0; f < e.childCount; f++)
    d.push(u(e.child(f)));
  if (U.from(d).eq(n))
    return { mark: l, type: o };
}
function nB(n, e, t, r, i) {
  if (!r.parent.isTextblock || t - e <= i.pos - r.pos || gd(r, !0, !1) < i.pos)
    return !1;
  let s = n.resolve(e);
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(gd(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || gd(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function gd(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function rB(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let u = Math.max(0, s - Math.min(o, l));
    r -= o + u - s;
  }
  if (o < s && n.size < e.size) {
    let u = r <= s && r >= o ? s - r : 0;
    s -= u, l = s + (l - o), o = s;
  } else if (l < s) {
    let u = r <= s && r >= l ? s - r : 0;
    s -= u, o = s + (o - l), l = s;
  }
  return { start: s, endA: o, endB: l };
}
class iB {
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new kN(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(rv), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = tv(this), ev(this), this.nodeViews = nv(this), this.docView = Bg(this.state.doc, Qg(this), md(this), this.dom, this), this.domObserver = new JN(this, (r, i, s, o) => eB(this, r, i, s, o)), this.domObserver.start(), SN(this), this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Qd(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(rv), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    let r = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (Wy(this), s = !0), this.state = e;
    let o = r.plugins != e.plugins || this._props.plugins != t.plugins;
    if (o || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let m = nv(this);
      oB(m, this.nodeViews) && (this.nodeViews = m, i = !0);
    }
    (o || t.handleDOMEvents != this._props.handleDOMEvents) && Qd(this), this.editable = tv(this), ev(this);
    let l = md(this), u = Qg(this), d = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", f = i || !this.docView.matchesNode(e.doc, u, l);
    (f || !e.selection.eq(r.selection)) && (s = !0);
    let h = d == "preserve" && s && this.dom.style.overflowAnchor == null && UR(this);
    if (s) {
      this.domObserver.stop();
      let m = f && (vn || tn) && !this.composing && !r.selection.empty && !e.selection.empty && sB(r.selection, e.selection);
      if (f) {
        let g = tn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (i || !this.docView.update(e.doc, u, l, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = Bg(e.doc, u, l, this.dom, this)), g && !this.trackWrites && (m = !0);
      }
      m || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && mN(this)) ? Xr(this, m) : (My(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : h && jR(h);
  }
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (t) => t(this)))
      if (this.state.selection instanceof ve) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && Og(this, t.getBoundingClientRect(), e);
      } else
        Og(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let l = this.directPlugins[o].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let l = s[o].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  hasFocus() {
    if (vn) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop(), this.editable && qR(this.dom), Xr(this), this.domObserver.start();
  }
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  posAtCoords(e) {
    return XR(this, e);
  }
  coordsAtPos(e, t = 1) {
    return Dy(this, e, t);
  }
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  endOfTextblock(e, t) {
    return nN(this, t || this.state, e);
  }
  pasteHTML(e, t) {
    return ha(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  pasteText(e, t) {
    return ha(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  destroy() {
    this.docView && (AN(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], md(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(e) {
    return TN(this, e);
  }
  dispatch(e) {
    let t = this._props.dispatchTransaction;
    t ? t.call(this, e) : this.updateState(this.state.apply(e));
  }
  domSelectionRange() {
    return sn && this.root.nodeType === 11 && PR(this.dom.ownerDocument) == this.dom ? XN(this) : this.domSelection();
  }
  domSelection() {
    return this.root.getSelection();
  }
}
function Qg(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), e.translate = "no", n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" && (e.class += " " + t[r]), r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), [hn.node(0, n.state.doc.content.size, e)];
}
function ev(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: hn.widget(n.state.selection.head, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function tv(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function sB(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function nv(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function oB(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function rv(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ai = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Yl = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, iv = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), aB = typeof navigator < "u" && /Mac/.test(navigator.platform), lB = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), uB = aB || iv && +iv[1] < 57;
for (var Nt = 0; Nt < 10; Nt++)
  Ai[48 + Nt] = Ai[96 + Nt] = String(Nt);
for (var Nt = 1; Nt <= 24; Nt++)
  Ai[Nt + 111] = "F" + Nt;
for (var Nt = 65; Nt <= 90; Nt++)
  Ai[Nt] = String.fromCharCode(Nt + 32), Yl[Nt] = String.fromCharCode(Nt);
for (var vd in Ai)
  Yl.hasOwnProperty(vd) || (Yl[vd] = Ai[vd]);
function cB(n) {
  var e = uB && (n.ctrlKey || n.altKey || n.metaKey) || lB && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Yl : Ai)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const dB = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function fB(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l++) {
    let u = e[l];
    if (/^(cmd|meta|m)$/i.test(u))
      o = !0;
    else if (/^a(lt)?$/i.test(u))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      i = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      dB ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function pB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[fB(t)] = n[t];
  return e;
}
function yd(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
function hB(n) {
  return new kt({ props: { handleKeyDown: Uf(n) } });
}
function Uf(n) {
  let e = pB(n);
  return function(t, r) {
    let i = cB(r), s = i.length == 1 && i != " ", o, l = e[yd(i, r, !s)];
    if (l && l(t.state, t.dispatch, t))
      return !0;
    if (s && (r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = Ai[r.keyCode]) && o != i) {
      let u = e[yd(o, r, !0)];
      if (u && u(t.state, t.dispatch, t))
        return !0;
    } else if (s && r.shiftKey) {
      let u = e[yd(i, r, !0)];
      if (u && u(t.state, t.dispatch, t))
        return !0;
    }
    return !1;
  };
}
const mB = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function gB(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const vB = (n, e, t) => {
  let r = gB(n, t);
  if (!r)
    return !1;
  let i = Gy(r);
  if (!i) {
    let o = r.blockRange(), l = o && go(o);
    return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (!s.type.spec.isolating && Xy(n, i, e))
    return !0;
  if (r.parent.content.size == 0 && (co(s, "end") || ve.isSelectable(s))) {
    let o = Ff(n.doc, r.before(), r.after(), Z.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(co(s, "end") ? _e.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : ve.create(l.doc, i.pos - s.nodeSize)), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
};
function co(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const yB = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = Gy(r);
  }
  let o = s && s.nodeBefore;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ve.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function Gy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function bB(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const _B = (n, e, t) => {
  let r = bB(n, t);
  if (!r)
    return !1;
  let i = Jy(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (Xy(n, i, e))
    return !0;
  if (r.parent.content.size == 0 && (co(s, "start") || ve.isSelectable(s))) {
    let o = Ff(n.doc, r.before(), r.after(), Z.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(co(s, "start") ? _e.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : ve.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, wB = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = Jy(r);
  }
  let o = s && s.nodeAfter;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ve.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function Jy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const DB = (n, e) => {
  let t = n.selection, r = t instanceof ve, i;
  if (r) {
    if (t.node.isTextblock || !Mi(n.doc, t.from))
      return !1;
    i = t.from;
  } else if (i = ly(n.doc, t.from, -1), i == null)
    return !1;
  if (e) {
    let s = n.tr.join(i);
    r && s.setSelection(ve.create(s.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, CB = (n, e) => {
  let t = n.selection, r;
  if (t instanceof ve) {
    if (t.node.isTextblock || !Mi(n.doc, t.to))
      return !1;
    r = t.to;
  } else if (r = ly(n.doc, t.to, 1), r == null)
    return !1;
  return e && e(n.tr.join(r).scrollIntoView()), !0;
}, xB = (n, e) => {
  let { $from: t, $to: r } = n.selection, i = t.blockRange(r), s = i && go(i);
  return s == null ? !1 : (e && e(n.tr.lift(i, s).scrollIntoView()), !0);
}, kB = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function Yy(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const SB = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = Yy(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let l = t.after(), u = n.tr.replaceWith(l, l, o.createAndFill());
    u.setSelection(_e.near(u.doc.resolve(l), 1)), e(u.scrollIntoView());
  }
  return !0;
}, AB = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof dr || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = Yy(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill());
    l.setSelection(we.create(l.doc, o + 1)), e(l.scrollIntoView());
  }
  return !0;
}, EB = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (Xs(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && go(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
}, TB = (n, e) => {
  let { $from: t, to: r } = n.selection, i, s = t.sharedDepth(r);
  return s == 0 ? !1 : (i = t.before(s), e && e(n.tr.setSelection(ve.create(n.doc, i))), !0);
};
function MB(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Mi(n.doc, e.pos)) ? !1 : (t && t(n.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()), !0);
}
function Xy(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s, o;
  if (r.type.spec.isolating || i.type.spec.isolating)
    return !1;
  if (MB(n, e, t))
    return !0;
  let l = e.parent.canReplace(e.index(), e.index() + 1);
  if (l && (s = (o = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && o.matchType(s[0] || i.type).validEnd) {
    if (t) {
      let h = e.pos + i.nodeSize, m = U.empty;
      for (let b = s.length - 1; b >= 0; b--)
        m = U.from(s[b].create(null, m));
      m = U.from(r.copy(m));
      let g = n.tr.step(new Tt(e.pos - 1, h, e.pos, h, new Z(m, 1, 0), s.length, !0)), y = h + 2 * s.length;
      Mi(g.doc, y) && g.join(y), t(g.scrollIntoView());
    }
    return !0;
  }
  let u = _e.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && go(d);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(d, f).scrollIntoView()), !0;
  if (l && co(i, "start", !0) && co(r, "end")) {
    let h = r, m = [];
    for (; m.push(h), !h.isTextblock; )
      h = h.lastChild;
    let g = i, y = 1;
    for (; !g.isTextblock; g = g.firstChild)
      y++;
    if (h.canReplace(h.childCount, h.childCount, g.content)) {
      if (t) {
        let b = U.empty;
        for (let T = m.length - 1; T >= 0; T--)
          b = U.from(m[T].copy(b));
        let w = n.tr.step(new Tt(e.pos - m.length, e.pos + i.nodeSize, e.pos + y, e.pos + i.nodeSize - y, new Z(b, m.length, 0), 0, !0));
        t(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Zy(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(we.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const OB = Zy(-1), FB = Zy(1);
function IB(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && Of(o, n, e);
    return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1;
  };
}
function sv(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, l, (u, d) => {
        if (i)
          return !1;
        if (!(!u.isTextblock || u.hasMarkup(n, e)))
          if (u.type == n)
            i = !0;
          else {
            let f = t.doc.resolve(d), h = f.index();
            i = f.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: l }, $to: { pos: u } } = t.selection.ranges[o];
        s.setBlockType(l, u, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function RB(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = !1, u = o;
    if (!o)
      return !1;
    if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(n) && o.startIndex == 0) {
      if (i.index(o.depth - 1) == 0)
        return !1;
      let f = t.doc.resolve(o.start - 2);
      u = new Wl(f, f, o.depth), o.endIndex < o.parent.childCount && (o = new Wl(i, t.doc.resolve(s.end(o.depth)), o.depth)), l = !0;
    }
    let d = Of(u, n, e, o);
    return d ? (r && r(NB(t.tr, o, d, l, n).scrollIntoView()), !0) : !1;
  };
}
function NB(n, e, t, r, i) {
  let s = U.empty;
  for (let f = t.length - 1; f >= 0; f--)
    s = U.from(t[f].type.create(t[f].attrs, s));
  n.step(new Tt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new Z(s, 0, 0), t.length, !0));
  let o = 0;
  for (let f = 0; f < t.length; f++)
    t[f].type == i && (o = f + 1);
  let l = t.length - o, u = e.start + t.length - (r ? 2 : 0), d = e.parent;
  for (let f = e.startIndex, h = e.endIndex, m = !0; f < h; f++, m = !1)
    !m && Xs(n.doc, u, l) && (n.split(u, l), u += 2 * l), u += d.child(f).nodeSize;
  return n;
}
function BB(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? $B(e, t, n, s) : LB(e, t, s) : !0 : !1;
  };
}
function $B(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Tt(s - 1, o, s, o, new Z(U.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Wl(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const l = go(r);
  if (l == null)
    return !1;
  i.lift(r, l);
  let u = i.mapping.map(s, -1) - 1;
  return Mi(i.doc, u) && i.join(u), e(i.scrollIntoView()), !0;
}
function LB(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let g = t.end, y = t.endIndex - 1, b = t.startIndex; y > b; y--)
    g -= i.child(y).nodeSize, r.delete(g - 1, g + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let l = t.startIndex == 0, u = t.endIndex == i.childCount, d = s.node(-1), f = s.index(-1);
  if (!d.canReplace(f + (l ? 0 : 1), f + 1, o.content.append(u ? U.empty : U.from(i))))
    return !1;
  let h = s.pos, m = h + o.nodeSize;
  return r.step(new Tt(h - (l ? 1 : 0), m + (u ? 1 : 0), h + 1, m - 1, new Z((l ? U.empty : U.from(i.copy(U.empty))).append(u ? U.empty : U.from(i.copy(U.empty))), l ? 0 : 1, u ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function PB(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (d) => d.childCount > 0 && d.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let l = s.parent, u = l.child(o - 1);
    if (u.type != n)
      return !1;
    if (t) {
      let d = u.lastChild && u.lastChild.type == l.type, f = U.from(d ? n.create() : null), h = new Z(U.from(n.create(null, U.from(l.type.create(null, f)))), d ? 3 : 1, 0), m = s.start, g = s.end;
      t(e.tr.step(new Tt(m - (d ? 3 : 1), g, m, g, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Iu(n) {
  const { state: e, transaction: t } = n;
  let { selection: r } = t, { doc: i } = t, { storedMarks: s } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    filterTransaction: e.filterTransaction,
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = t.selection, i = t.doc, s = t.storedMarks, t;
    }
  };
}
class Ru {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: s } = r, o = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([l, u]) => [l, (...f) => {
      const h = u(...f)(o);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), h;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, l = [], u = !!e, d = e || s.tr, f = () => (!u && t && !d.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(d), l.every((m) => m === !0)), h = {
      ...Object.fromEntries(Object.entries(r).map(([m, g]) => [m, (...b) => {
        const w = this.buildProps(d, t), T = g(...b)(w);
        return l.push(T), h;
      }])),
      run: f
    };
    return h;
  }
  createCan(e) {
    const { rawCommands: t, state: r } = this, i = !1, s = e || r.tr, o = this.buildProps(s, i);
    return {
      ...Object.fromEntries(Object.entries(t).map(([u, d]) => [u, (...f) => d(...f)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(s, i)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i;
    s.storedMarks && e.setStoredMarks(s.storedMarks);
    const l = {
      tr: e,
      editor: i,
      view: o,
      state: Iu({
        state: s,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([u, d]) => [u, (...f) => d(...f)(l)]));
      }
    };
    return l;
  }
}
class zB {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, t)), this;
  }
  off(e, t) {
    const r = this.callbacks[e];
    return r && (t ? this.callbacks[e] = r.filter((i) => i !== t) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function se(n, e, t) {
  return n.config[e] === void 0 && n.parent ? se(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
    ...t,
    parent: n.parent ? se(n.parent, e, t) : null
  }) : n.config[e];
}
function Nu(n) {
  const e = n.filter((i) => i.type === "extension"), t = n.filter((i) => i.type === "node"), r = n.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: r
  };
}
function Qy(n) {
  const e = [], { nodeExtensions: t, markExtensions: r } = Nu(n), i = [...t, ...r], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return n.forEach((o) => {
    const l = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, u = se(o, "addGlobalAttributes", l);
    if (!u)
      return;
    u().forEach((f) => {
      f.types.forEach((h) => {
        Object.entries(f.attributes).forEach(([m, g]) => {
          e.push({
            type: h,
            name: m,
            attribute: {
              ...s,
              ...g
            }
          });
        });
      });
    });
  }), i.forEach((o) => {
    const l = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, u = se(o, "addAttributes", l);
    if (!u)
      return;
    const d = u();
    Object.entries(d).forEach(([f, h]) => {
      const m = {
        ...s,
        ...h
      };
      h != null && h.isRequired && (h == null ? void 0 : h.default) === void 0 && delete m.default, e.push({
        type: o.name,
        name: f,
        attribute: m
      });
    });
  }), e;
}
function Mt(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
    return e.nodes[n];
  }
  return n;
}
function nt(...n) {
  return n.filter((e) => !!e).reduce((e, t) => {
    const r = { ...e };
    return Object.entries(t).forEach(([i, s]) => {
      if (!r[i]) {
        r[i] = s;
        return;
      }
      i === "class" ? r[i] = [r[i], s].join(" ") : i === "style" ? r[i] = [r[i], s].join("; ") : r[i] = s;
    }), r;
  }, {});
}
function ef(n, e) {
  return e.filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
    [t.name]: n.attrs[t.name]
  }).reduce((t, r) => nt(t, r), {});
}
function eb(n) {
  return typeof n == "function";
}
function Ae(n, e = void 0, ...t) {
  return eb(n) ? e ? n.bind(e)(...t) : n(...t) : n;
}
function VB(n = {}) {
  return Object.keys(n).length === 0 && n.constructor === Object;
}
function HB(n) {
  return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n;
}
function ov(n, e) {
  return n.style ? n : {
    ...n,
    getAttrs: (t) => {
      const r = n.getAttrs ? n.getAttrs(t) : n.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((s, o) => {
        const l = o.attribute.parseHTML ? o.attribute.parseHTML(t) : HB(t.getAttribute(o.name));
        return l == null ? s : {
          ...s,
          [o.name]: l
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function av(n) {
  return Object.fromEntries(Object.entries(n).filter(([e, t]) => e === "attrs" && VB(t) ? !1 : t != null));
}
function WB(n) {
  var e;
  const t = Qy(n), { nodeExtensions: r, markExtensions: i } = Nu(n), s = (e = r.find((u) => se(u, "topNode"))) === null || e === void 0 ? void 0 : e.name, o = Object.fromEntries(r.map((u) => {
    const d = t.filter((w) => w.type === u.name), f = {
      name: u.name,
      options: u.options,
      storage: u.storage
    }, h = n.reduce((w, T) => {
      const k = se(T, "extendNodeSchema", f);
      return {
        ...w,
        ...k ? k(u) : {}
      };
    }, {}), m = av({
      ...h,
      content: Ae(se(u, "content", f)),
      marks: Ae(se(u, "marks", f)),
      group: Ae(se(u, "group", f)),
      inline: Ae(se(u, "inline", f)),
      atom: Ae(se(u, "atom", f)),
      selectable: Ae(se(u, "selectable", f)),
      draggable: Ae(se(u, "draggable", f)),
      code: Ae(se(u, "code", f)),
      defining: Ae(se(u, "defining", f)),
      isolating: Ae(se(u, "isolating", f)),
      attrs: Object.fromEntries(d.map((w) => {
        var T;
        return [w.name, { default: (T = w == null ? void 0 : w.attribute) === null || T === void 0 ? void 0 : T.default }];
      }))
    }), g = Ae(se(u, "parseHTML", f));
    g && (m.parseDOM = g.map((w) => ov(w, d)));
    const y = se(u, "renderHTML", f);
    y && (m.toDOM = (w) => y({
      node: w,
      HTMLAttributes: ef(w, d)
    }));
    const b = se(u, "renderText", f);
    return b && (m.toText = b), [u.name, m];
  })), l = Object.fromEntries(i.map((u) => {
    const d = t.filter((b) => b.type === u.name), f = {
      name: u.name,
      options: u.options,
      storage: u.storage
    }, h = n.reduce((b, w) => {
      const T = se(w, "extendMarkSchema", f);
      return {
        ...b,
        ...T ? T(u) : {}
      };
    }, {}), m = av({
      ...h,
      inclusive: Ae(se(u, "inclusive", f)),
      excludes: Ae(se(u, "excludes", f)),
      group: Ae(se(u, "group", f)),
      spanning: Ae(se(u, "spanning", f)),
      code: Ae(se(u, "code", f)),
      attrs: Object.fromEntries(d.map((b) => {
        var w;
        return [b.name, { default: (w = b == null ? void 0 : b.attribute) === null || w === void 0 ? void 0 : w.default }];
      }))
    }), g = Ae(se(u, "parseHTML", f));
    g && (m.parseDOM = g.map((b) => ov(b, d)));
    const y = se(u, "renderHTML", f);
    return y && (m.toDOM = (b) => y({
      mark: b,
      HTMLAttributes: ef(b, d)
    })), [u.name, m];
  }));
  return new iR({
    topNode: s,
    nodes: o,
    marks: l
  });
}
function bd(n, e) {
  return e.nodes[n] || e.marks[n] || null;
}
function lv(n, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
}
const UB = (n, e = 500) => {
  let t = "";
  const r = n.parentOffset;
  return n.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, l) => {
    var u, d;
    const f = ((d = (u = i.type.spec).toText) === null || d === void 0 ? void 0 : d.call(u, {
      node: i,
      pos: s,
      parent: o,
      index: l
    })) || i.textContent || "%leaf%";
    t += f.slice(0, Math.max(0, r - s));
  }), t;
};
function jf(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
class Bu {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const jB = (n, e) => {
  if (jf(e))
    return e.exec(n);
  const t = e(n);
  if (!t)
    return null;
  const r = [t.text];
  return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r;
};
function _d(n) {
  var e;
  const { editor: t, from: r, to: i, text: s, rules: o, plugin: l } = n, { view: u } = t;
  if (u.composing)
    return !1;
  const d = u.state.doc.resolve(r);
  if (d.parent.type.spec.code || !((e = d.nodeBefore || d.nodeAfter) === null || e === void 0) && e.marks.find((m) => m.type.spec.code))
    return !1;
  let f = !1;
  const h = UB(d) + s;
  return o.forEach((m) => {
    if (f)
      return;
    const g = jB(h, m.find);
    if (!g)
      return;
    const y = u.state.tr, b = Iu({
      state: u.state,
      transaction: y
    }), w = {
      from: r - (g[0].length - s.length),
      to: i
    }, { commands: T, chain: k, can: S } = new Ru({
      editor: t,
      state: b
    });
    m.handler({
      state: b,
      range: w,
      match: g,
      commands: T,
      chain: k,
      can: S
    }) === null || !y.steps.length || (y.setMeta(l, {
      transform: y,
      from: r,
      to: i,
      text: s
    }), u.dispatch(y), f = !0);
  }), f;
}
function qB(n) {
  const { editor: e, rules: t } = n, r = new kt({
    state: {
      init() {
        return null;
      },
      apply(i, s) {
        const o = i.getMeta(r);
        return o || (i.selectionSet || i.docChanged ? null : s);
      }
    },
    props: {
      handleTextInput(i, s, o, l) {
        return _d({
          editor: e,
          from: s,
          to: o,
          text: l,
          rules: t,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: s } = i.state.selection;
          s && _d({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: t,
            plugin: r
          });
        }), !1)
      },
      handleKeyDown(i, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = i.state.selection;
        return o ? _d({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: t,
          plugin: r
        }) : !1;
      }
    },
    isInputRules: !0
  });
  return r;
}
function KB(n) {
  return typeof n == "number";
}
class GB {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const JB = (n, e) => {
  if (jf(e))
    return [...n.matchAll(e)];
  const t = e(n);
  return t ? t.map((r) => {
    const i = [r.text];
    return i.index = r.index, i.input = n, i.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(r.replaceWith)), i;
  }) : [];
};
function YB(n) {
  const { editor: e, state: t, from: r, to: i, rule: s } = n, { commands: o, chain: l, can: u } = new Ru({
    editor: e,
    state: t
  }), d = [];
  return t.doc.nodesBetween(r, i, (h, m) => {
    if (!h.isTextblock || h.type.spec.code)
      return;
    const g = Math.max(r, m), y = Math.min(i, m + h.content.size), b = h.textBetween(g - m, y - m, void 0, "");
    JB(b, s.find).forEach((T) => {
      if (T.index === void 0)
        return;
      const k = g + T.index + 1, S = k + T[0].length, C = {
        from: t.tr.mapping.map(k),
        to: t.tr.mapping.map(S)
      }, R = s.handler({
        state: t,
        range: C,
        match: T,
        commands: o,
        chain: l,
        can: u
      });
      d.push(R);
    });
  }), d.every((h) => h !== null);
}
function XB(n) {
  const { editor: e, rules: t } = n;
  let r = null, i = !1, s = !1;
  return t.map((l) => new kt({
    view(u) {
      const d = (f) => {
        var h;
        r = !((h = u.dom.parentElement) === null || h === void 0) && h.contains(f.target) ? u.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", d), {
        destroy() {
          window.removeEventListener("dragstart", d);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (u) => (s = r === u.dom.parentElement, !1),
        paste: (u, d) => {
          var f;
          const h = (f = d.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
          return i = !!(h != null && h.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (u, d, f) => {
      const h = u[0], m = h.getMeta("uiEvent") === "paste" && !i, g = h.getMeta("uiEvent") === "drop" && !s;
      if (!m && !g)
        return;
      const y = d.doc.content.findDiffStart(f.doc.content), b = d.doc.content.findDiffEnd(f.doc.content);
      if (!KB(y) || !b || y === b.b)
        return;
      const w = f.tr, T = Iu({
        state: f,
        transaction: w
      });
      if (!(!YB({
        editor: e,
        state: T,
        from: Math.max(y - 1, 0),
        to: b.b - 1,
        rule: l
      }) || !w.steps.length))
        return w;
    }
  }));
}
function ZB(n) {
  const e = n.filter((t, r) => n.indexOf(t) !== r);
  return [...new Set(e)];
}
class Vs {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.extensions = Vs.resolve(e), this.schema = WB(this.extensions), this.extensions.forEach((r) => {
      var i;
      this.editor.extensionStorage[r.name] = r.storage;
      const s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: this.editor,
        type: bd(r.name, this.schema)
      };
      r.type === "mark" && (!((i = Ae(se(r, "keepOnSplit", s))) !== null && i !== void 0) || i) && this.splittableMarks.push(r.name);
      const o = se(r, "onBeforeCreate", s);
      o && this.editor.on("beforeCreate", o);
      const l = se(r, "onCreate", s);
      l && this.editor.on("create", l);
      const u = se(r, "onUpdate", s);
      u && this.editor.on("update", u);
      const d = se(r, "onSelectionUpdate", s);
      d && this.editor.on("selectionUpdate", d);
      const f = se(r, "onTransaction", s);
      f && this.editor.on("transaction", f);
      const h = se(r, "onFocus", s);
      h && this.editor.on("focus", h);
      const m = se(r, "onBlur", s);
      m && this.editor.on("blur", m);
      const g = se(r, "onDestroy", s);
      g && this.editor.on("destroy", g);
    });
  }
  static resolve(e) {
    const t = Vs.sort(Vs.flatten(e)), r = ZB(t.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), t;
  }
  static flatten(e) {
    return e.map((t) => {
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage
      }, i = se(t, "addExtensions", r);
      return i ? [t, ...this.flatten(i())] : t;
    }).flat(10);
  }
  static sort(e) {
    return e.sort((r, i) => {
      const s = se(r, "priority") || 100, o = se(i, "priority") || 100;
      return s > o ? -1 : s < o ? 1 : 0;
    });
  }
  get commands() {
    return this.extensions.reduce((e, t) => {
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: bd(t.name, this.schema)
      }, i = se(t, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  get plugins() {
    const { editor: e } = this, t = Vs.sort([...this.extensions].reverse()), r = [], i = [], s = t.map((o) => {
      const l = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: bd(o.name, this.schema)
      }, u = [], d = se(o, "addKeyboardShortcuts", l);
      let f = {};
      if (o.type === "mark" && o.config.exitable && (f.ArrowRight = () => Xn.handleExit({ editor: e, mark: o })), d) {
        const b = Object.fromEntries(Object.entries(d()).map(([w, T]) => [w, () => T({ editor: e })]));
        f = { ...f, ...b };
      }
      const h = hB(f);
      u.push(h);
      const m = se(o, "addInputRules", l);
      lv(o, e.options.enableInputRules) && m && r.push(...m());
      const g = se(o, "addPasteRules", l);
      lv(o, e.options.enablePasteRules) && g && i.push(...g());
      const y = se(o, "addProseMirrorPlugins", l);
      if (y) {
        const b = y();
        u.push(...b);
      }
      return u;
    }).flat();
    return [
      qB({
        editor: e,
        rules: r
      }),
      ...XB({
        editor: e,
        rules: i
      }),
      ...s
    ];
  }
  get attributes() {
    return Qy(this.extensions);
  }
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = Nu(this.extensions);
    return Object.fromEntries(t.filter((r) => !!se(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((u) => u.type === r.name), s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Mt(r.name, this.schema)
      }, o = se(r, "addNodeView", s);
      if (!o)
        return [];
      const l = (u, d, f, h) => {
        const m = ef(u, i);
        return o()({
          editor: e,
          node: u,
          getPos: f,
          decorations: h,
          HTMLAttributes: m,
          extension: r
        });
      };
      return [r.name, l];
    }));
  }
}
function QB(n) {
  return Object.prototype.toString.call(n).slice(8, -1);
}
function wd(n) {
  return QB(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
}
function $u(n, e) {
  const t = { ...n };
  return wd(n) && wd(e) && Object.keys(e).forEach((r) => {
    wd(e[r]) ? r in n ? t[r] = $u(n[r], e[r]) : Object.assign(t, { [r]: e[r] }) : Object.assign(t, { [r]: e[r] });
  }), t;
}
class $t {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ae(se(this, "addOptions", {
      name: this.name
    }))), this.storage = Ae(se(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new $t(e);
  }
  configure(e = {}) {
    const t = this.extend();
    return t.options = $u(this.options, e), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  extend(e = {}) {
    const t = new $t(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ae(se(t, "addOptions", {
      name: t.name
    })), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
}
function tb(n, e, t) {
  const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = t || {};
  let l = "", u = !0;
  return n.nodesBetween(r, i, (d, f, h, m) => {
    var g;
    const y = o == null ? void 0 : o[d.type.name];
    y ? (d.isBlock && !u && (l += s, u = !0), h && (l += y({
      node: d,
      pos: f,
      parent: h,
      index: m,
      range: e
    }))) : d.isText ? (l += (g = d == null ? void 0 : d.text) === null || g === void 0 ? void 0 : g.slice(Math.max(r, f) - f, i - f), u = !1) : d.isBlock && !u && (l += s, u = !0);
  }), l;
}
function nb(n) {
  return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
}
const e$ = $t.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new kt({
        key: new Gt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map((f) => f.$from.pos)), l = Math.max(...s.map((f) => f.$to.pos)), u = nb(t);
            return tb(r, { from: o, to: l }, {
              textSerializers: u
            });
          }
        }
      })
    ];
  }
}), t$ = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
  var t;
  n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges());
}), !0), n$ = (n = !1) => ({ commands: e }) => e.setContent("", n), r$ = () => ({ state: n, tr: e, dispatch: t }) => {
  const { selection: r } = e, { ranges: i } = r;
  return t && i.forEach(({ $from: s, $to: o }) => {
    n.doc.nodesBetween(s.pos, o.pos, (l, u) => {
      if (l.type.isText)
        return;
      const { doc: d, mapping: f } = e, h = d.resolve(f.map(u)), m = d.resolve(f.map(u + l.nodeSize)), g = h.blockRange(m);
      if (!g)
        return;
      const y = go(g);
      if (l.type.isTextblock) {
        const { defaultType: b } = h.parent.contentMatchAt(h.index());
        e.setNodeMarkup(g.start, b);
      }
      (y || y === 0) && e.lift(g, y);
    });
  }), !0;
}, i$ = (n) => (e) => n(e), s$ = () => ({ state: n, dispatch: e }) => AB(n, e), o$ = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, r = t.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = n.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r.type) {
      if (e) {
        const l = i.before(s), u = i.after(s);
        n.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, a$ = (n) => ({ tr: e, state: t, dispatch: r }) => {
  const i = Mt(n, t.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === i) {
      if (r) {
        const u = s.before(o), d = s.after(o);
        e.delete(u, d).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, l$ = (n) => ({ tr: e, dispatch: t }) => {
  const { from: r, to: i } = n;
  return t && e.delete(r, i), !0;
}, u$ = () => ({ state: n, dispatch: e }) => mB(n, e), c$ = () => ({ commands: n }) => n.keyboardShortcut("Enter"), d$ = () => ({ state: n, dispatch: e }) => SB(n, e);
function Xl(n, e, t = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => t.strict ? e[i] === n[i] : jf(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : !0;
}
function tf(n, e, t = {}) {
  return n.find((r) => r.type === e && Xl(r.attrs, t));
}
function f$(n, e, t = {}) {
  return !!tf(n, e, t);
}
function qf(n, e, t = {}) {
  if (!n || !e)
    return;
  let r = n.parent.childAfter(n.parentOffset);
  if (n.parentOffset === r.offset && r.offset !== 0 && (r = n.parent.childBefore(n.parentOffset)), !r.node)
    return;
  const i = tf([...r.node.marks], e, t);
  if (!i)
    return;
  let s = r.index, o = n.start() + r.offset, l = s + 1, u = o + r.node.nodeSize;
  for (tf([...r.node.marks], e, t); s > 0 && i.isInSet(n.parent.child(s - 1).marks); )
    s -= 1, o -= n.parent.child(s).nodeSize;
  for (; l < n.parent.childCount && f$([...n.parent.child(l).marks], e, t); )
    u += n.parent.child(l).nodeSize, l += 1;
  return {
    from: o,
    to: u
  };
}
function Oi(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
    return e.marks[n];
  }
  return n;
}
const p$ = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  const s = Oi(n, r.schema), { doc: o, selection: l } = t, { $from: u, from: d, to: f } = l;
  if (i) {
    const h = qf(u, s, e);
    if (h && h.from <= d && h.to >= f) {
      const m = we.create(o, h.from, h.to);
      t.setSelection(m);
    }
  }
  return !0;
}, h$ = (n) => (e) => {
  const t = typeof n == "function" ? n(e) : n;
  for (let r = 0; r < t.length; r += 1)
    if (t[r](e))
      return !0;
  return !1;
};
function Kf(n) {
  return n instanceof we;
}
function Jr(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function rb(n, e = null) {
  if (!e)
    return null;
  const t = _e.atStart(n), r = _e.atEnd(n);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return r;
  const i = t.from, s = r.to;
  return e === "all" ? we.create(n, Jr(0, i, s), Jr(n.content.size, i, s)) : we.create(n, Jr(e, i, s), Jr(e, i, s));
}
function Gf() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const m$ = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    Gf() && r.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && n === null || n === !1)
    return !0;
  if (s && n === null && !Kf(t.state.selection))
    return o(), !0;
  const l = rb(i.doc, n) || t.state.selection, u = t.state.selection.eq(l);
  return s && (u || i.setSelection(l), u && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0;
}, g$ = (n, e) => (t) => n.every((r, i) => e(r, { ...t, index: i })), v$ = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e);
function uv(n) {
  const e = `<body>${n}</body>`;
  return new window.DOMParser().parseFromString(e, "text/html").body;
}
function Zl(n, e, t) {
  if (t = {
    slice: !0,
    parseOptions: {},
    ...t
  }, typeof n == "object" && n !== null)
    try {
      return Array.isArray(n) ? U.fromArray(n.map((r) => e.nodeFromJSON(r))) : e.nodeFromJSON(n);
    } catch (r) {
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", r), Zl("", e, t);
    }
  if (typeof n == "string") {
    const r = so.fromSchema(e);
    return t.slice ? r.parseSlice(uv(n), t.parseOptions).content : r.parse(uv(n), t.parseOptions);
  }
  return Zl("", e, t);
}
function y$(n, e, t) {
  const r = n.steps.length - 1;
  if (r < e)
    return;
  const i = n.steps[r];
  if (!(i instanceof jt || i instanceof Tt))
    return;
  const s = n.mapping.maps[r];
  let o = 0;
  s.forEach((l, u, d, f) => {
    o === 0 && (o = f);
  }), n.setSelection(_e.near(n.doc.resolve(o), t));
}
const b$ = (n) => n.toString().startsWith("<"), _$ = (n, e, t) => ({ tr: r, dispatch: i, editor: s }) => {
  if (i) {
    t = {
      parseOptions: {},
      updateSelection: !0,
      ...t
    };
    const o = Zl(e, s.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...t.parseOptions
      }
    });
    if (o.toString() === "<>")
      return !0;
    let { from: l, to: u } = typeof n == "number" ? { from: n, to: n } : n, d = !0, f = !0;
    if ((b$(o) ? o : [o]).forEach((m) => {
      m.check(), d = d ? m.isText && m.marks.length === 0 : !1, f = f ? m.isBlock : !1;
    }), l === u && f) {
      const { parent: m } = r.doc.resolve(l);
      m.isTextblock && !m.type.spec.code && !m.childCount && (l -= 1, u += 1);
    }
    d ? r.insertText(e, l, u) : r.replaceWith(l, u, o), t.updateSelection && y$(r, r.steps.length - 1, -1);
  }
  return !0;
}, w$ = () => ({ state: n, dispatch: e }) => DB(n, e), D$ = () => ({ state: n, dispatch: e }) => CB(n, e), C$ = () => ({ state: n, dispatch: e }) => vB(n, e), x$ = () => ({ state: n, dispatch: e }) => _B(n, e);
function ib() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function k$(n) {
  const e = n.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l += 1) {
    const u = e[l];
    if (/^(cmd|meta|m)$/i.test(u))
      o = !0;
    else if (/^a(lt)?$/i.test(u))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      i = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      Gf() || ib() ? o = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${u}`);
  }
  return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t;
}
const S$ = (n) => ({ editor: e, view: t, tr: r, dispatch: i }) => {
  const s = k$(n).split(/-(?!$)/), o = s.find((d) => !["Alt", "Ctrl", "Meta", "Shift"].includes(d)), l = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), u = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (d) => d(t, l));
  });
  return u == null || u.steps.forEach((d) => {
    const f = d.map(r.mapping);
    f && i && r.maybeStep(f);
  }), !0;
};
function ga(n, e, t = {}) {
  const { from: r, to: i, empty: s } = n.selection, o = e ? Mt(e, n.schema) : null, l = [];
  n.doc.nodesBetween(r, i, (h, m) => {
    if (h.isText)
      return;
    const g = Math.max(r, m), y = Math.min(i, m + h.nodeSize);
    l.push({
      node: h,
      from: g,
      to: y
    });
  });
  const u = i - r, d = l.filter((h) => o ? o.name === h.node.type.name : !0).filter((h) => Xl(h.node.attrs, t, { strict: !1 }));
  return s ? !!d.length : d.reduce((h, m) => h + m.to - m.from, 0) >= u;
}
const A$ = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Mt(n, t.schema);
  return ga(t, i, e) ? xB(t, r) : !1;
}, E$ = () => ({ state: n, dispatch: e }) => EB(n, e), T$ = (n) => ({ state: e, dispatch: t }) => {
  const r = Mt(n, e.schema);
  return BB(r)(e, t);
}, M$ = () => ({ state: n, dispatch: e }) => kB(n, e);
function Lu(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function cv(n, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {});
}
const O$ = (n, e) => ({ tr: t, state: r, dispatch: i }) => {
  let s = null, o = null;
  const l = Lu(typeof n == "string" ? n : n.name, r.schema);
  return l ? (l === "node" && (s = Mt(n, r.schema)), l === "mark" && (o = Oi(n, r.schema)), i && t.selection.ranges.forEach((u) => {
    r.doc.nodesBetween(u.$from.pos, u.$to.pos, (d, f) => {
      s && s === d.type && t.setNodeMarkup(f, void 0, cv(d.attrs, e)), o && d.marks.length && d.marks.forEach((h) => {
        o === h.type && t.addMark(f, f + d.nodeSize, o.create(cv(h.attrs, e)));
      });
    });
  }), !0) : !1;
}, F$ = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), I$ = () => ({ tr: n, commands: e }) => e.setTextSelection({
  from: 0,
  to: n.doc.content.size
}), R$ = () => ({ state: n, dispatch: e }) => yB(n, e), N$ = () => ({ state: n, dispatch: e }) => wB(n, e), B$ = () => ({ state: n, dispatch: e }) => TB(n, e), $$ = () => ({ state: n, dispatch: e }) => FB(n, e), L$ = () => ({ state: n, dispatch: e }) => OB(n, e);
function sb(n, e, t = {}) {
  return Zl(n, e, { slice: !1, parseOptions: t });
}
const P$ = (n, e = !1, t = {}) => ({ tr: r, editor: i, dispatch: s }) => {
  const { doc: o } = r, l = sb(n, i.schema, t);
  return s && r.replaceWith(0, o.content.size, l).setMeta("preventUpdate", !e), !0;
};
function z$(n, e) {
  const t = new If(n);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      t.step(i);
    });
  }), t;
}
function V$(n) {
  for (let e = 0; e < n.edgeCount; e += 1) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function H$(n, e, t) {
  const r = [];
  return n.nodesBetween(e.from, e.to, (i, s) => {
    t(i) && r.push({
      node: i,
      pos: s
    });
  }), r;
}
function ob(n, e) {
  for (let t = n.depth; t > 0; t -= 1) {
    const r = n.node(t);
    if (e(r))
      return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: r
      };
  }
}
function Jf(n) {
  return (e) => ob(e.$from, n);
}
function W$(n, e) {
  const t = Ar.fromSchema(e).serializeFragment(n), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(t), i.innerHTML;
}
function U$(n, e) {
  const t = {
    from: 0,
    to: n.content.size
  };
  return tb(n, t, e);
}
function Yf(n, e) {
  const t = Oi(e, n.schema), { from: r, to: i, empty: s } = n.selection, o = [];
  s ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, (u) => {
    o.push(...u.marks);
  });
  const l = o.find((u) => u.type.name === t.name);
  return l ? { ...l.attrs } : {};
}
function j$(n, e) {
  const t = Mt(e, n.schema), { from: r, to: i } = n.selection, s = [];
  n.doc.nodesBetween(r, i, (l) => {
    s.push(l);
  });
  const o = s.reverse().find((l) => l.type.name === t.name);
  return o ? { ...o.attrs } : {};
}
function ab(n, e) {
  const t = Lu(typeof e == "string" ? e : e.name, n.schema);
  return t === "node" ? j$(n, e) : t === "mark" ? Yf(n, e) : {};
}
function q$(n, e = JSON.stringify) {
  const t = {};
  return n.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(t, i) ? !1 : t[i] = !0;
  });
}
function K$(n) {
  const e = q$(n);
  return e.length === 1 ? e : e.filter((t, r) => !e.filter((s, o) => o !== r).some((s) => t.oldRange.from >= s.oldRange.from && t.oldRange.to <= s.oldRange.to && t.newRange.from >= s.newRange.from && t.newRange.to <= s.newRange.to));
}
function G$(n) {
  const { mapping: e, steps: t } = n, r = [];
  return e.maps.forEach((i, s) => {
    const o = [];
    if (i.ranges.length)
      i.forEach((l, u) => {
        o.push({ from: l, to: u });
      });
    else {
      const { from: l, to: u } = t[s];
      if (l === void 0 || u === void 0)
        return;
      o.push({ from: l, to: u });
    }
    o.forEach(({ from: l, to: u }) => {
      const d = e.slice(s).map(l, -1), f = e.slice(s).map(u), h = e.invert().map(d, -1), m = e.invert().map(f);
      r.push({
        oldRange: {
          from: h,
          to: m
        },
        newRange: {
          from: d,
          to: f
        }
      });
    });
  }), K$(r);
}
function Ql(n, e, t) {
  const r = [];
  return n === e ? t.resolve(n).marks().forEach((i) => {
    const s = t.resolve(n - 1), o = qf(s, i.type);
    o && r.push({
      mark: i,
      ...o
    });
  }) : t.nodesBetween(n, e, (i, s) => {
    r.push(...i.marks.map((o) => ({
      from: s,
      to: s + i.nodeSize,
      mark: o
    })));
  }), r;
}
function nf(n, e, t = {}) {
  const { empty: r, ranges: i } = n.selection, s = e ? Oi(e, n.schema) : null;
  if (r)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((h) => s ? s.name === h.type.name : !0).find((h) => Xl(h.attrs, t, { strict: !1 }));
  let o = 0;
  const l = [];
  if (i.forEach(({ $from: h, $to: m }) => {
    const g = h.pos, y = m.pos;
    n.doc.nodesBetween(g, y, (b, w) => {
      if (!b.isText && !b.marks.length)
        return;
      const T = Math.max(g, w), k = Math.min(y, w + b.nodeSize), S = k - T;
      o += S, l.push(...b.marks.map((C) => ({
        mark: C,
        from: T,
        to: k
      })));
    });
  }), o === 0)
    return !1;
  const u = l.filter((h) => s ? s.name === h.mark.type.name : !0).filter((h) => Xl(h.mark.attrs, t, { strict: !1 })).reduce((h, m) => h + m.to - m.from, 0), d = l.filter((h) => s ? h.mark.type !== s && h.mark.type.excludes(s) : !0).reduce((h, m) => h + m.to - m.from, 0);
  return (u > 0 ? u + d : u) >= o;
}
function J$(n, e, t = {}) {
  if (!e)
    return ga(n, null, t) || nf(n, null, t);
  const r = Lu(e, n.schema);
  return r === "node" ? ga(n, e, t) : r === "mark" ? nf(n, e, t) : !1;
}
function dv(n, e) {
  const { nodeExtensions: t } = Nu(e), r = t.find((o) => o.name === n);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, s = Ae(se(r, "group", i));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function Y$(n) {
  var e;
  const t = (e = n.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON(), r = n.toJSON();
  return JSON.stringify(t) === JSON.stringify(r);
}
function X$(n) {
  return n instanceof ve;
}
function lb(n, e, t) {
  const i = n.state.doc.content.size, s = Jr(e, 0, i), o = Jr(t, 0, i), l = n.coordsAtPos(s), u = n.coordsAtPos(o, -1), d = Math.min(l.top, u.top), f = Math.max(l.bottom, u.bottom), h = Math.min(l.left, u.left), m = Math.max(l.right, u.right), g = m - h, y = f - d, T = {
    top: d,
    bottom: f,
    left: h,
    right: m,
    width: g,
    height: y,
    x: h,
    y: d
  };
  return {
    ...T,
    toJSON: () => T
  };
}
function Z$(n, e, t) {
  var r;
  const { selection: i } = e;
  let s = null;
  if (Kf(i) && (s = i.$cursor), s) {
    const l = (r = n.storedMarks) !== null && r !== void 0 ? r : s.marks();
    return !!t.isInSet(l) || !l.some((u) => u.type.excludes(t));
  }
  const { ranges: o } = i;
  return o.some(({ $from: l, $to: u }) => {
    let d = l.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1;
    return n.doc.nodesBetween(l.pos, u.pos, (f, h, m) => {
      if (d)
        return !1;
      if (f.isInline) {
        const g = !m || m.type.allowsMarkType(t), y = !!t.isInSet(f.marks) || !f.marks.some((b) => b.type.excludes(t));
        d = g && y;
      }
      return !d;
    }), d;
  });
}
const Q$ = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  const { selection: s } = t, { empty: o, ranges: l } = s, u = Oi(n, r.schema);
  if (i)
    if (o) {
      const d = Yf(r, u);
      t.addStoredMark(u.create({
        ...d,
        ...e
      }));
    } else
      l.forEach((d) => {
        const f = d.$from.pos, h = d.$to.pos;
        r.doc.nodesBetween(f, h, (m, g) => {
          const y = Math.max(g, f), b = Math.min(g + m.nodeSize, h);
          m.marks.find((T) => T.type === u) ? m.marks.forEach((T) => {
            u === T.type && t.addMark(y, b, u.create({
              ...T.attrs,
              ...e
            }));
          }) : t.addMark(y, b, u.create(e));
        });
      });
  return Z$(r, t, u);
}, eL = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), tL = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => {
  const s = Mt(n, t.schema);
  return s.isTextblock ? i().command(({ commands: o }) => sv(s, e)(t) ? !0 : o.clearNodes()).command(({ state: o }) => sv(s, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, nL = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, i = Jr(n, 0, r.content.size), s = ve.create(r, i);
    e.setSelection(s);
  }
  return !0;
}, rL = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, { from: i, to: s } = typeof n == "number" ? { from: n, to: n } : n, o = we.atStart(r).from, l = we.atEnd(r).to, u = Jr(i, o, l), d = Jr(s, o, l), f = we.create(r, u, d);
    e.setSelection(f);
  }
  return !0;
}, iL = (n) => ({ state: e, dispatch: t }) => {
  const r = Mt(n, e.schema);
  return PB(r)(e, t);
};
function Fl(n, e, t) {
  return Object.fromEntries(Object.entries(t).filter(([r]) => {
    const i = n.find((s) => s.type === e && s.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function fv(n, e) {
  const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
  if (t) {
    const r = t.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    n.tr.ensureMarks(r);
  }
}
const sL = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => {
  const { selection: s, doc: o } = e, { $from: l, $to: u } = s, d = i.extensionManager.attributes, f = Fl(d, l.node().type.name, l.node().attrs);
  if (s instanceof ve && s.node.isBlock)
    return !l.parentOffset || !Xs(o, l.pos) ? !1 : (r && (n && fv(t, i.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()), !0);
  if (!l.parent.isBlock)
    return !1;
  if (r) {
    const h = u.parentOffset === u.parent.content.size;
    s instanceof we && e.deleteSelection();
    const m = l.depth === 0 ? void 0 : V$(l.node(-1).contentMatchAt(l.indexAfter(-1)));
    let g = h && m ? [
      {
        type: m,
        attrs: f
      }
    ] : void 0, y = Xs(e.doc, e.mapping.map(l.pos), 1, g);
    if (!g && !y && Xs(e.doc, e.mapping.map(l.pos), 1, m ? [{ type: m }] : void 0) && (y = !0, g = m ? [
      {
        type: m,
        attrs: f
      }
    ] : void 0), y && (e.split(e.mapping.map(l.pos), 1, g), m && !h && !l.parentOffset && l.parent.type !== m)) {
      const b = e.mapping.map(l.before()), w = e.doc.resolve(b);
      l.node(-1).canReplaceWith(w.index(), w.index() + 1, m) && e.setNodeMarkup(e.mapping.map(l.before()), m);
    }
    n && fv(t, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return !0;
}, oL = (n) => ({ tr: e, state: t, dispatch: r, editor: i }) => {
  var s;
  const o = Mt(n, t.schema), { $from: l, $to: u } = t.selection, d = t.selection.node;
  if (d && d.isBlock || l.depth < 2 || !l.sameParent(u))
    return !1;
  const f = l.node(-1);
  if (f.type !== o)
    return !1;
  const h = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== o || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (r) {
      let w = U.empty;
      const T = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let P = l.depth - T; P >= l.depth - 3; P -= 1)
        w = U.from(l.node(P).copy(w));
      const k = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, S = Fl(h, l.node().type.name, l.node().attrs), C = ((s = o.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(S)) || void 0;
      w = w.append(U.from(o.createAndFill(null, C) || void 0));
      const R = l.before(l.depth - (T - 1));
      e.replace(R, l.after(-k), new Z(w, 4 - T, 0));
      let I = -1;
      e.doc.nodesBetween(R, e.doc.content.size, (P, L) => {
        if (I > -1)
          return !1;
        P.isTextblock && P.content.size === 0 && (I = L + 1);
      }), I > -1 && e.setSelection(we.near(e.doc.resolve(I))), e.scrollIntoView();
    }
    return !0;
  }
  const m = u.pos === l.end() ? f.contentMatchAt(0).defaultType : null, g = Fl(h, f.type.name, f.attrs), y = Fl(h, l.node().type.name, l.node().attrs);
  e.delete(l.pos, u.pos);
  const b = m ? [
    { type: o, attrs: g },
    { type: m, attrs: y }
  ] : [{ type: o, attrs: g }];
  return Xs(e.doc, l.pos, 2) ? (r && e.split(l.pos, 2, b).scrollIntoView(), !0) : !1;
}, pv = (n, e) => {
  const t = Jf((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (r === void 0)
    return !0;
  const i = n.doc.nodeAt(r);
  return t.node.type === (i == null ? void 0 : i.type) && Mi(n.doc, t.pos) && n.join(t.pos), !0;
}, hv = (n, e) => {
  const t = Jf((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(t.start).after(t.depth);
  if (r === void 0)
    return !0;
  const i = n.doc.nodeAt(r);
  return t.node.type === (i == null ? void 0 : i.type) && Mi(n.doc, r) && n.join(r), !0;
}, aL = (n, e) => ({ editor: t, tr: r, state: i, dispatch: s, chain: o, commands: l, can: u }) => {
  const { extensions: d } = t.extensionManager, f = Mt(n, i.schema), h = Mt(e, i.schema), { selection: m } = i, { $from: g, $to: y } = m, b = g.blockRange(y);
  if (!b)
    return !1;
  const w = Jf((T) => dv(T.type.name, d))(m);
  if (b.depth >= 1 && w && b.depth - w.depth <= 1) {
    if (w.node.type === f)
      return l.liftListItem(h);
    if (dv(w.node.type.name, d) && f.validContent(w.node.content) && s)
      return o().command(() => (r.setNodeMarkup(w.pos, f), !0)).command(() => pv(r, f)).command(() => hv(r, f)).run();
  }
  return o().command(() => u().wrapInList(f) ? !0 : l.clearNodes()).wrapInList(f).command(() => pv(r, f)).command(() => hv(r, f)).run();
}, lL = (n, e = {}, t = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: s = !1 } = t, o = Oi(n, r.schema);
  return nf(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e);
}, uL = (n, e, t = {}) => ({ state: r, commands: i }) => {
  const s = Mt(n, r.schema), o = Mt(e, r.schema);
  return ga(r, s, t) ? i.setNode(o) : i.setNode(s, t);
}, cL = (n, e = {}) => ({ state: t, commands: r }) => {
  const i = Mt(n, t.schema);
  return ga(t, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, dL = () => ({ state: n, dispatch: e }) => {
  const t = n.plugins;
  for (let r = 0; r < t.length; r += 1) {
    const i = t[r];
    let s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        const o = n.tr, l = s.transform;
        for (let u = l.steps.length - 1; u >= 0; u -= 1)
          o.step(l.steps[u].invert(l.docs[u]));
        if (s.text) {
          const u = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, u));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, fL = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, { empty: r, ranges: i } = t;
  return r || e && i.forEach((s) => {
    n.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, pL = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: l } = t, u = Oi(n, r.schema), { $from: d, empty: f, ranges: h } = l;
  if (!i)
    return !0;
  if (f && o) {
    let { from: m, to: g } = l;
    const y = (s = d.marks().find((w) => w.type === u)) === null || s === void 0 ? void 0 : s.attrs, b = qf(d, u, y);
    b && (m = b.from, g = b.to), t.removeMark(m, g, u);
  } else
    h.forEach((m) => {
      t.removeMark(m.$from.pos, m.$to.pos, u);
    });
  return t.removeStoredMark(u), !0;
}, hL = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  let s = null, o = null;
  const l = Lu(typeof n == "string" ? n : n.name, r.schema);
  return l ? (l === "node" && (s = Mt(n, r.schema)), l === "mark" && (o = Oi(n, r.schema)), i && t.selection.ranges.forEach((u) => {
    const d = u.$from.pos, f = u.$to.pos;
    r.doc.nodesBetween(d, f, (h, m) => {
      s && s === h.type && t.setNodeMarkup(m, void 0, {
        ...h.attrs,
        ...e
      }), o && h.marks.length && h.marks.forEach((g) => {
        if (o === g.type) {
          const y = Math.max(m, d), b = Math.min(m + h.nodeSize, f);
          t.addMark(y, b, o.create({
            ...g.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, mL = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Mt(n, t.schema);
  return IB(i, e)(t, r);
}, gL = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Mt(n, t.schema);
  return RB(i, e)(t, r);
};
var vL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: t$,
  clearContent: n$,
  clearNodes: r$,
  command: i$,
  createParagraphNear: s$,
  deleteCurrentNode: o$,
  deleteNode: a$,
  deleteRange: l$,
  deleteSelection: u$,
  enter: c$,
  exitCode: d$,
  extendMarkRange: p$,
  first: h$,
  focus: m$,
  forEach: g$,
  insertContent: v$,
  insertContentAt: _$,
  joinUp: w$,
  joinDown: D$,
  joinBackward: C$,
  joinForward: x$,
  keyboardShortcut: S$,
  lift: A$,
  liftEmptyBlock: E$,
  liftListItem: T$,
  newlineInCode: M$,
  resetAttributes: O$,
  scrollIntoView: F$,
  selectAll: I$,
  selectNodeBackward: R$,
  selectNodeForward: N$,
  selectParentNode: B$,
  selectTextblockEnd: $$,
  selectTextblockStart: L$,
  setContent: P$,
  setMark: Q$,
  setMeta: eL,
  setNode: tL,
  setNodeSelection: nL,
  setTextSelection: rL,
  sinkListItem: iL,
  splitBlock: sL,
  splitListItem: oL,
  toggleList: aL,
  toggleMark: lL,
  toggleNode: uL,
  toggleWrap: cL,
  undoInputRule: dL,
  unsetAllMarks: fL,
  unsetMark: pL,
  updateAttributes: hL,
  wrapIn: mL,
  wrapInList: gL
});
const yL = $t.create({
  name: "commands",
  addCommands() {
    return {
      ...vL
    };
  }
}), bL = $t.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new kt({
        key: new Gt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), _L = $t.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new kt({
        key: new Gt("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              n.isFocused = !0;
              const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, t) => {
              n.isFocused = !1;
              const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), wL = $t.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      () => o.command(({ tr: l }) => {
        const { selection: u, doc: d } = l, { empty: f, $anchor: h } = u, { pos: m, parent: g } = h, y = _e.atStart(d).from === m;
        return !f || !y || !g.type.isTextblock || g.textContent.length ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: n,
      "Mod-Backspace": n,
      "Shift-Backspace": n,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, s = {
      ...r,
      "Ctrl-h": n,
      "Alt-Backspace": n,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Gf() || ib() ? s : i;
  },
  addProseMirrorPlugins() {
    return [
      new kt({
        key: new Gt("clearDocument"),
        appendTransaction: (n, e, t) => {
          if (!(n.some((y) => y.docChanged) && !e.doc.eq(t.doc)))
            return;
          const { empty: i, from: s, to: o } = e.selection, l = _e.atStart(e.doc).from, u = _e.atEnd(e.doc).to, d = s === l && o === u, f = t.doc.textBetween(0, t.doc.content.size, " ", " ").length === 0;
          if (i || !d || !f)
            return;
          const h = t.tr, m = Iu({
            state: t,
            transaction: h
          }), { commands: g } = new Ru({
            editor: this.editor,
            state: m
          });
          if (g.clearNodes(), !!h.steps.length)
            return h;
        }
      })
    ];
  }
}), DL = $t.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new kt({
        key: new Gt("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var CL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: e$,
  Commands: yL,
  Editable: bL,
  FocusEvents: _L,
  Keymap: wL,
  Tabindex: DL
});
const xL = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function kL(n, e) {
  const t = document.querySelector("style[data-tiptap-style]");
  if (t !== null)
    return t;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute("data-tiptap-style", ""), r.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let SL = class extends zB {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }));
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    this.options.injectCSS && document && (this.css = kL(xL, this.options.injectNonce));
  }
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(e, t) {
    const r = eb(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    this.view.updateState(i);
  }
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = typeof e == "string" ? `${e}$` : e.key, r = this.state.reconfigure({
      plugins: this.state.plugins.filter((i) => !i.key.startsWith(t))
    });
    this.view.updateState(r);
  }
  createExtensionManager() {
    const t = [...this.options.enableCoreExtensions ? Object.values(CL) : [], ...this.options.extensions].filter((r) => ["extension", "node", "mark"].includes(r == null ? void 0 : r.type));
    this.extensionManager = new Vs(t, this);
  }
  createCommandManager() {
    this.commandManager = new Ru({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    const e = sb(this.options.content, this.schema, this.options.parseOptions), t = rb(e, this.options.autofocus);
    this.view = new iB(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Ps.create({
        doc: e,
        selection: t || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews();
    const i = this.view.dom;
    i.editor = this;
  }
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  dispatchTransaction(e) {
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var l;
        return (l = this.capturedTransaction) === null || l === void 0 ? void 0 : l.step(o);
      });
      return;
    }
    const t = this.state.apply(e), r = !this.state.selection.eq(t.selection);
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), s = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  getAttributes(e) {
    return ab(this.state, e);
  }
  isActive(e, t) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e;
    return J$(this.state, r, i);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return W$(this.state.doc.content, this.schema);
  }
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {};
    return U$(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...r,
        ...nb(this.schema)
      }
    });
  }
  get isEmpty() {
    return Y$(this.state.doc);
  }
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners();
  }
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
};
function fs(n) {
  return new Bu({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = Ae(n.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], l = r[0];
      let u = t.to;
      if (o) {
        const d = l.search(/\S/), f = t.from + l.indexOf(o), h = f + o.length;
        if (Ql(t.from, t.to, e.doc).filter((g) => g.mark.type.excluded.find((b) => b === n.type && b !== g.mark.type)).filter((g) => g.to > f).length)
          return null;
        h < t.to && s.delete(h, t.to), f > t.from && s.delete(t.from + d, f), u = t.from + d + o.length, s.addMark(t.from + d, u, n.type.create(i || {})), s.removeStoredMark(n.type);
      }
    }
  });
}
function Xf(n) {
  return new Bu({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = Ae(n.getAttributes, void 0, r) || {}, { tr: s } = e, o = t.from;
      let l = t.to;
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let d = o + u;
        d > l ? d = l : l = d + r[1].length;
        const f = r[0][r[0].length - 1];
        s.insertText(f, o + r[0].length - 1), s.replaceWith(d, l, n.type.create(i));
      } else
        r[0] && s.replaceWith(o, l, n.type.create(i));
    }
  });
}
function rf(n) {
  return new Bu({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = e.doc.resolve(t.from), s = Ae(n.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, s);
    }
  });
}
function Zf(n) {
  return new Bu({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = Ae(n.getAttributes, void 0, r) || {}, s = e.tr.delete(t.from, t.to), l = s.doc.resolve(t.from).blockRange(), u = l && Of(l, n.type, i);
      if (!u)
        return null;
      s.wrap(l, u);
      const d = s.doc.resolve(t.from - 1).nodeBefore;
      d && d.type === n.type && Mi(s.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, d)) && s.join(t.from - 1);
    }
  });
}
class Xn {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ae(se(this, "addOptions", {
      name: this.name
    }))), this.storage = Ae(se(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Xn(e);
  }
  configure(e = {}) {
    const t = this.extend();
    return t.options = $u(this.options, e), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  extend(e = {}) {
    const t = new Xn(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ae(se(t, "addOptions", {
      name: t.name
    })), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const o = i.marks();
      if (!!!o.find((d) => (d == null ? void 0 : d.type.name) === t.name))
        return !1;
      const u = o.find((d) => (d == null ? void 0 : d.type.name) === t.name);
      return u && r.removeStoredMark(u), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
class mt {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ae(se(this, "addOptions", {
      name: this.name
    }))), this.storage = Ae(se(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new mt(e);
  }
  configure(e = {}) {
    const t = this.extend();
    return t.options = $u(this.options, e), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  extend(e = {}) {
    const t = new mt(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ae(se(t, "addOptions", {
      name: t.name
    })), t.storage = Ae(se(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
}
function Ei(n) {
  return new GB({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = Ae(n.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], l = r[0];
      let u = t.to;
      if (o) {
        const d = l.search(/\S/), f = t.from + l.indexOf(o), h = f + o.length;
        if (Ql(t.from, t.to, e.doc).filter((g) => g.mark.type.excluded.find((b) => b === n.type && b !== g.mark.type)).filter((g) => g.to > f).length)
          return null;
        h < t.to && s.delete(h, t.to), f > t.from && s.delete(t.from + d, f), u = t.from + d + o.length, s.addMark(t.from + d, u, n.type.create(i || {})), s.removeStoredMark(n.type);
      }
    }
  });
}
var Xi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, eu = {}, AL = {
  get exports() {
    return eu;
  },
  set exports(n) {
    eu = n;
  }
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(n, e) {
  (function() {
    var t, r = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", l = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", d = 500, f = "__lodash_placeholder__", h = 1, m = 2, g = 4, y = 1, b = 2, w = 1, T = 2, k = 4, S = 8, C = 16, R = 32, I = 64, P = 128, L = 256, q = 512, oe = 30, ae = "...", ke = 800, Ee = 16, rt = 1, Qe = 2, Ke = 3, He = 1 / 0, De = 9007199254740991, Te = 17976931348623157e292, Oe = 0 / 0, je = 4294967295, it = je - 1, Qn = je >>> 1, gt = [
      ["ary", P],
      ["bind", w],
      ["bindKey", T],
      ["curry", S],
      ["curryRight", C],
      ["flip", q],
      ["partial", R],
      ["partialRight", I],
      ["rearg", L]
    ], st = "[object Arguments]", _t = "[object Array]", bn = "[object AsyncFunction]", wt = "[object Boolean]", Jt = "[object Date]", ln = "[object DOMException]", Lt = "[object Error]", er = "[object Function]", In = "[object GeneratorFunction]", Pt = "[object Map]", vr = "[object Number]", Fi = "[object Null]", Yt = "[object Object]", Ii = "[object Promise]", gs = "[object Proxy]", Xt = "[object RegExp]", vt = "[object Set]", tr = "[object String]", Rn = "[object Symbol]", Ri = "[object Undefined]", yr = "[object WeakMap]", vs = "[object WeakSet]", br = "[object ArrayBuffer]", nr = "[object DataView]", bo = "[object Float32Array]", _o = "[object Float64Array]", wo = "[object Int8Array]", Do = "[object Int16Array]", Co = "[object Int32Array]", z = "[object Uint8Array]", ie = "[object Uint8ClampedArray]", pe = "[object Uint16Array]", Pe = "[object Uint32Array]", Be = /\b__p \+= '';/g, Ot = /\b(__p \+=) '' \+/g, un = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Rr = /&(?:amp|lt|gt|quot|#39);/g, xo = /[&<>"']/g, Nr = RegExp(Rr.source), ko = RegExp(xo.source), ys = /<%-([\s\S]+?)%>/g, Qr = /<%([\s\S]+?)%>/g, Aa = /<%=([\s\S]+?)%>/g, So = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, bs = /^\w*$/, Wb = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, zu = /[\\^$.*+?()[\]{}|]/g, Ub = RegExp(zu.source), Vu = /^\s+/, jb = /\s/, qb = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Kb = /\{\n\/\* \[wrapped with (.+)\] \*/, Gb = /,? & /, Jb = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Yb = /[()=,{}\[\]\/\s]/, Xb = /\\(\\)?/g, Zb = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, dp = /\w*$/, Qb = /^[-+]0x[0-9a-f]+$/i, e1 = /^0b[01]+$/i, t1 = /^\[object .+?Constructor\]$/, n1 = /^0o[0-7]+$/i, r1 = /^(?:0|[1-9]\d*)$/, i1 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ea = /($^)/, s1 = /['\n\r\u2028\u2029\\]/g, Ta = "\\ud800-\\udfff", o1 = "\\u0300-\\u036f", a1 = "\\ufe20-\\ufe2f", l1 = "\\u20d0-\\u20ff", fp = o1 + a1 + l1, pp = "\\u2700-\\u27bf", hp = "a-z\\xdf-\\xf6\\xf8-\\xff", u1 = "\\xac\\xb1\\xd7\\xf7", c1 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", d1 = "\\u2000-\\u206f", f1 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", mp = "A-Z\\xc0-\\xd6\\xd8-\\xde", gp = "\\ufe0e\\ufe0f", vp = u1 + c1 + d1 + f1, Hu = "[']", p1 = "[" + Ta + "]", yp = "[" + vp + "]", Ma = "[" + fp + "]", bp = "\\d+", h1 = "[" + pp + "]", _p = "[" + hp + "]", wp = "[^" + Ta + vp + bp + pp + hp + mp + "]", Wu = "\\ud83c[\\udffb-\\udfff]", m1 = "(?:" + Ma + "|" + Wu + ")", Dp = "[^" + Ta + "]", Uu = "(?:\\ud83c[\\udde6-\\uddff]){2}", ju = "[\\ud800-\\udbff][\\udc00-\\udfff]", _s = "[" + mp + "]", Cp = "\\u200d", xp = "(?:" + _p + "|" + wp + ")", g1 = "(?:" + _s + "|" + wp + ")", kp = "(?:" + Hu + "(?:d|ll|m|re|s|t|ve))?", Sp = "(?:" + Hu + "(?:D|LL|M|RE|S|T|VE))?", Ap = m1 + "?", Ep = "[" + gp + "]?", v1 = "(?:" + Cp + "(?:" + [Dp, Uu, ju].join("|") + ")" + Ep + Ap + ")*", y1 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", b1 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Tp = Ep + Ap + v1, _1 = "(?:" + [h1, Uu, ju].join("|") + ")" + Tp, w1 = "(?:" + [Dp + Ma + "?", Ma, Uu, ju, p1].join("|") + ")", D1 = RegExp(Hu, "g"), C1 = RegExp(Ma, "g"), qu = RegExp(Wu + "(?=" + Wu + ")|" + w1 + Tp, "g"), x1 = RegExp([
      _s + "?" + _p + "+" + kp + "(?=" + [yp, _s, "$"].join("|") + ")",
      g1 + "+" + Sp + "(?=" + [yp, _s + xp, "$"].join("|") + ")",
      _s + "?" + xp + "+" + kp,
      _s + "+" + Sp,
      b1,
      y1,
      bp,
      _1
    ].join("|"), "g"), k1 = RegExp("[" + Cp + Ta + fp + gp + "]"), S1 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, A1 = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], E1 = -1, tt = {};
    tt[bo] = tt[_o] = tt[wo] = tt[Do] = tt[Co] = tt[z] = tt[ie] = tt[pe] = tt[Pe] = !0, tt[st] = tt[_t] = tt[br] = tt[wt] = tt[nr] = tt[Jt] = tt[Lt] = tt[er] = tt[Pt] = tt[vr] = tt[Yt] = tt[Xt] = tt[vt] = tt[tr] = tt[yr] = !1;
    var et = {};
    et[st] = et[_t] = et[br] = et[nr] = et[wt] = et[Jt] = et[bo] = et[_o] = et[wo] = et[Do] = et[Co] = et[Pt] = et[vr] = et[Yt] = et[Xt] = et[vt] = et[tr] = et[Rn] = et[z] = et[ie] = et[pe] = et[Pe] = !0, et[Lt] = et[er] = et[yr] = !1;
    var T1 = {
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, M1 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, O1 = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, F1 = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, I1 = parseFloat, R1 = parseInt, Mp = typeof Xi == "object" && Xi && Xi.Object === Object && Xi, N1 = typeof self == "object" && self && self.Object === Object && self, Ft = Mp || N1 || Function("return this")(), Ku = e && !e.nodeType && e, Ni = Ku && !0 && n && !n.nodeType && n, Op = Ni && Ni.exports === Ku, Gu = Op && Mp.process, Nn = function() {
      try {
        var N = Ni && Ni.require && Ni.require("util").types;
        return N || Gu && Gu.binding && Gu.binding("util");
      } catch {
      }
    }(), Fp = Nn && Nn.isArrayBuffer, Ip = Nn && Nn.isDate, Rp = Nn && Nn.isMap, Np = Nn && Nn.isRegExp, Bp = Nn && Nn.isSet, $p = Nn && Nn.isTypedArray;
    function _n(N, V, $) {
      switch ($.length) {
        case 0:
          return N.call(V);
        case 1:
          return N.call(V, $[0]);
        case 2:
          return N.call(V, $[0], $[1]);
        case 3:
          return N.call(V, $[0], $[1], $[2]);
      }
      return N.apply(V, $);
    }
    function B1(N, V, $, te) {
      for (var Ce = -1, Ve = N == null ? 0 : N.length; ++Ce < Ve; ) {
        var Dt = N[Ce];
        V(te, Dt, $(Dt), N);
      }
      return te;
    }
    function Bn(N, V) {
      for (var $ = -1, te = N == null ? 0 : N.length; ++$ < te && V(N[$], $, N) !== !1; )
        ;
      return N;
    }
    function $1(N, V) {
      for (var $ = N == null ? 0 : N.length; $-- && V(N[$], $, N) !== !1; )
        ;
      return N;
    }
    function Lp(N, V) {
      for (var $ = -1, te = N == null ? 0 : N.length; ++$ < te; )
        if (!V(N[$], $, N))
          return !1;
      return !0;
    }
    function ei(N, V) {
      for (var $ = -1, te = N == null ? 0 : N.length, Ce = 0, Ve = []; ++$ < te; ) {
        var Dt = N[$];
        V(Dt, $, N) && (Ve[Ce++] = Dt);
      }
      return Ve;
    }
    function Oa(N, V) {
      var $ = N == null ? 0 : N.length;
      return !!$ && ws(N, V, 0) > -1;
    }
    function Ju(N, V, $) {
      for (var te = -1, Ce = N == null ? 0 : N.length; ++te < Ce; )
        if ($(V, N[te]))
          return !0;
      return !1;
    }
    function ot(N, V) {
      for (var $ = -1, te = N == null ? 0 : N.length, Ce = Array(te); ++$ < te; )
        Ce[$] = V(N[$], $, N);
      return Ce;
    }
    function ti(N, V) {
      for (var $ = -1, te = V.length, Ce = N.length; ++$ < te; )
        N[Ce + $] = V[$];
      return N;
    }
    function Yu(N, V, $, te) {
      var Ce = -1, Ve = N == null ? 0 : N.length;
      for (te && Ve && ($ = N[++Ce]); ++Ce < Ve; )
        $ = V($, N[Ce], Ce, N);
      return $;
    }
    function L1(N, V, $, te) {
      var Ce = N == null ? 0 : N.length;
      for (te && Ce && ($ = N[--Ce]); Ce--; )
        $ = V($, N[Ce], Ce, N);
      return $;
    }
    function Xu(N, V) {
      for (var $ = -1, te = N == null ? 0 : N.length; ++$ < te; )
        if (V(N[$], $, N))
          return !0;
      return !1;
    }
    var P1 = Zu("length");
    function z1(N) {
      return N.split("");
    }
    function V1(N) {
      return N.match(Jb) || [];
    }
    function Pp(N, V, $) {
      var te;
      return $(N, function(Ce, Ve, Dt) {
        if (V(Ce, Ve, Dt))
          return te = Ve, !1;
      }), te;
    }
    function Fa(N, V, $, te) {
      for (var Ce = N.length, Ve = $ + (te ? 1 : -1); te ? Ve-- : ++Ve < Ce; )
        if (V(N[Ve], Ve, N))
          return Ve;
      return -1;
    }
    function ws(N, V, $) {
      return V === V ? Q1(N, V, $) : Fa(N, zp, $);
    }
    function H1(N, V, $, te) {
      for (var Ce = $ - 1, Ve = N.length; ++Ce < Ve; )
        if (te(N[Ce], V))
          return Ce;
      return -1;
    }
    function zp(N) {
      return N !== N;
    }
    function Vp(N, V) {
      var $ = N == null ? 0 : N.length;
      return $ ? ec(N, V) / $ : Oe;
    }
    function Zu(N) {
      return function(V) {
        return V == null ? t : V[N];
      };
    }
    function Qu(N) {
      return function(V) {
        return N == null ? t : N[V];
      };
    }
    function Hp(N, V, $, te, Ce) {
      return Ce(N, function(Ve, Dt, Ze) {
        $ = te ? (te = !1, Ve) : V($, Ve, Dt, Ze);
      }), $;
    }
    function W1(N, V) {
      var $ = N.length;
      for (N.sort(V); $--; )
        N[$] = N[$].value;
      return N;
    }
    function ec(N, V) {
      for (var $, te = -1, Ce = N.length; ++te < Ce; ) {
        var Ve = V(N[te]);
        Ve !== t && ($ = $ === t ? Ve : $ + Ve);
      }
      return $;
    }
    function tc(N, V) {
      for (var $ = -1, te = Array(N); ++$ < N; )
        te[$] = V($);
      return te;
    }
    function U1(N, V) {
      return ot(V, function($) {
        return [$, N[$]];
      });
    }
    function Wp(N) {
      return N && N.slice(0, Kp(N) + 1).replace(Vu, "");
    }
    function wn(N) {
      return function(V) {
        return N(V);
      };
    }
    function nc(N, V) {
      return ot(V, function($) {
        return N[$];
      });
    }
    function Ao(N, V) {
      return N.has(V);
    }
    function Up(N, V) {
      for (var $ = -1, te = N.length; ++$ < te && ws(V, N[$], 0) > -1; )
        ;
      return $;
    }
    function jp(N, V) {
      for (var $ = N.length; $-- && ws(V, N[$], 0) > -1; )
        ;
      return $;
    }
    function j1(N, V) {
      for (var $ = N.length, te = 0; $--; )
        N[$] === V && ++te;
      return te;
    }
    var q1 = Qu(T1), K1 = Qu(M1);
    function G1(N) {
      return "\\" + F1[N];
    }
    function J1(N, V) {
      return N == null ? t : N[V];
    }
    function Ds(N) {
      return k1.test(N);
    }
    function Y1(N) {
      return S1.test(N);
    }
    function X1(N) {
      for (var V, $ = []; !(V = N.next()).done; )
        $.push(V.value);
      return $;
    }
    function rc(N) {
      var V = -1, $ = Array(N.size);
      return N.forEach(function(te, Ce) {
        $[++V] = [Ce, te];
      }), $;
    }
    function qp(N, V) {
      return function($) {
        return N(V($));
      };
    }
    function ni(N, V) {
      for (var $ = -1, te = N.length, Ce = 0, Ve = []; ++$ < te; ) {
        var Dt = N[$];
        (Dt === V || Dt === f) && (N[$] = f, Ve[Ce++] = $);
      }
      return Ve;
    }
    function Ia(N) {
      var V = -1, $ = Array(N.size);
      return N.forEach(function(te) {
        $[++V] = te;
      }), $;
    }
    function Z1(N) {
      var V = -1, $ = Array(N.size);
      return N.forEach(function(te) {
        $[++V] = [te, te];
      }), $;
    }
    function Q1(N, V, $) {
      for (var te = $ - 1, Ce = N.length; ++te < Ce; )
        if (N[te] === V)
          return te;
      return -1;
    }
    function e_(N, V, $) {
      for (var te = $ + 1; te--; )
        if (N[te] === V)
          return te;
      return te;
    }
    function Cs(N) {
      return Ds(N) ? n_(N) : P1(N);
    }
    function rr(N) {
      return Ds(N) ? r_(N) : z1(N);
    }
    function Kp(N) {
      for (var V = N.length; V-- && jb.test(N.charAt(V)); )
        ;
      return V;
    }
    var t_ = Qu(O1);
    function n_(N) {
      for (var V = qu.lastIndex = 0; qu.test(N); )
        ++V;
      return V;
    }
    function r_(N) {
      return N.match(qu) || [];
    }
    function i_(N) {
      return N.match(x1) || [];
    }
    var s_ = function N(V) {
      V = V == null ? Ft : xs.defaults(Ft.Object(), V, xs.pick(Ft, A1));
      var $ = V.Array, te = V.Date, Ce = V.Error, Ve = V.Function, Dt = V.Math, Ze = V.Object, ic = V.RegExp, o_ = V.String, $n = V.TypeError, Ra = $.prototype, a_ = Ve.prototype, ks = Ze.prototype, Na = V["__core-js_shared__"], Ba = a_.toString, qe = ks.hasOwnProperty, l_ = 0, Gp = function() {
        var a = /[^.]+$/.exec(Na && Na.keys && Na.keys.IE_PROTO || "");
        return a ? "Symbol(src)_1." + a : "";
      }(), $a = ks.toString, u_ = Ba.call(Ze), c_ = Ft._, d_ = ic(
        "^" + Ba.call(qe).replace(zu, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), La = Op ? V.Buffer : t, ri = V.Symbol, Pa = V.Uint8Array, Jp = La ? La.allocUnsafe : t, za = qp(Ze.getPrototypeOf, Ze), Yp = Ze.create, Xp = ks.propertyIsEnumerable, Va = Ra.splice, Zp = ri ? ri.isConcatSpreadable : t, Eo = ri ? ri.iterator : t, Bi = ri ? ri.toStringTag : t, Ha = function() {
        try {
          var a = Vi(Ze, "defineProperty");
          return a({}, "", {}), a;
        } catch {
        }
      }(), f_ = V.clearTimeout !== Ft.clearTimeout && V.clearTimeout, p_ = te && te.now !== Ft.Date.now && te.now, h_ = V.setTimeout !== Ft.setTimeout && V.setTimeout, Wa = Dt.ceil, Ua = Dt.floor, sc = Ze.getOwnPropertySymbols, m_ = La ? La.isBuffer : t, Qp = V.isFinite, g_ = Ra.join, v_ = qp(Ze.keys, Ze), Ct = Dt.max, zt = Dt.min, y_ = te.now, b_ = V.parseInt, eh = Dt.random, __ = Ra.reverse, oc = Vi(V, "DataView"), To = Vi(V, "Map"), ac = Vi(V, "Promise"), Ss = Vi(V, "Set"), Mo = Vi(V, "WeakMap"), Oo = Vi(Ze, "create"), ja = Mo && new Mo(), As = {}, w_ = Hi(oc), D_ = Hi(To), C_ = Hi(ac), x_ = Hi(Ss), k_ = Hi(Mo), qa = ri ? ri.prototype : t, Fo = qa ? qa.valueOf : t, th = qa ? qa.toString : t;
      function D(a) {
        if (ut(a) && !xe(a) && !(a instanceof Ne)) {
          if (a instanceof Ln)
            return a;
          if (qe.call(a, "__wrapped__"))
            return nm(a);
        }
        return new Ln(a);
      }
      var Es = function() {
        function a() {
        }
        return function(c) {
          if (!at(c))
            return {};
          if (Yp)
            return Yp(c);
          a.prototype = c;
          var p = new a();
          return a.prototype = t, p;
        };
      }();
      function Ka() {
      }
      function Ln(a, c) {
        this.__wrapped__ = a, this.__actions__ = [], this.__chain__ = !!c, this.__index__ = 0, this.__values__ = t;
      }
      D.templateSettings = {
        escape: ys,
        evaluate: Qr,
        interpolate: Aa,
        variable: "",
        imports: {
          _: D
        }
      }, D.prototype = Ka.prototype, D.prototype.constructor = D, Ln.prototype = Es(Ka.prototype), Ln.prototype.constructor = Ln;
      function Ne(a) {
        this.__wrapped__ = a, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = je, this.__views__ = [];
      }
      function S_() {
        var a = new Ne(this.__wrapped__);
        return a.__actions__ = cn(this.__actions__), a.__dir__ = this.__dir__, a.__filtered__ = this.__filtered__, a.__iteratees__ = cn(this.__iteratees__), a.__takeCount__ = this.__takeCount__, a.__views__ = cn(this.__views__), a;
      }
      function A_() {
        if (this.__filtered__) {
          var a = new Ne(this);
          a.__dir__ = -1, a.__filtered__ = !0;
        } else
          a = this.clone(), a.__dir__ *= -1;
        return a;
      }
      function E_() {
        var a = this.__wrapped__.value(), c = this.__dir__, p = xe(a), v = c < 0, _ = p ? a.length : 0, x = zw(0, _, this.__views__), A = x.start, M = x.end, B = M - A, H = v ? M : A - 1, W = this.__iteratees__, j = W.length, Q = 0, le = zt(B, this.__takeCount__);
        if (!p || !v && _ == B && le == B)
          return kh(a, this.__actions__);
        var ye = [];
        e:
          for (; B-- && Q < le; ) {
            H += c;
            for (var Me = -1, be = a[H]; ++Me < j; ) {
              var Ie = W[Me], $e = Ie.iteratee, xn = Ie.type, en = $e(be);
              if (xn == Qe)
                be = en;
              else if (!en) {
                if (xn == rt)
                  continue e;
                break e;
              }
            }
            ye[Q++] = be;
          }
        return ye;
      }
      Ne.prototype = Es(Ka.prototype), Ne.prototype.constructor = Ne;
      function $i(a) {
        var c = -1, p = a == null ? 0 : a.length;
        for (this.clear(); ++c < p; ) {
          var v = a[c];
          this.set(v[0], v[1]);
        }
      }
      function T_() {
        this.__data__ = Oo ? Oo(null) : {}, this.size = 0;
      }
      function M_(a) {
        var c = this.has(a) && delete this.__data__[a];
        return this.size -= c ? 1 : 0, c;
      }
      function O_(a) {
        var c = this.__data__;
        if (Oo) {
          var p = c[a];
          return p === u ? t : p;
        }
        return qe.call(c, a) ? c[a] : t;
      }
      function F_(a) {
        var c = this.__data__;
        return Oo ? c[a] !== t : qe.call(c, a);
      }
      function I_(a, c) {
        var p = this.__data__;
        return this.size += this.has(a) ? 0 : 1, p[a] = Oo && c === t ? u : c, this;
      }
      $i.prototype.clear = T_, $i.prototype.delete = M_, $i.prototype.get = O_, $i.prototype.has = F_, $i.prototype.set = I_;
      function Br(a) {
        var c = -1, p = a == null ? 0 : a.length;
        for (this.clear(); ++c < p; ) {
          var v = a[c];
          this.set(v[0], v[1]);
        }
      }
      function R_() {
        this.__data__ = [], this.size = 0;
      }
      function N_(a) {
        var c = this.__data__, p = Ga(c, a);
        if (p < 0)
          return !1;
        var v = c.length - 1;
        return p == v ? c.pop() : Va.call(c, p, 1), --this.size, !0;
      }
      function B_(a) {
        var c = this.__data__, p = Ga(c, a);
        return p < 0 ? t : c[p][1];
      }
      function $_(a) {
        return Ga(this.__data__, a) > -1;
      }
      function L_(a, c) {
        var p = this.__data__, v = Ga(p, a);
        return v < 0 ? (++this.size, p.push([a, c])) : p[v][1] = c, this;
      }
      Br.prototype.clear = R_, Br.prototype.delete = N_, Br.prototype.get = B_, Br.prototype.has = $_, Br.prototype.set = L_;
      function $r(a) {
        var c = -1, p = a == null ? 0 : a.length;
        for (this.clear(); ++c < p; ) {
          var v = a[c];
          this.set(v[0], v[1]);
        }
      }
      function P_() {
        this.size = 0, this.__data__ = {
          hash: new $i(),
          map: new (To || Br)(),
          string: new $i()
        };
      }
      function z_(a) {
        var c = ol(this, a).delete(a);
        return this.size -= c ? 1 : 0, c;
      }
      function V_(a) {
        return ol(this, a).get(a);
      }
      function H_(a) {
        return ol(this, a).has(a);
      }
      function W_(a, c) {
        var p = ol(this, a), v = p.size;
        return p.set(a, c), this.size += p.size == v ? 0 : 1, this;
      }
      $r.prototype.clear = P_, $r.prototype.delete = z_, $r.prototype.get = V_, $r.prototype.has = H_, $r.prototype.set = W_;
      function Li(a) {
        var c = -1, p = a == null ? 0 : a.length;
        for (this.__data__ = new $r(); ++c < p; )
          this.add(a[c]);
      }
      function U_(a) {
        return this.__data__.set(a, u), this;
      }
      function j_(a) {
        return this.__data__.has(a);
      }
      Li.prototype.add = Li.prototype.push = U_, Li.prototype.has = j_;
      function ir(a) {
        var c = this.__data__ = new Br(a);
        this.size = c.size;
      }
      function q_() {
        this.__data__ = new Br(), this.size = 0;
      }
      function K_(a) {
        var c = this.__data__, p = c.delete(a);
        return this.size = c.size, p;
      }
      function G_(a) {
        return this.__data__.get(a);
      }
      function J_(a) {
        return this.__data__.has(a);
      }
      function Y_(a, c) {
        var p = this.__data__;
        if (p instanceof Br) {
          var v = p.__data__;
          if (!To || v.length < i - 1)
            return v.push([a, c]), this.size = ++p.size, this;
          p = this.__data__ = new $r(v);
        }
        return p.set(a, c), this.size = p.size, this;
      }
      ir.prototype.clear = q_, ir.prototype.delete = K_, ir.prototype.get = G_, ir.prototype.has = J_, ir.prototype.set = Y_;
      function nh(a, c) {
        var p = xe(a), v = !p && Wi(a), _ = !p && !v && li(a), x = !p && !v && !_ && Fs(a), A = p || v || _ || x, M = A ? tc(a.length, o_) : [], B = M.length;
        for (var H in a)
          (c || qe.call(a, H)) && !(A && (H == "length" || _ && (H == "offset" || H == "parent") || x && (H == "buffer" || H == "byteLength" || H == "byteOffset") || Vr(H, B))) && M.push(H);
        return M;
      }
      function rh(a) {
        var c = a.length;
        return c ? a[yc(0, c - 1)] : t;
      }
      function X_(a, c) {
        return al(cn(a), Pi(c, 0, a.length));
      }
      function Z_(a) {
        return al(cn(a));
      }
      function lc(a, c, p) {
        (p !== t && !sr(a[c], p) || p === t && !(c in a)) && Lr(a, c, p);
      }
      function Io(a, c, p) {
        var v = a[c];
        (!(qe.call(a, c) && sr(v, p)) || p === t && !(c in a)) && Lr(a, c, p);
      }
      function Ga(a, c) {
        for (var p = a.length; p--; )
          if (sr(a[p][0], c))
            return p;
        return -1;
      }
      function Q_(a, c, p, v) {
        return ii(a, function(_, x, A) {
          c(v, _, p(_), A);
        }), v;
      }
      function ih(a, c) {
        return a && wr(c, St(c), a);
      }
      function ew(a, c) {
        return a && wr(c, fn(c), a);
      }
      function Lr(a, c, p) {
        c == "__proto__" && Ha ? Ha(a, c, {
          configurable: !0,
          enumerable: !0,
          value: p,
          writable: !0
        }) : a[c] = p;
      }
      function uc(a, c) {
        for (var p = -1, v = c.length, _ = $(v), x = a == null; ++p < v; )
          _[p] = x ? t : Wc(a, c[p]);
        return _;
      }
      function Pi(a, c, p) {
        return a === a && (p !== t && (a = a <= p ? a : p), c !== t && (a = a >= c ? a : c)), a;
      }
      function Pn(a, c, p, v, _, x) {
        var A, M = c & h, B = c & m, H = c & g;
        if (p && (A = _ ? p(a, v, _, x) : p(a)), A !== t)
          return A;
        if (!at(a))
          return a;
        var W = xe(a);
        if (W) {
          if (A = Hw(a), !M)
            return cn(a, A);
        } else {
          var j = Vt(a), Q = j == er || j == In;
          if (li(a))
            return Eh(a, M);
          if (j == Yt || j == st || Q && !_) {
            if (A = B || Q ? {} : Kh(a), !M)
              return B ? Ow(a, ew(A, a)) : Mw(a, ih(A, a));
          } else {
            if (!et[j])
              return _ ? a : {};
            A = Ww(a, j, M);
          }
        }
        x || (x = new ir());
        var le = x.get(a);
        if (le)
          return le;
        x.set(a, A), Dm(a) ? a.forEach(function(be) {
          A.add(Pn(be, c, p, be, a, x));
        }) : _m(a) && a.forEach(function(be, Ie) {
          A.set(Ie, Pn(be, c, p, Ie, a, x));
        });
        var ye = H ? B ? Tc : Ec : B ? fn : St, Me = W ? t : ye(a);
        return Bn(Me || a, function(be, Ie) {
          Me && (Ie = be, be = a[Ie]), Io(A, Ie, Pn(be, c, p, Ie, a, x));
        }), A;
      }
      function tw(a) {
        var c = St(a);
        return function(p) {
          return sh(p, a, c);
        };
      }
      function sh(a, c, p) {
        var v = p.length;
        if (a == null)
          return !v;
        for (a = Ze(a); v--; ) {
          var _ = p[v], x = c[_], A = a[_];
          if (A === t && !(_ in a) || !x(A))
            return !1;
        }
        return !0;
      }
      function oh(a, c, p) {
        if (typeof a != "function")
          throw new $n(o);
        return zo(function() {
          a.apply(t, p);
        }, c);
      }
      function Ro(a, c, p, v) {
        var _ = -1, x = Oa, A = !0, M = a.length, B = [], H = c.length;
        if (!M)
          return B;
        p && (c = ot(c, wn(p))), v ? (x = Ju, A = !1) : c.length >= i && (x = Ao, A = !1, c = new Li(c));
        e:
          for (; ++_ < M; ) {
            var W = a[_], j = p == null ? W : p(W);
            if (W = v || W !== 0 ? W : 0, A && j === j) {
              for (var Q = H; Q--; )
                if (c[Q] === j)
                  continue e;
              B.push(W);
            } else
              x(c, j, v) || B.push(W);
          }
        return B;
      }
      var ii = Ih(_r), ah = Ih(dc, !0);
      function nw(a, c) {
        var p = !0;
        return ii(a, function(v, _, x) {
          return p = !!c(v, _, x), p;
        }), p;
      }
      function Ja(a, c, p) {
        for (var v = -1, _ = a.length; ++v < _; ) {
          var x = a[v], A = c(x);
          if (A != null && (M === t ? A === A && !Cn(A) : p(A, M)))
            var M = A, B = x;
        }
        return B;
      }
      function rw(a, c, p, v) {
        var _ = a.length;
        for (p = Se(p), p < 0 && (p = -p > _ ? 0 : _ + p), v = v === t || v > _ ? _ : Se(v), v < 0 && (v += _), v = p > v ? 0 : xm(v); p < v; )
          a[p++] = c;
        return a;
      }
      function lh(a, c) {
        var p = [];
        return ii(a, function(v, _, x) {
          c(v, _, x) && p.push(v);
        }), p;
      }
      function It(a, c, p, v, _) {
        var x = -1, A = a.length;
        for (p || (p = jw), _ || (_ = []); ++x < A; ) {
          var M = a[x];
          c > 0 && p(M) ? c > 1 ? It(M, c - 1, p, v, _) : ti(_, M) : v || (_[_.length] = M);
        }
        return _;
      }
      var cc = Rh(), uh = Rh(!0);
      function _r(a, c) {
        return a && cc(a, c, St);
      }
      function dc(a, c) {
        return a && uh(a, c, St);
      }
      function Ya(a, c) {
        return ei(c, function(p) {
          return Hr(a[p]);
        });
      }
      function zi(a, c) {
        c = oi(c, a);
        for (var p = 0, v = c.length; a != null && p < v; )
          a = a[Dr(c[p++])];
        return p && p == v ? a : t;
      }
      function ch(a, c, p) {
        var v = c(a);
        return xe(a) ? v : ti(v, p(a));
      }
      function Zt(a) {
        return a == null ? a === t ? Ri : Fi : Bi && Bi in Ze(a) ? Pw(a) : Zw(a);
      }
      function fc(a, c) {
        return a > c;
      }
      function iw(a, c) {
        return a != null && qe.call(a, c);
      }
      function sw(a, c) {
        return a != null && c in Ze(a);
      }
      function ow(a, c, p) {
        return a >= zt(c, p) && a < Ct(c, p);
      }
      function pc(a, c, p) {
        for (var v = p ? Ju : Oa, _ = a[0].length, x = a.length, A = x, M = $(x), B = 1 / 0, H = []; A--; ) {
          var W = a[A];
          A && c && (W = ot(W, wn(c))), B = zt(W.length, B), M[A] = !p && (c || _ >= 120 && W.length >= 120) ? new Li(A && W) : t;
        }
        W = a[0];
        var j = -1, Q = M[0];
        e:
          for (; ++j < _ && H.length < B; ) {
            var le = W[j], ye = c ? c(le) : le;
            if (le = p || le !== 0 ? le : 0, !(Q ? Ao(Q, ye) : v(H, ye, p))) {
              for (A = x; --A; ) {
                var Me = M[A];
                if (!(Me ? Ao(Me, ye) : v(a[A], ye, p)))
                  continue e;
              }
              Q && Q.push(ye), H.push(le);
            }
          }
        return H;
      }
      function aw(a, c, p, v) {
        return _r(a, function(_, x, A) {
          c(v, p(_), x, A);
        }), v;
      }
      function No(a, c, p) {
        c = oi(c, a), a = Xh(a, c);
        var v = a == null ? a : a[Dr(Vn(c))];
        return v == null ? t : _n(v, a, p);
      }
      function dh(a) {
        return ut(a) && Zt(a) == st;
      }
      function lw(a) {
        return ut(a) && Zt(a) == br;
      }
      function uw(a) {
        return ut(a) && Zt(a) == Jt;
      }
      function Bo(a, c, p, v, _) {
        return a === c ? !0 : a == null || c == null || !ut(a) && !ut(c) ? a !== a && c !== c : cw(a, c, p, v, Bo, _);
      }
      function cw(a, c, p, v, _, x) {
        var A = xe(a), M = xe(c), B = A ? _t : Vt(a), H = M ? _t : Vt(c);
        B = B == st ? Yt : B, H = H == st ? Yt : H;
        var W = B == Yt, j = H == Yt, Q = B == H;
        if (Q && li(a)) {
          if (!li(c))
            return !1;
          A = !0, W = !1;
        }
        if (Q && !W)
          return x || (x = new ir()), A || Fs(a) ? Uh(a, c, p, v, _, x) : $w(a, c, B, p, v, _, x);
        if (!(p & y)) {
          var le = W && qe.call(a, "__wrapped__"), ye = j && qe.call(c, "__wrapped__");
          if (le || ye) {
            var Me = le ? a.value() : a, be = ye ? c.value() : c;
            return x || (x = new ir()), _(Me, be, p, v, x);
          }
        }
        return Q ? (x || (x = new ir()), Lw(a, c, p, v, _, x)) : !1;
      }
      function dw(a) {
        return ut(a) && Vt(a) == Pt;
      }
      function hc(a, c, p, v) {
        var _ = p.length, x = _, A = !v;
        if (a == null)
          return !x;
        for (a = Ze(a); _--; ) {
          var M = p[_];
          if (A && M[2] ? M[1] !== a[M[0]] : !(M[0] in a))
            return !1;
        }
        for (; ++_ < x; ) {
          M = p[_];
          var B = M[0], H = a[B], W = M[1];
          if (A && M[2]) {
            if (H === t && !(B in a))
              return !1;
          } else {
            var j = new ir();
            if (v)
              var Q = v(H, W, B, a, c, j);
            if (!(Q === t ? Bo(W, H, y | b, v, j) : Q))
              return !1;
          }
        }
        return !0;
      }
      function fh(a) {
        if (!at(a) || Kw(a))
          return !1;
        var c = Hr(a) ? d_ : t1;
        return c.test(Hi(a));
      }
      function fw(a) {
        return ut(a) && Zt(a) == Xt;
      }
      function pw(a) {
        return ut(a) && Vt(a) == vt;
      }
      function hw(a) {
        return ut(a) && pl(a.length) && !!tt[Zt(a)];
      }
      function ph(a) {
        return typeof a == "function" ? a : a == null ? pn : typeof a == "object" ? xe(a) ? gh(a[0], a[1]) : mh(a) : Nm(a);
      }
      function mc(a) {
        if (!Po(a))
          return v_(a);
        var c = [];
        for (var p in Ze(a))
          qe.call(a, p) && p != "constructor" && c.push(p);
        return c;
      }
      function mw(a) {
        if (!at(a))
          return Xw(a);
        var c = Po(a), p = [];
        for (var v in a)
          v == "constructor" && (c || !qe.call(a, v)) || p.push(v);
        return p;
      }
      function gc(a, c) {
        return a < c;
      }
      function hh(a, c) {
        var p = -1, v = dn(a) ? $(a.length) : [];
        return ii(a, function(_, x, A) {
          v[++p] = c(_, x, A);
        }), v;
      }
      function mh(a) {
        var c = Oc(a);
        return c.length == 1 && c[0][2] ? Jh(c[0][0], c[0][1]) : function(p) {
          return p === a || hc(p, a, c);
        };
      }
      function gh(a, c) {
        return Ic(a) && Gh(c) ? Jh(Dr(a), c) : function(p) {
          var v = Wc(p, a);
          return v === t && v === c ? Uc(p, a) : Bo(c, v, y | b);
        };
      }
      function Xa(a, c, p, v, _) {
        a !== c && cc(c, function(x, A) {
          if (_ || (_ = new ir()), at(x))
            gw(a, c, A, p, Xa, v, _);
          else {
            var M = v ? v(Nc(a, A), x, A + "", a, c, _) : t;
            M === t && (M = x), lc(a, A, M);
          }
        }, fn);
      }
      function gw(a, c, p, v, _, x, A) {
        var M = Nc(a, p), B = Nc(c, p), H = A.get(B);
        if (H) {
          lc(a, p, H);
          return;
        }
        var W = x ? x(M, B, p + "", a, c, A) : t, j = W === t;
        if (j) {
          var Q = xe(B), le = !Q && li(B), ye = !Q && !le && Fs(B);
          W = B, Q || le || ye ? xe(M) ? W = M : pt(M) ? W = cn(M) : le ? (j = !1, W = Eh(B, !0)) : ye ? (j = !1, W = Th(B, !0)) : W = [] : Vo(B) || Wi(B) ? (W = M, Wi(M) ? W = km(M) : (!at(M) || Hr(M)) && (W = Kh(B))) : j = !1;
        }
        j && (A.set(B, W), _(W, B, v, x, A), A.delete(B)), lc(a, p, W);
      }
      function vh(a, c) {
        var p = a.length;
        if (p)
          return c += c < 0 ? p : 0, Vr(c, p) ? a[c] : t;
      }
      function yh(a, c, p) {
        c.length ? c = ot(c, function(x) {
          return xe(x) ? function(A) {
            return zi(A, x.length === 1 ? x[0] : x);
          } : x;
        }) : c = [pn];
        var v = -1;
        c = ot(c, wn(he()));
        var _ = hh(a, function(x, A, M) {
          var B = ot(c, function(H) {
            return H(x);
          });
          return { criteria: B, index: ++v, value: x };
        });
        return W1(_, function(x, A) {
          return Tw(x, A, p);
        });
      }
      function vw(a, c) {
        return bh(a, c, function(p, v) {
          return Uc(a, v);
        });
      }
      function bh(a, c, p) {
        for (var v = -1, _ = c.length, x = {}; ++v < _; ) {
          var A = c[v], M = zi(a, A);
          p(M, A) && $o(x, oi(A, a), M);
        }
        return x;
      }
      function yw(a) {
        return function(c) {
          return zi(c, a);
        };
      }
      function vc(a, c, p, v) {
        var _ = v ? H1 : ws, x = -1, A = c.length, M = a;
        for (a === c && (c = cn(c)), p && (M = ot(a, wn(p))); ++x < A; )
          for (var B = 0, H = c[x], W = p ? p(H) : H; (B = _(M, W, B, v)) > -1; )
            M !== a && Va.call(M, B, 1), Va.call(a, B, 1);
        return a;
      }
      function _h(a, c) {
        for (var p = a ? c.length : 0, v = p - 1; p--; ) {
          var _ = c[p];
          if (p == v || _ !== x) {
            var x = _;
            Vr(_) ? Va.call(a, _, 1) : wc(a, _);
          }
        }
        return a;
      }
      function yc(a, c) {
        return a + Ua(eh() * (c - a + 1));
      }
      function bw(a, c, p, v) {
        for (var _ = -1, x = Ct(Wa((c - a) / (p || 1)), 0), A = $(x); x--; )
          A[v ? x : ++_] = a, a += p;
        return A;
      }
      function bc(a, c) {
        var p = "";
        if (!a || c < 1 || c > De)
          return p;
        do
          c % 2 && (p += a), c = Ua(c / 2), c && (a += a);
        while (c);
        return p;
      }
      function Fe(a, c) {
        return Bc(Yh(a, c, pn), a + "");
      }
      function _w(a) {
        return rh(Is(a));
      }
      function ww(a, c) {
        var p = Is(a);
        return al(p, Pi(c, 0, p.length));
      }
      function $o(a, c, p, v) {
        if (!at(a))
          return a;
        c = oi(c, a);
        for (var _ = -1, x = c.length, A = x - 1, M = a; M != null && ++_ < x; ) {
          var B = Dr(c[_]), H = p;
          if (B === "__proto__" || B === "constructor" || B === "prototype")
            return a;
          if (_ != A) {
            var W = M[B];
            H = v ? v(W, B, M) : t, H === t && (H = at(W) ? W : Vr(c[_ + 1]) ? [] : {});
          }
          Io(M, B, H), M = M[B];
        }
        return a;
      }
      var wh = ja ? function(a, c) {
        return ja.set(a, c), a;
      } : pn, Dw = Ha ? function(a, c) {
        return Ha(a, "toString", {
          configurable: !0,
          enumerable: !1,
          value: qc(c),
          writable: !0
        });
      } : pn;
      function Cw(a) {
        return al(Is(a));
      }
      function zn(a, c, p) {
        var v = -1, _ = a.length;
        c < 0 && (c = -c > _ ? 0 : _ + c), p = p > _ ? _ : p, p < 0 && (p += _), _ = c > p ? 0 : p - c >>> 0, c >>>= 0;
        for (var x = $(_); ++v < _; )
          x[v] = a[v + c];
        return x;
      }
      function xw(a, c) {
        var p;
        return ii(a, function(v, _, x) {
          return p = c(v, _, x), !p;
        }), !!p;
      }
      function Za(a, c, p) {
        var v = 0, _ = a == null ? v : a.length;
        if (typeof c == "number" && c === c && _ <= Qn) {
          for (; v < _; ) {
            var x = v + _ >>> 1, A = a[x];
            A !== null && !Cn(A) && (p ? A <= c : A < c) ? v = x + 1 : _ = x;
          }
          return _;
        }
        return _c(a, c, pn, p);
      }
      function _c(a, c, p, v) {
        var _ = 0, x = a == null ? 0 : a.length;
        if (x === 0)
          return 0;
        c = p(c);
        for (var A = c !== c, M = c === null, B = Cn(c), H = c === t; _ < x; ) {
          var W = Ua((_ + x) / 2), j = p(a[W]), Q = j !== t, le = j === null, ye = j === j, Me = Cn(j);
          if (A)
            var be = v || ye;
          else
            H ? be = ye && (v || Q) : M ? be = ye && Q && (v || !le) : B ? be = ye && Q && !le && (v || !Me) : le || Me ? be = !1 : be = v ? j <= c : j < c;
          be ? _ = W + 1 : x = W;
        }
        return zt(x, it);
      }
      function Dh(a, c) {
        for (var p = -1, v = a.length, _ = 0, x = []; ++p < v; ) {
          var A = a[p], M = c ? c(A) : A;
          if (!p || !sr(M, B)) {
            var B = M;
            x[_++] = A === 0 ? 0 : A;
          }
        }
        return x;
      }
      function Ch(a) {
        return typeof a == "number" ? a : Cn(a) ? Oe : +a;
      }
      function Dn(a) {
        if (typeof a == "string")
          return a;
        if (xe(a))
          return ot(a, Dn) + "";
        if (Cn(a))
          return th ? th.call(a) : "";
        var c = a + "";
        return c == "0" && 1 / a == -He ? "-0" : c;
      }
      function si(a, c, p) {
        var v = -1, _ = Oa, x = a.length, A = !0, M = [], B = M;
        if (p)
          A = !1, _ = Ju;
        else if (x >= i) {
          var H = c ? null : Nw(a);
          if (H)
            return Ia(H);
          A = !1, _ = Ao, B = new Li();
        } else
          B = c ? [] : M;
        e:
          for (; ++v < x; ) {
            var W = a[v], j = c ? c(W) : W;
            if (W = p || W !== 0 ? W : 0, A && j === j) {
              for (var Q = B.length; Q--; )
                if (B[Q] === j)
                  continue e;
              c && B.push(j), M.push(W);
            } else
              _(B, j, p) || (B !== M && B.push(j), M.push(W));
          }
        return M;
      }
      function wc(a, c) {
        return c = oi(c, a), a = Xh(a, c), a == null || delete a[Dr(Vn(c))];
      }
      function xh(a, c, p, v) {
        return $o(a, c, p(zi(a, c)), v);
      }
      function Qa(a, c, p, v) {
        for (var _ = a.length, x = v ? _ : -1; (v ? x-- : ++x < _) && c(a[x], x, a); )
          ;
        return p ? zn(a, v ? 0 : x, v ? x + 1 : _) : zn(a, v ? x + 1 : 0, v ? _ : x);
      }
      function kh(a, c) {
        var p = a;
        return p instanceof Ne && (p = p.value()), Yu(c, function(v, _) {
          return _.func.apply(_.thisArg, ti([v], _.args));
        }, p);
      }
      function Dc(a, c, p) {
        var v = a.length;
        if (v < 2)
          return v ? si(a[0]) : [];
        for (var _ = -1, x = $(v); ++_ < v; )
          for (var A = a[_], M = -1; ++M < v; )
            M != _ && (x[_] = Ro(x[_] || A, a[M], c, p));
        return si(It(x, 1), c, p);
      }
      function Sh(a, c, p) {
        for (var v = -1, _ = a.length, x = c.length, A = {}; ++v < _; ) {
          var M = v < x ? c[v] : t;
          p(A, a[v], M);
        }
        return A;
      }
      function Cc(a) {
        return pt(a) ? a : [];
      }
      function xc(a) {
        return typeof a == "function" ? a : pn;
      }
      function oi(a, c) {
        return xe(a) ? a : Ic(a, c) ? [a] : tm(We(a));
      }
      var kw = Fe;
      function ai(a, c, p) {
        var v = a.length;
        return p = p === t ? v : p, !c && p >= v ? a : zn(a, c, p);
      }
      var Ah = f_ || function(a) {
        return Ft.clearTimeout(a);
      };
      function Eh(a, c) {
        if (c)
          return a.slice();
        var p = a.length, v = Jp ? Jp(p) : new a.constructor(p);
        return a.copy(v), v;
      }
      function kc(a) {
        var c = new a.constructor(a.byteLength);
        return new Pa(c).set(new Pa(a)), c;
      }
      function Sw(a, c) {
        var p = c ? kc(a.buffer) : a.buffer;
        return new a.constructor(p, a.byteOffset, a.byteLength);
      }
      function Aw(a) {
        var c = new a.constructor(a.source, dp.exec(a));
        return c.lastIndex = a.lastIndex, c;
      }
      function Ew(a) {
        return Fo ? Ze(Fo.call(a)) : {};
      }
      function Th(a, c) {
        var p = c ? kc(a.buffer) : a.buffer;
        return new a.constructor(p, a.byteOffset, a.length);
      }
      function Mh(a, c) {
        if (a !== c) {
          var p = a !== t, v = a === null, _ = a === a, x = Cn(a), A = c !== t, M = c === null, B = c === c, H = Cn(c);
          if (!M && !H && !x && a > c || x && A && B && !M && !H || v && A && B || !p && B || !_)
            return 1;
          if (!v && !x && !H && a < c || H && p && _ && !v && !x || M && p && _ || !A && _ || !B)
            return -1;
        }
        return 0;
      }
      function Tw(a, c, p) {
        for (var v = -1, _ = a.criteria, x = c.criteria, A = _.length, M = p.length; ++v < A; ) {
          var B = Mh(_[v], x[v]);
          if (B) {
            if (v >= M)
              return B;
            var H = p[v];
            return B * (H == "desc" ? -1 : 1);
          }
        }
        return a.index - c.index;
      }
      function Oh(a, c, p, v) {
        for (var _ = -1, x = a.length, A = p.length, M = -1, B = c.length, H = Ct(x - A, 0), W = $(B + H), j = !v; ++M < B; )
          W[M] = c[M];
        for (; ++_ < A; )
          (j || _ < x) && (W[p[_]] = a[_]);
        for (; H--; )
          W[M++] = a[_++];
        return W;
      }
      function Fh(a, c, p, v) {
        for (var _ = -1, x = a.length, A = -1, M = p.length, B = -1, H = c.length, W = Ct(x - M, 0), j = $(W + H), Q = !v; ++_ < W; )
          j[_] = a[_];
        for (var le = _; ++B < H; )
          j[le + B] = c[B];
        for (; ++A < M; )
          (Q || _ < x) && (j[le + p[A]] = a[_++]);
        return j;
      }
      function cn(a, c) {
        var p = -1, v = a.length;
        for (c || (c = $(v)); ++p < v; )
          c[p] = a[p];
        return c;
      }
      function wr(a, c, p, v) {
        var _ = !p;
        p || (p = {});
        for (var x = -1, A = c.length; ++x < A; ) {
          var M = c[x], B = v ? v(p[M], a[M], M, p, a) : t;
          B === t && (B = a[M]), _ ? Lr(p, M, B) : Io(p, M, B);
        }
        return p;
      }
      function Mw(a, c) {
        return wr(a, Fc(a), c);
      }
      function Ow(a, c) {
        return wr(a, jh(a), c);
      }
      function el(a, c) {
        return function(p, v) {
          var _ = xe(p) ? B1 : Q_, x = c ? c() : {};
          return _(p, a, he(v, 2), x);
        };
      }
      function Ts(a) {
        return Fe(function(c, p) {
          var v = -1, _ = p.length, x = _ > 1 ? p[_ - 1] : t, A = _ > 2 ? p[2] : t;
          for (x = a.length > 3 && typeof x == "function" ? (_--, x) : t, A && Qt(p[0], p[1], A) && (x = _ < 3 ? t : x, _ = 1), c = Ze(c); ++v < _; ) {
            var M = p[v];
            M && a(c, M, v, x);
          }
          return c;
        });
      }
      function Ih(a, c) {
        return function(p, v) {
          if (p == null)
            return p;
          if (!dn(p))
            return a(p, v);
          for (var _ = p.length, x = c ? _ : -1, A = Ze(p); (c ? x-- : ++x < _) && v(A[x], x, A) !== !1; )
            ;
          return p;
        };
      }
      function Rh(a) {
        return function(c, p, v) {
          for (var _ = -1, x = Ze(c), A = v(c), M = A.length; M--; ) {
            var B = A[a ? M : ++_];
            if (p(x[B], B, x) === !1)
              break;
          }
          return c;
        };
      }
      function Fw(a, c, p) {
        var v = c & w, _ = Lo(a);
        function x() {
          var A = this && this !== Ft && this instanceof x ? _ : a;
          return A.apply(v ? p : this, arguments);
        }
        return x;
      }
      function Nh(a) {
        return function(c) {
          c = We(c);
          var p = Ds(c) ? rr(c) : t, v = p ? p[0] : c.charAt(0), _ = p ? ai(p, 1).join("") : c.slice(1);
          return v[a]() + _;
        };
      }
      function Ms(a) {
        return function(c) {
          return Yu(Im(Fm(c).replace(D1, "")), a, "");
        };
      }
      function Lo(a) {
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return new a();
            case 1:
              return new a(c[0]);
            case 2:
              return new a(c[0], c[1]);
            case 3:
              return new a(c[0], c[1], c[2]);
            case 4:
              return new a(c[0], c[1], c[2], c[3]);
            case 5:
              return new a(c[0], c[1], c[2], c[3], c[4]);
            case 6:
              return new a(c[0], c[1], c[2], c[3], c[4], c[5]);
            case 7:
              return new a(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
          }
          var p = Es(a.prototype), v = a.apply(p, c);
          return at(v) ? v : p;
        };
      }
      function Iw(a, c, p) {
        var v = Lo(a);
        function _() {
          for (var x = arguments.length, A = $(x), M = x, B = Os(_); M--; )
            A[M] = arguments[M];
          var H = x < 3 && A[0] !== B && A[x - 1] !== B ? [] : ni(A, B);
          if (x -= H.length, x < p)
            return zh(
              a,
              c,
              tl,
              _.placeholder,
              t,
              A,
              H,
              t,
              t,
              p - x
            );
          var W = this && this !== Ft && this instanceof _ ? v : a;
          return _n(W, this, A);
        }
        return _;
      }
      function Bh(a) {
        return function(c, p, v) {
          var _ = Ze(c);
          if (!dn(c)) {
            var x = he(p, 3);
            c = St(c), p = function(M) {
              return x(_[M], M, _);
            };
          }
          var A = a(c, p, v);
          return A > -1 ? _[x ? c[A] : A] : t;
        };
      }
      function $h(a) {
        return zr(function(c) {
          var p = c.length, v = p, _ = Ln.prototype.thru;
          for (a && c.reverse(); v--; ) {
            var x = c[v];
            if (typeof x != "function")
              throw new $n(o);
            if (_ && !A && sl(x) == "wrapper")
              var A = new Ln([], !0);
          }
          for (v = A ? v : p; ++v < p; ) {
            x = c[v];
            var M = sl(x), B = M == "wrapper" ? Mc(x) : t;
            B && Rc(B[0]) && B[1] == (P | S | R | L) && !B[4].length && B[9] == 1 ? A = A[sl(B[0])].apply(A, B[3]) : A = x.length == 1 && Rc(x) ? A[M]() : A.thru(x);
          }
          return function() {
            var H = arguments, W = H[0];
            if (A && H.length == 1 && xe(W))
              return A.plant(W).value();
            for (var j = 0, Q = p ? c[j].apply(this, H) : W; ++j < p; )
              Q = c[j].call(this, Q);
            return Q;
          };
        });
      }
      function tl(a, c, p, v, _, x, A, M, B, H) {
        var W = c & P, j = c & w, Q = c & T, le = c & (S | C), ye = c & q, Me = Q ? t : Lo(a);
        function be() {
          for (var Ie = arguments.length, $e = $(Ie), xn = Ie; xn--; )
            $e[xn] = arguments[xn];
          if (le)
            var en = Os(be), kn = j1($e, en);
          if (v && ($e = Oh($e, v, _, le)), x && ($e = Fh($e, x, A, le)), Ie -= kn, le && Ie < H) {
            var ht = ni($e, en);
            return zh(
              a,
              c,
              tl,
              be.placeholder,
              p,
              $e,
              ht,
              M,
              B,
              H - Ie
            );
          }
          var or = j ? p : this, Ur = Q ? or[a] : a;
          return Ie = $e.length, M ? $e = Qw($e, M) : ye && Ie > 1 && $e.reverse(), W && B < Ie && ($e.length = B), this && this !== Ft && this instanceof be && (Ur = Me || Lo(Ur)), Ur.apply(or, $e);
        }
        return be;
      }
      function Lh(a, c) {
        return function(p, v) {
          return aw(p, a, c(v), {});
        };
      }
      function nl(a, c) {
        return function(p, v) {
          var _;
          if (p === t && v === t)
            return c;
          if (p !== t && (_ = p), v !== t) {
            if (_ === t)
              return v;
            typeof p == "string" || typeof v == "string" ? (p = Dn(p), v = Dn(v)) : (p = Ch(p), v = Ch(v)), _ = a(p, v);
          }
          return _;
        };
      }
      function Sc(a) {
        return zr(function(c) {
          return c = ot(c, wn(he())), Fe(function(p) {
            var v = this;
            return a(c, function(_) {
              return _n(_, v, p);
            });
          });
        });
      }
      function rl(a, c) {
        c = c === t ? " " : Dn(c);
        var p = c.length;
        if (p < 2)
          return p ? bc(c, a) : c;
        var v = bc(c, Wa(a / Cs(c)));
        return Ds(c) ? ai(rr(v), 0, a).join("") : v.slice(0, a);
      }
      function Rw(a, c, p, v) {
        var _ = c & w, x = Lo(a);
        function A() {
          for (var M = -1, B = arguments.length, H = -1, W = v.length, j = $(W + B), Q = this && this !== Ft && this instanceof A ? x : a; ++H < W; )
            j[H] = v[H];
          for (; B--; )
            j[H++] = arguments[++M];
          return _n(Q, _ ? p : this, j);
        }
        return A;
      }
      function Ph(a) {
        return function(c, p, v) {
          return v && typeof v != "number" && Qt(c, p, v) && (p = v = t), c = Wr(c), p === t ? (p = c, c = 0) : p = Wr(p), v = v === t ? c < p ? 1 : -1 : Wr(v), bw(c, p, v, a);
        };
      }
      function il(a) {
        return function(c, p) {
          return typeof c == "string" && typeof p == "string" || (c = Hn(c), p = Hn(p)), a(c, p);
        };
      }
      function zh(a, c, p, v, _, x, A, M, B, H) {
        var W = c & S, j = W ? A : t, Q = W ? t : A, le = W ? x : t, ye = W ? t : x;
        c |= W ? R : I, c &= ~(W ? I : R), c & k || (c &= ~(w | T));
        var Me = [
          a,
          c,
          _,
          le,
          j,
          ye,
          Q,
          M,
          B,
          H
        ], be = p.apply(t, Me);
        return Rc(a) && Zh(be, Me), be.placeholder = v, Qh(be, a, c);
      }
      function Ac(a) {
        var c = Dt[a];
        return function(p, v) {
          if (p = Hn(p), v = v == null ? 0 : zt(Se(v), 292), v && Qp(p)) {
            var _ = (We(p) + "e").split("e"), x = c(_[0] + "e" + (+_[1] + v));
            return _ = (We(x) + "e").split("e"), +(_[0] + "e" + (+_[1] - v));
          }
          return c(p);
        };
      }
      var Nw = Ss && 1 / Ia(new Ss([, -0]))[1] == He ? function(a) {
        return new Ss(a);
      } : Jc;
      function Vh(a) {
        return function(c) {
          var p = Vt(c);
          return p == Pt ? rc(c) : p == vt ? Z1(c) : U1(c, a(c));
        };
      }
      function Pr(a, c, p, v, _, x, A, M) {
        var B = c & T;
        if (!B && typeof a != "function")
          throw new $n(o);
        var H = v ? v.length : 0;
        if (H || (c &= ~(R | I), v = _ = t), A = A === t ? A : Ct(Se(A), 0), M = M === t ? M : Se(M), H -= _ ? _.length : 0, c & I) {
          var W = v, j = _;
          v = _ = t;
        }
        var Q = B ? t : Mc(a), le = [
          a,
          c,
          p,
          v,
          _,
          W,
          j,
          x,
          A,
          M
        ];
        if (Q && Yw(le, Q), a = le[0], c = le[1], p = le[2], v = le[3], _ = le[4], M = le[9] = le[9] === t ? B ? 0 : a.length : Ct(le[9] - H, 0), !M && c & (S | C) && (c &= ~(S | C)), !c || c == w)
          var ye = Fw(a, c, p);
        else
          c == S || c == C ? ye = Iw(a, c, M) : (c == R || c == (w | R)) && !_.length ? ye = Rw(a, c, p, v) : ye = tl.apply(t, le);
        var Me = Q ? wh : Zh;
        return Qh(Me(ye, le), a, c);
      }
      function Hh(a, c, p, v) {
        return a === t || sr(a, ks[p]) && !qe.call(v, p) ? c : a;
      }
      function Wh(a, c, p, v, _, x) {
        return at(a) && at(c) && (x.set(c, a), Xa(a, c, t, Wh, x), x.delete(c)), a;
      }
      function Bw(a) {
        return Vo(a) ? t : a;
      }
      function Uh(a, c, p, v, _, x) {
        var A = p & y, M = a.length, B = c.length;
        if (M != B && !(A && B > M))
          return !1;
        var H = x.get(a), W = x.get(c);
        if (H && W)
          return H == c && W == a;
        var j = -1, Q = !0, le = p & b ? new Li() : t;
        for (x.set(a, c), x.set(c, a); ++j < M; ) {
          var ye = a[j], Me = c[j];
          if (v)
            var be = A ? v(Me, ye, j, c, a, x) : v(ye, Me, j, a, c, x);
          if (be !== t) {
            if (be)
              continue;
            Q = !1;
            break;
          }
          if (le) {
            if (!Xu(c, function(Ie, $e) {
              if (!Ao(le, $e) && (ye === Ie || _(ye, Ie, p, v, x)))
                return le.push($e);
            })) {
              Q = !1;
              break;
            }
          } else if (!(ye === Me || _(ye, Me, p, v, x))) {
            Q = !1;
            break;
          }
        }
        return x.delete(a), x.delete(c), Q;
      }
      function $w(a, c, p, v, _, x, A) {
        switch (p) {
          case nr:
            if (a.byteLength != c.byteLength || a.byteOffset != c.byteOffset)
              return !1;
            a = a.buffer, c = c.buffer;
          case br:
            return !(a.byteLength != c.byteLength || !x(new Pa(a), new Pa(c)));
          case wt:
          case Jt:
          case vr:
            return sr(+a, +c);
          case Lt:
            return a.name == c.name && a.message == c.message;
          case Xt:
          case tr:
            return a == c + "";
          case Pt:
            var M = rc;
          case vt:
            var B = v & y;
            if (M || (M = Ia), a.size != c.size && !B)
              return !1;
            var H = A.get(a);
            if (H)
              return H == c;
            v |= b, A.set(a, c);
            var W = Uh(M(a), M(c), v, _, x, A);
            return A.delete(a), W;
          case Rn:
            if (Fo)
              return Fo.call(a) == Fo.call(c);
        }
        return !1;
      }
      function Lw(a, c, p, v, _, x) {
        var A = p & y, M = Ec(a), B = M.length, H = Ec(c), W = H.length;
        if (B != W && !A)
          return !1;
        for (var j = B; j--; ) {
          var Q = M[j];
          if (!(A ? Q in c : qe.call(c, Q)))
            return !1;
        }
        var le = x.get(a), ye = x.get(c);
        if (le && ye)
          return le == c && ye == a;
        var Me = !0;
        x.set(a, c), x.set(c, a);
        for (var be = A; ++j < B; ) {
          Q = M[j];
          var Ie = a[Q], $e = c[Q];
          if (v)
            var xn = A ? v($e, Ie, Q, c, a, x) : v(Ie, $e, Q, a, c, x);
          if (!(xn === t ? Ie === $e || _(Ie, $e, p, v, x) : xn)) {
            Me = !1;
            break;
          }
          be || (be = Q == "constructor");
        }
        if (Me && !be) {
          var en = a.constructor, kn = c.constructor;
          en != kn && "constructor" in a && "constructor" in c && !(typeof en == "function" && en instanceof en && typeof kn == "function" && kn instanceof kn) && (Me = !1);
        }
        return x.delete(a), x.delete(c), Me;
      }
      function zr(a) {
        return Bc(Yh(a, t, sm), a + "");
      }
      function Ec(a) {
        return ch(a, St, Fc);
      }
      function Tc(a) {
        return ch(a, fn, jh);
      }
      var Mc = ja ? function(a) {
        return ja.get(a);
      } : Jc;
      function sl(a) {
        for (var c = a.name + "", p = As[c], v = qe.call(As, c) ? p.length : 0; v--; ) {
          var _ = p[v], x = _.func;
          if (x == null || x == a)
            return _.name;
        }
        return c;
      }
      function Os(a) {
        var c = qe.call(D, "placeholder") ? D : a;
        return c.placeholder;
      }
      function he() {
        var a = D.iteratee || Kc;
        return a = a === Kc ? ph : a, arguments.length ? a(arguments[0], arguments[1]) : a;
      }
      function ol(a, c) {
        var p = a.__data__;
        return qw(c) ? p[typeof c == "string" ? "string" : "hash"] : p.map;
      }
      function Oc(a) {
        for (var c = St(a), p = c.length; p--; ) {
          var v = c[p], _ = a[v];
          c[p] = [v, _, Gh(_)];
        }
        return c;
      }
      function Vi(a, c) {
        var p = J1(a, c);
        return fh(p) ? p : t;
      }
      function Pw(a) {
        var c = qe.call(a, Bi), p = a[Bi];
        try {
          a[Bi] = t;
          var v = !0;
        } catch {
        }
        var _ = $a.call(a);
        return v && (c ? a[Bi] = p : delete a[Bi]), _;
      }
      var Fc = sc ? function(a) {
        return a == null ? [] : (a = Ze(a), ei(sc(a), function(c) {
          return Xp.call(a, c);
        }));
      } : Yc, jh = sc ? function(a) {
        for (var c = []; a; )
          ti(c, Fc(a)), a = za(a);
        return c;
      } : Yc, Vt = Zt;
      (oc && Vt(new oc(new ArrayBuffer(1))) != nr || To && Vt(new To()) != Pt || ac && Vt(ac.resolve()) != Ii || Ss && Vt(new Ss()) != vt || Mo && Vt(new Mo()) != yr) && (Vt = function(a) {
        var c = Zt(a), p = c == Yt ? a.constructor : t, v = p ? Hi(p) : "";
        if (v)
          switch (v) {
            case w_:
              return nr;
            case D_:
              return Pt;
            case C_:
              return Ii;
            case x_:
              return vt;
            case k_:
              return yr;
          }
        return c;
      });
      function zw(a, c, p) {
        for (var v = -1, _ = p.length; ++v < _; ) {
          var x = p[v], A = x.size;
          switch (x.type) {
            case "drop":
              a += A;
              break;
            case "dropRight":
              c -= A;
              break;
            case "take":
              c = zt(c, a + A);
              break;
            case "takeRight":
              a = Ct(a, c - A);
              break;
          }
        }
        return { start: a, end: c };
      }
      function Vw(a) {
        var c = a.match(Kb);
        return c ? c[1].split(Gb) : [];
      }
      function qh(a, c, p) {
        c = oi(c, a);
        for (var v = -1, _ = c.length, x = !1; ++v < _; ) {
          var A = Dr(c[v]);
          if (!(x = a != null && p(a, A)))
            break;
          a = a[A];
        }
        return x || ++v != _ ? x : (_ = a == null ? 0 : a.length, !!_ && pl(_) && Vr(A, _) && (xe(a) || Wi(a)));
      }
      function Hw(a) {
        var c = a.length, p = new a.constructor(c);
        return c && typeof a[0] == "string" && qe.call(a, "index") && (p.index = a.index, p.input = a.input), p;
      }
      function Kh(a) {
        return typeof a.constructor == "function" && !Po(a) ? Es(za(a)) : {};
      }
      function Ww(a, c, p) {
        var v = a.constructor;
        switch (c) {
          case br:
            return kc(a);
          case wt:
          case Jt:
            return new v(+a);
          case nr:
            return Sw(a, p);
          case bo:
          case _o:
          case wo:
          case Do:
          case Co:
          case z:
          case ie:
          case pe:
          case Pe:
            return Th(a, p);
          case Pt:
            return new v();
          case vr:
          case tr:
            return new v(a);
          case Xt:
            return Aw(a);
          case vt:
            return new v();
          case Rn:
            return Ew(a);
        }
      }
      function Uw(a, c) {
        var p = c.length;
        if (!p)
          return a;
        var v = p - 1;
        return c[v] = (p > 1 ? "& " : "") + c[v], c = c.join(p > 2 ? ", " : " "), a.replace(qb, `{
/* [wrapped with ` + c + `] */
`);
      }
      function jw(a) {
        return xe(a) || Wi(a) || !!(Zp && a && a[Zp]);
      }
      function Vr(a, c) {
        var p = typeof a;
        return c = c ?? De, !!c && (p == "number" || p != "symbol" && r1.test(a)) && a > -1 && a % 1 == 0 && a < c;
      }
      function Qt(a, c, p) {
        if (!at(p))
          return !1;
        var v = typeof c;
        return (v == "number" ? dn(p) && Vr(c, p.length) : v == "string" && c in p) ? sr(p[c], a) : !1;
      }
      function Ic(a, c) {
        if (xe(a))
          return !1;
        var p = typeof a;
        return p == "number" || p == "symbol" || p == "boolean" || a == null || Cn(a) ? !0 : bs.test(a) || !So.test(a) || c != null && a in Ze(c);
      }
      function qw(a) {
        var c = typeof a;
        return c == "string" || c == "number" || c == "symbol" || c == "boolean" ? a !== "__proto__" : a === null;
      }
      function Rc(a) {
        var c = sl(a), p = D[c];
        if (typeof p != "function" || !(c in Ne.prototype))
          return !1;
        if (a === p)
          return !0;
        var v = Mc(p);
        return !!v && a === v[0];
      }
      function Kw(a) {
        return !!Gp && Gp in a;
      }
      var Gw = Na ? Hr : Xc;
      function Po(a) {
        var c = a && a.constructor, p = typeof c == "function" && c.prototype || ks;
        return a === p;
      }
      function Gh(a) {
        return a === a && !at(a);
      }
      function Jh(a, c) {
        return function(p) {
          return p == null ? !1 : p[a] === c && (c !== t || a in Ze(p));
        };
      }
      function Jw(a) {
        var c = dl(a, function(v) {
          return p.size === d && p.clear(), v;
        }), p = c.cache;
        return c;
      }
      function Yw(a, c) {
        var p = a[1], v = c[1], _ = p | v, x = _ < (w | T | P), A = v == P && p == S || v == P && p == L && a[7].length <= c[8] || v == (P | L) && c[7].length <= c[8] && p == S;
        if (!(x || A))
          return a;
        v & w && (a[2] = c[2], _ |= p & w ? 0 : k);
        var M = c[3];
        if (M) {
          var B = a[3];
          a[3] = B ? Oh(B, M, c[4]) : M, a[4] = B ? ni(a[3], f) : c[4];
        }
        return M = c[5], M && (B = a[5], a[5] = B ? Fh(B, M, c[6]) : M, a[6] = B ? ni(a[5], f) : c[6]), M = c[7], M && (a[7] = M), v & P && (a[8] = a[8] == null ? c[8] : zt(a[8], c[8])), a[9] == null && (a[9] = c[9]), a[0] = c[0], a[1] = _, a;
      }
      function Xw(a) {
        var c = [];
        if (a != null)
          for (var p in Ze(a))
            c.push(p);
        return c;
      }
      function Zw(a) {
        return $a.call(a);
      }
      function Yh(a, c, p) {
        return c = Ct(c === t ? a.length - 1 : c, 0), function() {
          for (var v = arguments, _ = -1, x = Ct(v.length - c, 0), A = $(x); ++_ < x; )
            A[_] = v[c + _];
          _ = -1;
          for (var M = $(c + 1); ++_ < c; )
            M[_] = v[_];
          return M[c] = p(A), _n(a, this, M);
        };
      }
      function Xh(a, c) {
        return c.length < 2 ? a : zi(a, zn(c, 0, -1));
      }
      function Qw(a, c) {
        for (var p = a.length, v = zt(c.length, p), _ = cn(a); v--; ) {
          var x = c[v];
          a[v] = Vr(x, p) ? _[x] : t;
        }
        return a;
      }
      function Nc(a, c) {
        if (!(c === "constructor" && typeof a[c] == "function") && c != "__proto__")
          return a[c];
      }
      var Zh = em(wh), zo = h_ || function(a, c) {
        return Ft.setTimeout(a, c);
      }, Bc = em(Dw);
      function Qh(a, c, p) {
        var v = c + "";
        return Bc(a, Uw(v, eD(Vw(v), p)));
      }
      function em(a) {
        var c = 0, p = 0;
        return function() {
          var v = y_(), _ = Ee - (v - p);
          if (p = v, _ > 0) {
            if (++c >= ke)
              return arguments[0];
          } else
            c = 0;
          return a.apply(t, arguments);
        };
      }
      function al(a, c) {
        var p = -1, v = a.length, _ = v - 1;
        for (c = c === t ? v : c; ++p < c; ) {
          var x = yc(p, _), A = a[x];
          a[x] = a[p], a[p] = A;
        }
        return a.length = c, a;
      }
      var tm = Jw(function(a) {
        var c = [];
        return a.charCodeAt(0) === 46 && c.push(""), a.replace(Wb, function(p, v, _, x) {
          c.push(_ ? x.replace(Xb, "$1") : v || p);
        }), c;
      });
      function Dr(a) {
        if (typeof a == "string" || Cn(a))
          return a;
        var c = a + "";
        return c == "0" && 1 / a == -He ? "-0" : c;
      }
      function Hi(a) {
        if (a != null) {
          try {
            return Ba.call(a);
          } catch {
          }
          try {
            return a + "";
          } catch {
          }
        }
        return "";
      }
      function eD(a, c) {
        return Bn(gt, function(p) {
          var v = "_." + p[0];
          c & p[1] && !Oa(a, v) && a.push(v);
        }), a.sort();
      }
      function nm(a) {
        if (a instanceof Ne)
          return a.clone();
        var c = new Ln(a.__wrapped__, a.__chain__);
        return c.__actions__ = cn(a.__actions__), c.__index__ = a.__index__, c.__values__ = a.__values__, c;
      }
      function tD(a, c, p) {
        (p ? Qt(a, c, p) : c === t) ? c = 1 : c = Ct(Se(c), 0);
        var v = a == null ? 0 : a.length;
        if (!v || c < 1)
          return [];
        for (var _ = 0, x = 0, A = $(Wa(v / c)); _ < v; )
          A[x++] = zn(a, _, _ += c);
        return A;
      }
      function nD(a) {
        for (var c = -1, p = a == null ? 0 : a.length, v = 0, _ = []; ++c < p; ) {
          var x = a[c];
          x && (_[v++] = x);
        }
        return _;
      }
      function rD() {
        var a = arguments.length;
        if (!a)
          return [];
        for (var c = $(a - 1), p = arguments[0], v = a; v--; )
          c[v - 1] = arguments[v];
        return ti(xe(p) ? cn(p) : [p], It(c, 1));
      }
      var iD = Fe(function(a, c) {
        return pt(a) ? Ro(a, It(c, 1, pt, !0)) : [];
      }), sD = Fe(function(a, c) {
        var p = Vn(c);
        return pt(p) && (p = t), pt(a) ? Ro(a, It(c, 1, pt, !0), he(p, 2)) : [];
      }), oD = Fe(function(a, c) {
        var p = Vn(c);
        return pt(p) && (p = t), pt(a) ? Ro(a, It(c, 1, pt, !0), t, p) : [];
      });
      function aD(a, c, p) {
        var v = a == null ? 0 : a.length;
        return v ? (c = p || c === t ? 1 : Se(c), zn(a, c < 0 ? 0 : c, v)) : [];
      }
      function lD(a, c, p) {
        var v = a == null ? 0 : a.length;
        return v ? (c = p || c === t ? 1 : Se(c), c = v - c, zn(a, 0, c < 0 ? 0 : c)) : [];
      }
      function uD(a, c) {
        return a && a.length ? Qa(a, he(c, 3), !0, !0) : [];
      }
      function cD(a, c) {
        return a && a.length ? Qa(a, he(c, 3), !0) : [];
      }
      function dD(a, c, p, v) {
        var _ = a == null ? 0 : a.length;
        return _ ? (p && typeof p != "number" && Qt(a, c, p) && (p = 0, v = _), rw(a, c, p, v)) : [];
      }
      function rm(a, c, p) {
        var v = a == null ? 0 : a.length;
        if (!v)
          return -1;
        var _ = p == null ? 0 : Se(p);
        return _ < 0 && (_ = Ct(v + _, 0)), Fa(a, he(c, 3), _);
      }
      function im(a, c, p) {
        var v = a == null ? 0 : a.length;
        if (!v)
          return -1;
        var _ = v - 1;
        return p !== t && (_ = Se(p), _ = p < 0 ? Ct(v + _, 0) : zt(_, v - 1)), Fa(a, he(c, 3), _, !0);
      }
      function sm(a) {
        var c = a == null ? 0 : a.length;
        return c ? It(a, 1) : [];
      }
      function fD(a) {
        var c = a == null ? 0 : a.length;
        return c ? It(a, He) : [];
      }
      function pD(a, c) {
        var p = a == null ? 0 : a.length;
        return p ? (c = c === t ? 1 : Se(c), It(a, c)) : [];
      }
      function hD(a) {
        for (var c = -1, p = a == null ? 0 : a.length, v = {}; ++c < p; ) {
          var _ = a[c];
          v[_[0]] = _[1];
        }
        return v;
      }
      function om(a) {
        return a && a.length ? a[0] : t;
      }
      function mD(a, c, p) {
        var v = a == null ? 0 : a.length;
        if (!v)
          return -1;
        var _ = p == null ? 0 : Se(p);
        return _ < 0 && (_ = Ct(v + _, 0)), ws(a, c, _);
      }
      function gD(a) {
        var c = a == null ? 0 : a.length;
        return c ? zn(a, 0, -1) : [];
      }
      var vD = Fe(function(a) {
        var c = ot(a, Cc);
        return c.length && c[0] === a[0] ? pc(c) : [];
      }), yD = Fe(function(a) {
        var c = Vn(a), p = ot(a, Cc);
        return c === Vn(p) ? c = t : p.pop(), p.length && p[0] === a[0] ? pc(p, he(c, 2)) : [];
      }), bD = Fe(function(a) {
        var c = Vn(a), p = ot(a, Cc);
        return c = typeof c == "function" ? c : t, c && p.pop(), p.length && p[0] === a[0] ? pc(p, t, c) : [];
      });
      function _D(a, c) {
        return a == null ? "" : g_.call(a, c);
      }
      function Vn(a) {
        var c = a == null ? 0 : a.length;
        return c ? a[c - 1] : t;
      }
      function wD(a, c, p) {
        var v = a == null ? 0 : a.length;
        if (!v)
          return -1;
        var _ = v;
        return p !== t && (_ = Se(p), _ = _ < 0 ? Ct(v + _, 0) : zt(_, v - 1)), c === c ? e_(a, c, _) : Fa(a, zp, _, !0);
      }
      function DD(a, c) {
        return a && a.length ? vh(a, Se(c)) : t;
      }
      var CD = Fe(am);
      function am(a, c) {
        return a && a.length && c && c.length ? vc(a, c) : a;
      }
      function xD(a, c, p) {
        return a && a.length && c && c.length ? vc(a, c, he(p, 2)) : a;
      }
      function kD(a, c, p) {
        return a && a.length && c && c.length ? vc(a, c, t, p) : a;
      }
      var SD = zr(function(a, c) {
        var p = a == null ? 0 : a.length, v = uc(a, c);
        return _h(a, ot(c, function(_) {
          return Vr(_, p) ? +_ : _;
        }).sort(Mh)), v;
      });
      function AD(a, c) {
        var p = [];
        if (!(a && a.length))
          return p;
        var v = -1, _ = [], x = a.length;
        for (c = he(c, 3); ++v < x; ) {
          var A = a[v];
          c(A, v, a) && (p.push(A), _.push(v));
        }
        return _h(a, _), p;
      }
      function $c(a) {
        return a == null ? a : __.call(a);
      }
      function ED(a, c, p) {
        var v = a == null ? 0 : a.length;
        return v ? (p && typeof p != "number" && Qt(a, c, p) ? (c = 0, p = v) : (c = c == null ? 0 : Se(c), p = p === t ? v : Se(p)), zn(a, c, p)) : [];
      }
      function TD(a, c) {
        return Za(a, c);
      }
      function MD(a, c, p) {
        return _c(a, c, he(p, 2));
      }
      function OD(a, c) {
        var p = a == null ? 0 : a.length;
        if (p) {
          var v = Za(a, c);
          if (v < p && sr(a[v], c))
            return v;
        }
        return -1;
      }
      function FD(a, c) {
        return Za(a, c, !0);
      }
      function ID(a, c, p) {
        return _c(a, c, he(p, 2), !0);
      }
      function RD(a, c) {
        var p = a == null ? 0 : a.length;
        if (p) {
          var v = Za(a, c, !0) - 1;
          if (sr(a[v], c))
            return v;
        }
        return -1;
      }
      function ND(a) {
        return a && a.length ? Dh(a) : [];
      }
      function BD(a, c) {
        return a && a.length ? Dh(a, he(c, 2)) : [];
      }
      function $D(a) {
        var c = a == null ? 0 : a.length;
        return c ? zn(a, 1, c) : [];
      }
      function LD(a, c, p) {
        return a && a.length ? (c = p || c === t ? 1 : Se(c), zn(a, 0, c < 0 ? 0 : c)) : [];
      }
      function PD(a, c, p) {
        var v = a == null ? 0 : a.length;
        return v ? (c = p || c === t ? 1 : Se(c), c = v - c, zn(a, c < 0 ? 0 : c, v)) : [];
      }
      function zD(a, c) {
        return a && a.length ? Qa(a, he(c, 3), !1, !0) : [];
      }
      function VD(a, c) {
        return a && a.length ? Qa(a, he(c, 3)) : [];
      }
      var HD = Fe(function(a) {
        return si(It(a, 1, pt, !0));
      }), WD = Fe(function(a) {
        var c = Vn(a);
        return pt(c) && (c = t), si(It(a, 1, pt, !0), he(c, 2));
      }), UD = Fe(function(a) {
        var c = Vn(a);
        return c = typeof c == "function" ? c : t, si(It(a, 1, pt, !0), t, c);
      });
      function jD(a) {
        return a && a.length ? si(a) : [];
      }
      function qD(a, c) {
        return a && a.length ? si(a, he(c, 2)) : [];
      }
      function KD(a, c) {
        return c = typeof c == "function" ? c : t, a && a.length ? si(a, t, c) : [];
      }
      function Lc(a) {
        if (!(a && a.length))
          return [];
        var c = 0;
        return a = ei(a, function(p) {
          if (pt(p))
            return c = Ct(p.length, c), !0;
        }), tc(c, function(p) {
          return ot(a, Zu(p));
        });
      }
      function lm(a, c) {
        if (!(a && a.length))
          return [];
        var p = Lc(a);
        return c == null ? p : ot(p, function(v) {
          return _n(c, t, v);
        });
      }
      var GD = Fe(function(a, c) {
        return pt(a) ? Ro(a, c) : [];
      }), JD = Fe(function(a) {
        return Dc(ei(a, pt));
      }), YD = Fe(function(a) {
        var c = Vn(a);
        return pt(c) && (c = t), Dc(ei(a, pt), he(c, 2));
      }), XD = Fe(function(a) {
        var c = Vn(a);
        return c = typeof c == "function" ? c : t, Dc(ei(a, pt), t, c);
      }), ZD = Fe(Lc);
      function QD(a, c) {
        return Sh(a || [], c || [], Io);
      }
      function eC(a, c) {
        return Sh(a || [], c || [], $o);
      }
      var tC = Fe(function(a) {
        var c = a.length, p = c > 1 ? a[c - 1] : t;
        return p = typeof p == "function" ? (a.pop(), p) : t, lm(a, p);
      });
      function um(a) {
        var c = D(a);
        return c.__chain__ = !0, c;
      }
      function nC(a, c) {
        return c(a), a;
      }
      function ll(a, c) {
        return c(a);
      }
      var rC = zr(function(a) {
        var c = a.length, p = c ? a[0] : 0, v = this.__wrapped__, _ = function(x) {
          return uc(x, a);
        };
        return c > 1 || this.__actions__.length || !(v instanceof Ne) || !Vr(p) ? this.thru(_) : (v = v.slice(p, +p + (c ? 1 : 0)), v.__actions__.push({
          func: ll,
          args: [_],
          thisArg: t
        }), new Ln(v, this.__chain__).thru(function(x) {
          return c && !x.length && x.push(t), x;
        }));
      });
      function iC() {
        return um(this);
      }
      function sC() {
        return new Ln(this.value(), this.__chain__);
      }
      function oC() {
        this.__values__ === t && (this.__values__ = Cm(this.value()));
        var a = this.__index__ >= this.__values__.length, c = a ? t : this.__values__[this.__index__++];
        return { done: a, value: c };
      }
      function aC() {
        return this;
      }
      function lC(a) {
        for (var c, p = this; p instanceof Ka; ) {
          var v = nm(p);
          v.__index__ = 0, v.__values__ = t, c ? _.__wrapped__ = v : c = v;
          var _ = v;
          p = p.__wrapped__;
        }
        return _.__wrapped__ = a, c;
      }
      function uC() {
        var a = this.__wrapped__;
        if (a instanceof Ne) {
          var c = a;
          return this.__actions__.length && (c = new Ne(this)), c = c.reverse(), c.__actions__.push({
            func: ll,
            args: [$c],
            thisArg: t
          }), new Ln(c, this.__chain__);
        }
        return this.thru($c);
      }
      function cC() {
        return kh(this.__wrapped__, this.__actions__);
      }
      var dC = el(function(a, c, p) {
        qe.call(a, p) ? ++a[p] : Lr(a, p, 1);
      });
      function fC(a, c, p) {
        var v = xe(a) ? Lp : nw;
        return p && Qt(a, c, p) && (c = t), v(a, he(c, 3));
      }
      function pC(a, c) {
        var p = xe(a) ? ei : lh;
        return p(a, he(c, 3));
      }
      var hC = Bh(rm), mC = Bh(im);
      function gC(a, c) {
        return It(ul(a, c), 1);
      }
      function vC(a, c) {
        return It(ul(a, c), He);
      }
      function yC(a, c, p) {
        return p = p === t ? 1 : Se(p), It(ul(a, c), p);
      }
      function cm(a, c) {
        var p = xe(a) ? Bn : ii;
        return p(a, he(c, 3));
      }
      function dm(a, c) {
        var p = xe(a) ? $1 : ah;
        return p(a, he(c, 3));
      }
      var bC = el(function(a, c, p) {
        qe.call(a, p) ? a[p].push(c) : Lr(a, p, [c]);
      });
      function _C(a, c, p, v) {
        a = dn(a) ? a : Is(a), p = p && !v ? Se(p) : 0;
        var _ = a.length;
        return p < 0 && (p = Ct(_ + p, 0)), hl(a) ? p <= _ && a.indexOf(c, p) > -1 : !!_ && ws(a, c, p) > -1;
      }
      var wC = Fe(function(a, c, p) {
        var v = -1, _ = typeof c == "function", x = dn(a) ? $(a.length) : [];
        return ii(a, function(A) {
          x[++v] = _ ? _n(c, A, p) : No(A, c, p);
        }), x;
      }), DC = el(function(a, c, p) {
        Lr(a, p, c);
      });
      function ul(a, c) {
        var p = xe(a) ? ot : hh;
        return p(a, he(c, 3));
      }
      function CC(a, c, p, v) {
        return a == null ? [] : (xe(c) || (c = c == null ? [] : [c]), p = v ? t : p, xe(p) || (p = p == null ? [] : [p]), yh(a, c, p));
      }
      var xC = el(function(a, c, p) {
        a[p ? 0 : 1].push(c);
      }, function() {
        return [[], []];
      });
      function kC(a, c, p) {
        var v = xe(a) ? Yu : Hp, _ = arguments.length < 3;
        return v(a, he(c, 4), p, _, ii);
      }
      function SC(a, c, p) {
        var v = xe(a) ? L1 : Hp, _ = arguments.length < 3;
        return v(a, he(c, 4), p, _, ah);
      }
      function AC(a, c) {
        var p = xe(a) ? ei : lh;
        return p(a, fl(he(c, 3)));
      }
      function EC(a) {
        var c = xe(a) ? rh : _w;
        return c(a);
      }
      function TC(a, c, p) {
        (p ? Qt(a, c, p) : c === t) ? c = 1 : c = Se(c);
        var v = xe(a) ? X_ : ww;
        return v(a, c);
      }
      function MC(a) {
        var c = xe(a) ? Z_ : Cw;
        return c(a);
      }
      function OC(a) {
        if (a == null)
          return 0;
        if (dn(a))
          return hl(a) ? Cs(a) : a.length;
        var c = Vt(a);
        return c == Pt || c == vt ? a.size : mc(a).length;
      }
      function FC(a, c, p) {
        var v = xe(a) ? Xu : xw;
        return p && Qt(a, c, p) && (c = t), v(a, he(c, 3));
      }
      var IC = Fe(function(a, c) {
        if (a == null)
          return [];
        var p = c.length;
        return p > 1 && Qt(a, c[0], c[1]) ? c = [] : p > 2 && Qt(c[0], c[1], c[2]) && (c = [c[0]]), yh(a, It(c, 1), []);
      }), cl = p_ || function() {
        return Ft.Date.now();
      };
      function RC(a, c) {
        if (typeof c != "function")
          throw new $n(o);
        return a = Se(a), function() {
          if (--a < 1)
            return c.apply(this, arguments);
        };
      }
      function fm(a, c, p) {
        return c = p ? t : c, c = a && c == null ? a.length : c, Pr(a, P, t, t, t, t, c);
      }
      function pm(a, c) {
        var p;
        if (typeof c != "function")
          throw new $n(o);
        return a = Se(a), function() {
          return --a > 0 && (p = c.apply(this, arguments)), a <= 1 && (c = t), p;
        };
      }
      var Pc = Fe(function(a, c, p) {
        var v = w;
        if (p.length) {
          var _ = ni(p, Os(Pc));
          v |= R;
        }
        return Pr(a, v, c, p, _);
      }), hm = Fe(function(a, c, p) {
        var v = w | T;
        if (p.length) {
          var _ = ni(p, Os(hm));
          v |= R;
        }
        return Pr(c, v, a, p, _);
      });
      function mm(a, c, p) {
        c = p ? t : c;
        var v = Pr(a, S, t, t, t, t, t, c);
        return v.placeholder = mm.placeholder, v;
      }
      function gm(a, c, p) {
        c = p ? t : c;
        var v = Pr(a, C, t, t, t, t, t, c);
        return v.placeholder = gm.placeholder, v;
      }
      function vm(a, c, p) {
        var v, _, x, A, M, B, H = 0, W = !1, j = !1, Q = !0;
        if (typeof a != "function")
          throw new $n(o);
        c = Hn(c) || 0, at(p) && (W = !!p.leading, j = "maxWait" in p, x = j ? Ct(Hn(p.maxWait) || 0, c) : x, Q = "trailing" in p ? !!p.trailing : Q);
        function le(ht) {
          var or = v, Ur = _;
          return v = _ = t, H = ht, A = a.apply(Ur, or), A;
        }
        function ye(ht) {
          return H = ht, M = zo(Ie, c), W ? le(ht) : A;
        }
        function Me(ht) {
          var or = ht - B, Ur = ht - H, Bm = c - or;
          return j ? zt(Bm, x - Ur) : Bm;
        }
        function be(ht) {
          var or = ht - B, Ur = ht - H;
          return B === t || or >= c || or < 0 || j && Ur >= x;
        }
        function Ie() {
          var ht = cl();
          if (be(ht))
            return $e(ht);
          M = zo(Ie, Me(ht));
        }
        function $e(ht) {
          return M = t, Q && v ? le(ht) : (v = _ = t, A);
        }
        function xn() {
          M !== t && Ah(M), H = 0, v = B = _ = M = t;
        }
        function en() {
          return M === t ? A : $e(cl());
        }
        function kn() {
          var ht = cl(), or = be(ht);
          if (v = arguments, _ = this, B = ht, or) {
            if (M === t)
              return ye(B);
            if (j)
              return Ah(M), M = zo(Ie, c), le(B);
          }
          return M === t && (M = zo(Ie, c)), A;
        }
        return kn.cancel = xn, kn.flush = en, kn;
      }
      var NC = Fe(function(a, c) {
        return oh(a, 1, c);
      }), BC = Fe(function(a, c, p) {
        return oh(a, Hn(c) || 0, p);
      });
      function $C(a) {
        return Pr(a, q);
      }
      function dl(a, c) {
        if (typeof a != "function" || c != null && typeof c != "function")
          throw new $n(o);
        var p = function() {
          var v = arguments, _ = c ? c.apply(this, v) : v[0], x = p.cache;
          if (x.has(_))
            return x.get(_);
          var A = a.apply(this, v);
          return p.cache = x.set(_, A) || x, A;
        };
        return p.cache = new (dl.Cache || $r)(), p;
      }
      dl.Cache = $r;
      function fl(a) {
        if (typeof a != "function")
          throw new $n(o);
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return !a.call(this);
            case 1:
              return !a.call(this, c[0]);
            case 2:
              return !a.call(this, c[0], c[1]);
            case 3:
              return !a.call(this, c[0], c[1], c[2]);
          }
          return !a.apply(this, c);
        };
      }
      function LC(a) {
        return pm(2, a);
      }
      var PC = kw(function(a, c) {
        c = c.length == 1 && xe(c[0]) ? ot(c[0], wn(he())) : ot(It(c, 1), wn(he()));
        var p = c.length;
        return Fe(function(v) {
          for (var _ = -1, x = zt(v.length, p); ++_ < x; )
            v[_] = c[_].call(this, v[_]);
          return _n(a, this, v);
        });
      }), zc = Fe(function(a, c) {
        var p = ni(c, Os(zc));
        return Pr(a, R, t, c, p);
      }), ym = Fe(function(a, c) {
        var p = ni(c, Os(ym));
        return Pr(a, I, t, c, p);
      }), zC = zr(function(a, c) {
        return Pr(a, L, t, t, t, c);
      });
      function VC(a, c) {
        if (typeof a != "function")
          throw new $n(o);
        return c = c === t ? c : Se(c), Fe(a, c);
      }
      function HC(a, c) {
        if (typeof a != "function")
          throw new $n(o);
        return c = c == null ? 0 : Ct(Se(c), 0), Fe(function(p) {
          var v = p[c], _ = ai(p, 0, c);
          return v && ti(_, v), _n(a, this, _);
        });
      }
      function WC(a, c, p) {
        var v = !0, _ = !0;
        if (typeof a != "function")
          throw new $n(o);
        return at(p) && (v = "leading" in p ? !!p.leading : v, _ = "trailing" in p ? !!p.trailing : _), vm(a, c, {
          leading: v,
          maxWait: c,
          trailing: _
        });
      }
      function UC(a) {
        return fm(a, 1);
      }
      function jC(a, c) {
        return zc(xc(c), a);
      }
      function qC() {
        if (!arguments.length)
          return [];
        var a = arguments[0];
        return xe(a) ? a : [a];
      }
      function KC(a) {
        return Pn(a, g);
      }
      function GC(a, c) {
        return c = typeof c == "function" ? c : t, Pn(a, g, c);
      }
      function JC(a) {
        return Pn(a, h | g);
      }
      function YC(a, c) {
        return c = typeof c == "function" ? c : t, Pn(a, h | g, c);
      }
      function XC(a, c) {
        return c == null || sh(a, c, St(c));
      }
      function sr(a, c) {
        return a === c || a !== a && c !== c;
      }
      var ZC = il(fc), QC = il(function(a, c) {
        return a >= c;
      }), Wi = dh(function() {
        return arguments;
      }()) ? dh : function(a) {
        return ut(a) && qe.call(a, "callee") && !Xp.call(a, "callee");
      }, xe = $.isArray, ex = Fp ? wn(Fp) : lw;
      function dn(a) {
        return a != null && pl(a.length) && !Hr(a);
      }
      function pt(a) {
        return ut(a) && dn(a);
      }
      function tx(a) {
        return a === !0 || a === !1 || ut(a) && Zt(a) == wt;
      }
      var li = m_ || Xc, nx = Ip ? wn(Ip) : uw;
      function rx(a) {
        return ut(a) && a.nodeType === 1 && !Vo(a);
      }
      function ix(a) {
        if (a == null)
          return !0;
        if (dn(a) && (xe(a) || typeof a == "string" || typeof a.splice == "function" || li(a) || Fs(a) || Wi(a)))
          return !a.length;
        var c = Vt(a);
        if (c == Pt || c == vt)
          return !a.size;
        if (Po(a))
          return !mc(a).length;
        for (var p in a)
          if (qe.call(a, p))
            return !1;
        return !0;
      }
      function sx(a, c) {
        return Bo(a, c);
      }
      function ox(a, c, p) {
        p = typeof p == "function" ? p : t;
        var v = p ? p(a, c) : t;
        return v === t ? Bo(a, c, t, p) : !!v;
      }
      function Vc(a) {
        if (!ut(a))
          return !1;
        var c = Zt(a);
        return c == Lt || c == ln || typeof a.message == "string" && typeof a.name == "string" && !Vo(a);
      }
      function ax(a) {
        return typeof a == "number" && Qp(a);
      }
      function Hr(a) {
        if (!at(a))
          return !1;
        var c = Zt(a);
        return c == er || c == In || c == bn || c == gs;
      }
      function bm(a) {
        return typeof a == "number" && a == Se(a);
      }
      function pl(a) {
        return typeof a == "number" && a > -1 && a % 1 == 0 && a <= De;
      }
      function at(a) {
        var c = typeof a;
        return a != null && (c == "object" || c == "function");
      }
      function ut(a) {
        return a != null && typeof a == "object";
      }
      var _m = Rp ? wn(Rp) : dw;
      function lx(a, c) {
        return a === c || hc(a, c, Oc(c));
      }
      function ux(a, c, p) {
        return p = typeof p == "function" ? p : t, hc(a, c, Oc(c), p);
      }
      function cx(a) {
        return wm(a) && a != +a;
      }
      function dx(a) {
        if (Gw(a))
          throw new Ce(s);
        return fh(a);
      }
      function fx(a) {
        return a === null;
      }
      function px(a) {
        return a == null;
      }
      function wm(a) {
        return typeof a == "number" || ut(a) && Zt(a) == vr;
      }
      function Vo(a) {
        if (!ut(a) || Zt(a) != Yt)
          return !1;
        var c = za(a);
        if (c === null)
          return !0;
        var p = qe.call(c, "constructor") && c.constructor;
        return typeof p == "function" && p instanceof p && Ba.call(p) == u_;
      }
      var Hc = Np ? wn(Np) : fw;
      function hx(a) {
        return bm(a) && a >= -De && a <= De;
      }
      var Dm = Bp ? wn(Bp) : pw;
      function hl(a) {
        return typeof a == "string" || !xe(a) && ut(a) && Zt(a) == tr;
      }
      function Cn(a) {
        return typeof a == "symbol" || ut(a) && Zt(a) == Rn;
      }
      var Fs = $p ? wn($p) : hw;
      function mx(a) {
        return a === t;
      }
      function gx(a) {
        return ut(a) && Vt(a) == yr;
      }
      function vx(a) {
        return ut(a) && Zt(a) == vs;
      }
      var yx = il(gc), bx = il(function(a, c) {
        return a <= c;
      });
      function Cm(a) {
        if (!a)
          return [];
        if (dn(a))
          return hl(a) ? rr(a) : cn(a);
        if (Eo && a[Eo])
          return X1(a[Eo]());
        var c = Vt(a), p = c == Pt ? rc : c == vt ? Ia : Is;
        return p(a);
      }
      function Wr(a) {
        if (!a)
          return a === 0 ? a : 0;
        if (a = Hn(a), a === He || a === -He) {
          var c = a < 0 ? -1 : 1;
          return c * Te;
        }
        return a === a ? a : 0;
      }
      function Se(a) {
        var c = Wr(a), p = c % 1;
        return c === c ? p ? c - p : c : 0;
      }
      function xm(a) {
        return a ? Pi(Se(a), 0, je) : 0;
      }
      function Hn(a) {
        if (typeof a == "number")
          return a;
        if (Cn(a))
          return Oe;
        if (at(a)) {
          var c = typeof a.valueOf == "function" ? a.valueOf() : a;
          a = at(c) ? c + "" : c;
        }
        if (typeof a != "string")
          return a === 0 ? a : +a;
        a = Wp(a);
        var p = e1.test(a);
        return p || n1.test(a) ? R1(a.slice(2), p ? 2 : 8) : Qb.test(a) ? Oe : +a;
      }
      function km(a) {
        return wr(a, fn(a));
      }
      function _x(a) {
        return a ? Pi(Se(a), -De, De) : a === 0 ? a : 0;
      }
      function We(a) {
        return a == null ? "" : Dn(a);
      }
      var wx = Ts(function(a, c) {
        if (Po(c) || dn(c)) {
          wr(c, St(c), a);
          return;
        }
        for (var p in c)
          qe.call(c, p) && Io(a, p, c[p]);
      }), Sm = Ts(function(a, c) {
        wr(c, fn(c), a);
      }), ml = Ts(function(a, c, p, v) {
        wr(c, fn(c), a, v);
      }), Dx = Ts(function(a, c, p, v) {
        wr(c, St(c), a, v);
      }), Cx = zr(uc);
      function xx(a, c) {
        var p = Es(a);
        return c == null ? p : ih(p, c);
      }
      var kx = Fe(function(a, c) {
        a = Ze(a);
        var p = -1, v = c.length, _ = v > 2 ? c[2] : t;
        for (_ && Qt(c[0], c[1], _) && (v = 1); ++p < v; )
          for (var x = c[p], A = fn(x), M = -1, B = A.length; ++M < B; ) {
            var H = A[M], W = a[H];
            (W === t || sr(W, ks[H]) && !qe.call(a, H)) && (a[H] = x[H]);
          }
        return a;
      }), Sx = Fe(function(a) {
        return a.push(t, Wh), _n(Am, t, a);
      });
      function Ax(a, c) {
        return Pp(a, he(c, 3), _r);
      }
      function Ex(a, c) {
        return Pp(a, he(c, 3), dc);
      }
      function Tx(a, c) {
        return a == null ? a : cc(a, he(c, 3), fn);
      }
      function Mx(a, c) {
        return a == null ? a : uh(a, he(c, 3), fn);
      }
      function Ox(a, c) {
        return a && _r(a, he(c, 3));
      }
      function Fx(a, c) {
        return a && dc(a, he(c, 3));
      }
      function Ix(a) {
        return a == null ? [] : Ya(a, St(a));
      }
      function Rx(a) {
        return a == null ? [] : Ya(a, fn(a));
      }
      function Wc(a, c, p) {
        var v = a == null ? t : zi(a, c);
        return v === t ? p : v;
      }
      function Nx(a, c) {
        return a != null && qh(a, c, iw);
      }
      function Uc(a, c) {
        return a != null && qh(a, c, sw);
      }
      var Bx = Lh(function(a, c, p) {
        c != null && typeof c.toString != "function" && (c = $a.call(c)), a[c] = p;
      }, qc(pn)), $x = Lh(function(a, c, p) {
        c != null && typeof c.toString != "function" && (c = $a.call(c)), qe.call(a, c) ? a[c].push(p) : a[c] = [p];
      }, he), Lx = Fe(No);
      function St(a) {
        return dn(a) ? nh(a) : mc(a);
      }
      function fn(a) {
        return dn(a) ? nh(a, !0) : mw(a);
      }
      function Px(a, c) {
        var p = {};
        return c = he(c, 3), _r(a, function(v, _, x) {
          Lr(p, c(v, _, x), v);
        }), p;
      }
      function zx(a, c) {
        var p = {};
        return c = he(c, 3), _r(a, function(v, _, x) {
          Lr(p, _, c(v, _, x));
        }), p;
      }
      var Vx = Ts(function(a, c, p) {
        Xa(a, c, p);
      }), Am = Ts(function(a, c, p, v) {
        Xa(a, c, p, v);
      }), Hx = zr(function(a, c) {
        var p = {};
        if (a == null)
          return p;
        var v = !1;
        c = ot(c, function(x) {
          return x = oi(x, a), v || (v = x.length > 1), x;
        }), wr(a, Tc(a), p), v && (p = Pn(p, h | m | g, Bw));
        for (var _ = c.length; _--; )
          wc(p, c[_]);
        return p;
      });
      function Wx(a, c) {
        return Em(a, fl(he(c)));
      }
      var Ux = zr(function(a, c) {
        return a == null ? {} : vw(a, c);
      });
      function Em(a, c) {
        if (a == null)
          return {};
        var p = ot(Tc(a), function(v) {
          return [v];
        });
        return c = he(c), bh(a, p, function(v, _) {
          return c(v, _[0]);
        });
      }
      function jx(a, c, p) {
        c = oi(c, a);
        var v = -1, _ = c.length;
        for (_ || (_ = 1, a = t); ++v < _; ) {
          var x = a == null ? t : a[Dr(c[v])];
          x === t && (v = _, x = p), a = Hr(x) ? x.call(a) : x;
        }
        return a;
      }
      function qx(a, c, p) {
        return a == null ? a : $o(a, c, p);
      }
      function Kx(a, c, p, v) {
        return v = typeof v == "function" ? v : t, a == null ? a : $o(a, c, p, v);
      }
      var Tm = Vh(St), Mm = Vh(fn);
      function Gx(a, c, p) {
        var v = xe(a), _ = v || li(a) || Fs(a);
        if (c = he(c, 4), p == null) {
          var x = a && a.constructor;
          _ ? p = v ? new x() : [] : at(a) ? p = Hr(x) ? Es(za(a)) : {} : p = {};
        }
        return (_ ? Bn : _r)(a, function(A, M, B) {
          return c(p, A, M, B);
        }), p;
      }
      function Jx(a, c) {
        return a == null ? !0 : wc(a, c);
      }
      function Yx(a, c, p) {
        return a == null ? a : xh(a, c, xc(p));
      }
      function Xx(a, c, p, v) {
        return v = typeof v == "function" ? v : t, a == null ? a : xh(a, c, xc(p), v);
      }
      function Is(a) {
        return a == null ? [] : nc(a, St(a));
      }
      function Zx(a) {
        return a == null ? [] : nc(a, fn(a));
      }
      function Qx(a, c, p) {
        return p === t && (p = c, c = t), p !== t && (p = Hn(p), p = p === p ? p : 0), c !== t && (c = Hn(c), c = c === c ? c : 0), Pi(Hn(a), c, p);
      }
      function ek(a, c, p) {
        return c = Wr(c), p === t ? (p = c, c = 0) : p = Wr(p), a = Hn(a), ow(a, c, p);
      }
      function tk(a, c, p) {
        if (p && typeof p != "boolean" && Qt(a, c, p) && (c = p = t), p === t && (typeof c == "boolean" ? (p = c, c = t) : typeof a == "boolean" && (p = a, a = t)), a === t && c === t ? (a = 0, c = 1) : (a = Wr(a), c === t ? (c = a, a = 0) : c = Wr(c)), a > c) {
          var v = a;
          a = c, c = v;
        }
        if (p || a % 1 || c % 1) {
          var _ = eh();
          return zt(a + _ * (c - a + I1("1e-" + ((_ + "").length - 1))), c);
        }
        return yc(a, c);
      }
      var nk = Ms(function(a, c, p) {
        return c = c.toLowerCase(), a + (p ? Om(c) : c);
      });
      function Om(a) {
        return jc(We(a).toLowerCase());
      }
      function Fm(a) {
        return a = We(a), a && a.replace(i1, q1).replace(C1, "");
      }
      function rk(a, c, p) {
        a = We(a), c = Dn(c);
        var v = a.length;
        p = p === t ? v : Pi(Se(p), 0, v);
        var _ = p;
        return p -= c.length, p >= 0 && a.slice(p, _) == c;
      }
      function ik(a) {
        return a = We(a), a && ko.test(a) ? a.replace(xo, K1) : a;
      }
      function sk(a) {
        return a = We(a), a && Ub.test(a) ? a.replace(zu, "\\$&") : a;
      }
      var ok = Ms(function(a, c, p) {
        return a + (p ? "-" : "") + c.toLowerCase();
      }), ak = Ms(function(a, c, p) {
        return a + (p ? " " : "") + c.toLowerCase();
      }), lk = Nh("toLowerCase");
      function uk(a, c, p) {
        a = We(a), c = Se(c);
        var v = c ? Cs(a) : 0;
        if (!c || v >= c)
          return a;
        var _ = (c - v) / 2;
        return rl(Ua(_), p) + a + rl(Wa(_), p);
      }
      function ck(a, c, p) {
        a = We(a), c = Se(c);
        var v = c ? Cs(a) : 0;
        return c && v < c ? a + rl(c - v, p) : a;
      }
      function dk(a, c, p) {
        a = We(a), c = Se(c);
        var v = c ? Cs(a) : 0;
        return c && v < c ? rl(c - v, p) + a : a;
      }
      function fk(a, c, p) {
        return p || c == null ? c = 0 : c && (c = +c), b_(We(a).replace(Vu, ""), c || 0);
      }
      function pk(a, c, p) {
        return (p ? Qt(a, c, p) : c === t) ? c = 1 : c = Se(c), bc(We(a), c);
      }
      function hk() {
        var a = arguments, c = We(a[0]);
        return a.length < 3 ? c : c.replace(a[1], a[2]);
      }
      var mk = Ms(function(a, c, p) {
        return a + (p ? "_" : "") + c.toLowerCase();
      });
      function gk(a, c, p) {
        return p && typeof p != "number" && Qt(a, c, p) && (c = p = t), p = p === t ? je : p >>> 0, p ? (a = We(a), a && (typeof c == "string" || c != null && !Hc(c)) && (c = Dn(c), !c && Ds(a)) ? ai(rr(a), 0, p) : a.split(c, p)) : [];
      }
      var vk = Ms(function(a, c, p) {
        return a + (p ? " " : "") + jc(c);
      });
      function yk(a, c, p) {
        return a = We(a), p = p == null ? 0 : Pi(Se(p), 0, a.length), c = Dn(c), a.slice(p, p + c.length) == c;
      }
      function bk(a, c, p) {
        var v = D.templateSettings;
        p && Qt(a, c, p) && (c = t), a = We(a), c = ml({}, c, v, Hh);
        var _ = ml({}, c.imports, v.imports, Hh), x = St(_), A = nc(_, x), M, B, H = 0, W = c.interpolate || Ea, j = "__p += '", Q = ic(
          (c.escape || Ea).source + "|" + W.source + "|" + (W === Aa ? Zb : Ea).source + "|" + (c.evaluate || Ea).source + "|$",
          "g"
        ), le = "//# sourceURL=" + (qe.call(c, "sourceURL") ? (c.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++E1 + "]") + `
`;
        a.replace(Q, function(be, Ie, $e, xn, en, kn) {
          return $e || ($e = xn), j += a.slice(H, kn).replace(s1, G1), Ie && (M = !0, j += `' +
__e(` + Ie + `) +
'`), en && (B = !0, j += `';
` + en + `;
__p += '`), $e && (j += `' +
((__t = (` + $e + `)) == null ? '' : __t) +
'`), H = kn + be.length, be;
        }), j += `';
`;
        var ye = qe.call(c, "variable") && c.variable;
        if (!ye)
          j = `with (obj) {
` + j + `
}
`;
        else if (Yb.test(ye))
          throw new Ce(l);
        j = (B ? j.replace(Be, "") : j).replace(Ot, "$1").replace(un, "$1;"), j = "function(" + (ye || "obj") + `) {
` + (ye ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (M ? ", __e = _.escape" : "") + (B ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + j + `return __p
}`;
        var Me = Rm(function() {
          return Ve(x, le + "return " + j).apply(t, A);
        });
        if (Me.source = j, Vc(Me))
          throw Me;
        return Me;
      }
      function _k(a) {
        return We(a).toLowerCase();
      }
      function wk(a) {
        return We(a).toUpperCase();
      }
      function Dk(a, c, p) {
        if (a = We(a), a && (p || c === t))
          return Wp(a);
        if (!a || !(c = Dn(c)))
          return a;
        var v = rr(a), _ = rr(c), x = Up(v, _), A = jp(v, _) + 1;
        return ai(v, x, A).join("");
      }
      function Ck(a, c, p) {
        if (a = We(a), a && (p || c === t))
          return a.slice(0, Kp(a) + 1);
        if (!a || !(c = Dn(c)))
          return a;
        var v = rr(a), _ = jp(v, rr(c)) + 1;
        return ai(v, 0, _).join("");
      }
      function xk(a, c, p) {
        if (a = We(a), a && (p || c === t))
          return a.replace(Vu, "");
        if (!a || !(c = Dn(c)))
          return a;
        var v = rr(a), _ = Up(v, rr(c));
        return ai(v, _).join("");
      }
      function kk(a, c) {
        var p = oe, v = ae;
        if (at(c)) {
          var _ = "separator" in c ? c.separator : _;
          p = "length" in c ? Se(c.length) : p, v = "omission" in c ? Dn(c.omission) : v;
        }
        a = We(a);
        var x = a.length;
        if (Ds(a)) {
          var A = rr(a);
          x = A.length;
        }
        if (p >= x)
          return a;
        var M = p - Cs(v);
        if (M < 1)
          return v;
        var B = A ? ai(A, 0, M).join("") : a.slice(0, M);
        if (_ === t)
          return B + v;
        if (A && (M += B.length - M), Hc(_)) {
          if (a.slice(M).search(_)) {
            var H, W = B;
            for (_.global || (_ = ic(_.source, We(dp.exec(_)) + "g")), _.lastIndex = 0; H = _.exec(W); )
              var j = H.index;
            B = B.slice(0, j === t ? M : j);
          }
        } else if (a.indexOf(Dn(_), M) != M) {
          var Q = B.lastIndexOf(_);
          Q > -1 && (B = B.slice(0, Q));
        }
        return B + v;
      }
      function Sk(a) {
        return a = We(a), a && Nr.test(a) ? a.replace(Rr, t_) : a;
      }
      var Ak = Ms(function(a, c, p) {
        return a + (p ? " " : "") + c.toUpperCase();
      }), jc = Nh("toUpperCase");
      function Im(a, c, p) {
        return a = We(a), c = p ? t : c, c === t ? Y1(a) ? i_(a) : V1(a) : a.match(c) || [];
      }
      var Rm = Fe(function(a, c) {
        try {
          return _n(a, t, c);
        } catch (p) {
          return Vc(p) ? p : new Ce(p);
        }
      }), Ek = zr(function(a, c) {
        return Bn(c, function(p) {
          p = Dr(p), Lr(a, p, Pc(a[p], a));
        }), a;
      });
      function Tk(a) {
        var c = a == null ? 0 : a.length, p = he();
        return a = c ? ot(a, function(v) {
          if (typeof v[1] != "function")
            throw new $n(o);
          return [p(v[0]), v[1]];
        }) : [], Fe(function(v) {
          for (var _ = -1; ++_ < c; ) {
            var x = a[_];
            if (_n(x[0], this, v))
              return _n(x[1], this, v);
          }
        });
      }
      function Mk(a) {
        return tw(Pn(a, h));
      }
      function qc(a) {
        return function() {
          return a;
        };
      }
      function Ok(a, c) {
        return a == null || a !== a ? c : a;
      }
      var Fk = $h(), Ik = $h(!0);
      function pn(a) {
        return a;
      }
      function Kc(a) {
        return ph(typeof a == "function" ? a : Pn(a, h));
      }
      function Rk(a) {
        return mh(Pn(a, h));
      }
      function Nk(a, c) {
        return gh(a, Pn(c, h));
      }
      var Bk = Fe(function(a, c) {
        return function(p) {
          return No(p, a, c);
        };
      }), $k = Fe(function(a, c) {
        return function(p) {
          return No(a, p, c);
        };
      });
      function Gc(a, c, p) {
        var v = St(c), _ = Ya(c, v);
        p == null && !(at(c) && (_.length || !v.length)) && (p = c, c = a, a = this, _ = Ya(c, St(c)));
        var x = !(at(p) && "chain" in p) || !!p.chain, A = Hr(a);
        return Bn(_, function(M) {
          var B = c[M];
          a[M] = B, A && (a.prototype[M] = function() {
            var H = this.__chain__;
            if (x || H) {
              var W = a(this.__wrapped__), j = W.__actions__ = cn(this.__actions__);
              return j.push({ func: B, args: arguments, thisArg: a }), W.__chain__ = H, W;
            }
            return B.apply(a, ti([this.value()], arguments));
          });
        }), a;
      }
      function Lk() {
        return Ft._ === this && (Ft._ = c_), this;
      }
      function Jc() {
      }
      function Pk(a) {
        return a = Se(a), Fe(function(c) {
          return vh(c, a);
        });
      }
      var zk = Sc(ot), Vk = Sc(Lp), Hk = Sc(Xu);
      function Nm(a) {
        return Ic(a) ? Zu(Dr(a)) : yw(a);
      }
      function Wk(a) {
        return function(c) {
          return a == null ? t : zi(a, c);
        };
      }
      var Uk = Ph(), jk = Ph(!0);
      function Yc() {
        return [];
      }
      function Xc() {
        return !1;
      }
      function qk() {
        return {};
      }
      function Kk() {
        return "";
      }
      function Gk() {
        return !0;
      }
      function Jk(a, c) {
        if (a = Se(a), a < 1 || a > De)
          return [];
        var p = je, v = zt(a, je);
        c = he(c), a -= je;
        for (var _ = tc(v, c); ++p < a; )
          c(p);
        return _;
      }
      function Yk(a) {
        return xe(a) ? ot(a, Dr) : Cn(a) ? [a] : cn(tm(We(a)));
      }
      function Xk(a) {
        var c = ++l_;
        return We(a) + c;
      }
      var Zk = nl(function(a, c) {
        return a + c;
      }, 0), Qk = Ac("ceil"), eS = nl(function(a, c) {
        return a / c;
      }, 1), tS = Ac("floor");
      function nS(a) {
        return a && a.length ? Ja(a, pn, fc) : t;
      }
      function rS(a, c) {
        return a && a.length ? Ja(a, he(c, 2), fc) : t;
      }
      function iS(a) {
        return Vp(a, pn);
      }
      function sS(a, c) {
        return Vp(a, he(c, 2));
      }
      function oS(a) {
        return a && a.length ? Ja(a, pn, gc) : t;
      }
      function aS(a, c) {
        return a && a.length ? Ja(a, he(c, 2), gc) : t;
      }
      var lS = nl(function(a, c) {
        return a * c;
      }, 1), uS = Ac("round"), cS = nl(function(a, c) {
        return a - c;
      }, 0);
      function dS(a) {
        return a && a.length ? ec(a, pn) : 0;
      }
      function fS(a, c) {
        return a && a.length ? ec(a, he(c, 2)) : 0;
      }
      return D.after = RC, D.ary = fm, D.assign = wx, D.assignIn = Sm, D.assignInWith = ml, D.assignWith = Dx, D.at = Cx, D.before = pm, D.bind = Pc, D.bindAll = Ek, D.bindKey = hm, D.castArray = qC, D.chain = um, D.chunk = tD, D.compact = nD, D.concat = rD, D.cond = Tk, D.conforms = Mk, D.constant = qc, D.countBy = dC, D.create = xx, D.curry = mm, D.curryRight = gm, D.debounce = vm, D.defaults = kx, D.defaultsDeep = Sx, D.defer = NC, D.delay = BC, D.difference = iD, D.differenceBy = sD, D.differenceWith = oD, D.drop = aD, D.dropRight = lD, D.dropRightWhile = uD, D.dropWhile = cD, D.fill = dD, D.filter = pC, D.flatMap = gC, D.flatMapDeep = vC, D.flatMapDepth = yC, D.flatten = sm, D.flattenDeep = fD, D.flattenDepth = pD, D.flip = $C, D.flow = Fk, D.flowRight = Ik, D.fromPairs = hD, D.functions = Ix, D.functionsIn = Rx, D.groupBy = bC, D.initial = gD, D.intersection = vD, D.intersectionBy = yD, D.intersectionWith = bD, D.invert = Bx, D.invertBy = $x, D.invokeMap = wC, D.iteratee = Kc, D.keyBy = DC, D.keys = St, D.keysIn = fn, D.map = ul, D.mapKeys = Px, D.mapValues = zx, D.matches = Rk, D.matchesProperty = Nk, D.memoize = dl, D.merge = Vx, D.mergeWith = Am, D.method = Bk, D.methodOf = $k, D.mixin = Gc, D.negate = fl, D.nthArg = Pk, D.omit = Hx, D.omitBy = Wx, D.once = LC, D.orderBy = CC, D.over = zk, D.overArgs = PC, D.overEvery = Vk, D.overSome = Hk, D.partial = zc, D.partialRight = ym, D.partition = xC, D.pick = Ux, D.pickBy = Em, D.property = Nm, D.propertyOf = Wk, D.pull = CD, D.pullAll = am, D.pullAllBy = xD, D.pullAllWith = kD, D.pullAt = SD, D.range = Uk, D.rangeRight = jk, D.rearg = zC, D.reject = AC, D.remove = AD, D.rest = VC, D.reverse = $c, D.sampleSize = TC, D.set = qx, D.setWith = Kx, D.shuffle = MC, D.slice = ED, D.sortBy = IC, D.sortedUniq = ND, D.sortedUniqBy = BD, D.split = gk, D.spread = HC, D.tail = $D, D.take = LD, D.takeRight = PD, D.takeRightWhile = zD, D.takeWhile = VD, D.tap = nC, D.throttle = WC, D.thru = ll, D.toArray = Cm, D.toPairs = Tm, D.toPairsIn = Mm, D.toPath = Yk, D.toPlainObject = km, D.transform = Gx, D.unary = UC, D.union = HD, D.unionBy = WD, D.unionWith = UD, D.uniq = jD, D.uniqBy = qD, D.uniqWith = KD, D.unset = Jx, D.unzip = Lc, D.unzipWith = lm, D.update = Yx, D.updateWith = Xx, D.values = Is, D.valuesIn = Zx, D.without = GD, D.words = Im, D.wrap = jC, D.xor = JD, D.xorBy = YD, D.xorWith = XD, D.zip = ZD, D.zipObject = QD, D.zipObjectDeep = eC, D.zipWith = tC, D.entries = Tm, D.entriesIn = Mm, D.extend = Sm, D.extendWith = ml, Gc(D, D), D.add = Zk, D.attempt = Rm, D.camelCase = nk, D.capitalize = Om, D.ceil = Qk, D.clamp = Qx, D.clone = KC, D.cloneDeep = JC, D.cloneDeepWith = YC, D.cloneWith = GC, D.conformsTo = XC, D.deburr = Fm, D.defaultTo = Ok, D.divide = eS, D.endsWith = rk, D.eq = sr, D.escape = ik, D.escapeRegExp = sk, D.every = fC, D.find = hC, D.findIndex = rm, D.findKey = Ax, D.findLast = mC, D.findLastIndex = im, D.findLastKey = Ex, D.floor = tS, D.forEach = cm, D.forEachRight = dm, D.forIn = Tx, D.forInRight = Mx, D.forOwn = Ox, D.forOwnRight = Fx, D.get = Wc, D.gt = ZC, D.gte = QC, D.has = Nx, D.hasIn = Uc, D.head = om, D.identity = pn, D.includes = _C, D.indexOf = mD, D.inRange = ek, D.invoke = Lx, D.isArguments = Wi, D.isArray = xe, D.isArrayBuffer = ex, D.isArrayLike = dn, D.isArrayLikeObject = pt, D.isBoolean = tx, D.isBuffer = li, D.isDate = nx, D.isElement = rx, D.isEmpty = ix, D.isEqual = sx, D.isEqualWith = ox, D.isError = Vc, D.isFinite = ax, D.isFunction = Hr, D.isInteger = bm, D.isLength = pl, D.isMap = _m, D.isMatch = lx, D.isMatchWith = ux, D.isNaN = cx, D.isNative = dx, D.isNil = px, D.isNull = fx, D.isNumber = wm, D.isObject = at, D.isObjectLike = ut, D.isPlainObject = Vo, D.isRegExp = Hc, D.isSafeInteger = hx, D.isSet = Dm, D.isString = hl, D.isSymbol = Cn, D.isTypedArray = Fs, D.isUndefined = mx, D.isWeakMap = gx, D.isWeakSet = vx, D.join = _D, D.kebabCase = ok, D.last = Vn, D.lastIndexOf = wD, D.lowerCase = ak, D.lowerFirst = lk, D.lt = yx, D.lte = bx, D.max = nS, D.maxBy = rS, D.mean = iS, D.meanBy = sS, D.min = oS, D.minBy = aS, D.stubArray = Yc, D.stubFalse = Xc, D.stubObject = qk, D.stubString = Kk, D.stubTrue = Gk, D.multiply = lS, D.nth = DD, D.noConflict = Lk, D.noop = Jc, D.now = cl, D.pad = uk, D.padEnd = ck, D.padStart = dk, D.parseInt = fk, D.random = tk, D.reduce = kC, D.reduceRight = SC, D.repeat = pk, D.replace = hk, D.result = jx, D.round = uS, D.runInContext = N, D.sample = EC, D.size = OC, D.snakeCase = mk, D.some = FC, D.sortedIndex = TD, D.sortedIndexBy = MD, D.sortedIndexOf = OD, D.sortedLastIndex = FD, D.sortedLastIndexBy = ID, D.sortedLastIndexOf = RD, D.startCase = vk, D.startsWith = yk, D.subtract = cS, D.sum = dS, D.sumBy = fS, D.template = bk, D.times = Jk, D.toFinite = Wr, D.toInteger = Se, D.toLength = xm, D.toLower = _k, D.toNumber = Hn, D.toSafeInteger = _x, D.toString = We, D.toUpper = wk, D.trim = Dk, D.trimEnd = Ck, D.trimStart = xk, D.truncate = kk, D.unescape = Sk, D.uniqueId = Xk, D.upperCase = Ak, D.upperFirst = jc, D.each = cm, D.eachRight = dm, D.first = om, Gc(D, function() {
        var a = {};
        return _r(D, function(c, p) {
          qe.call(D.prototype, p) || (a[p] = c);
        }), a;
      }(), { chain: !1 }), D.VERSION = r, Bn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(a) {
        D[a].placeholder = D;
      }), Bn(["drop", "take"], function(a, c) {
        Ne.prototype[a] = function(p) {
          p = p === t ? 1 : Ct(Se(p), 0);
          var v = this.__filtered__ && !c ? new Ne(this) : this.clone();
          return v.__filtered__ ? v.__takeCount__ = zt(p, v.__takeCount__) : v.__views__.push({
            size: zt(p, je),
            type: a + (v.__dir__ < 0 ? "Right" : "")
          }), v;
        }, Ne.prototype[a + "Right"] = function(p) {
          return this.reverse()[a](p).reverse();
        };
      }), Bn(["filter", "map", "takeWhile"], function(a, c) {
        var p = c + 1, v = p == rt || p == Ke;
        Ne.prototype[a] = function(_) {
          var x = this.clone();
          return x.__iteratees__.push({
            iteratee: he(_, 3),
            type: p
          }), x.__filtered__ = x.__filtered__ || v, x;
        };
      }), Bn(["head", "last"], function(a, c) {
        var p = "take" + (c ? "Right" : "");
        Ne.prototype[a] = function() {
          return this[p](1).value()[0];
        };
      }), Bn(["initial", "tail"], function(a, c) {
        var p = "drop" + (c ? "" : "Right");
        Ne.prototype[a] = function() {
          return this.__filtered__ ? new Ne(this) : this[p](1);
        };
      }), Ne.prototype.compact = function() {
        return this.filter(pn);
      }, Ne.prototype.find = function(a) {
        return this.filter(a).head();
      }, Ne.prototype.findLast = function(a) {
        return this.reverse().find(a);
      }, Ne.prototype.invokeMap = Fe(function(a, c) {
        return typeof a == "function" ? new Ne(this) : this.map(function(p) {
          return No(p, a, c);
        });
      }), Ne.prototype.reject = function(a) {
        return this.filter(fl(he(a)));
      }, Ne.prototype.slice = function(a, c) {
        a = Se(a);
        var p = this;
        return p.__filtered__ && (a > 0 || c < 0) ? new Ne(p) : (a < 0 ? p = p.takeRight(-a) : a && (p = p.drop(a)), c !== t && (c = Se(c), p = c < 0 ? p.dropRight(-c) : p.take(c - a)), p);
      }, Ne.prototype.takeRightWhile = function(a) {
        return this.reverse().takeWhile(a).reverse();
      }, Ne.prototype.toArray = function() {
        return this.take(je);
      }, _r(Ne.prototype, function(a, c) {
        var p = /^(?:filter|find|map|reject)|While$/.test(c), v = /^(?:head|last)$/.test(c), _ = D[v ? "take" + (c == "last" ? "Right" : "") : c], x = v || /^find/.test(c);
        _ && (D.prototype[c] = function() {
          var A = this.__wrapped__, M = v ? [1] : arguments, B = A instanceof Ne, H = M[0], W = B || xe(A), j = function(Ie) {
            var $e = _.apply(D, ti([Ie], M));
            return v && Q ? $e[0] : $e;
          };
          W && p && typeof H == "function" && H.length != 1 && (B = W = !1);
          var Q = this.__chain__, le = !!this.__actions__.length, ye = x && !Q, Me = B && !le;
          if (!x && W) {
            A = Me ? A : new Ne(this);
            var be = a.apply(A, M);
            return be.__actions__.push({ func: ll, args: [j], thisArg: t }), new Ln(be, Q);
          }
          return ye && Me ? a.apply(this, M) : (be = this.thru(j), ye ? v ? be.value()[0] : be.value() : be);
        });
      }), Bn(["pop", "push", "shift", "sort", "splice", "unshift"], function(a) {
        var c = Ra[a], p = /^(?:push|sort|unshift)$/.test(a) ? "tap" : "thru", v = /^(?:pop|shift)$/.test(a);
        D.prototype[a] = function() {
          var _ = arguments;
          if (v && !this.__chain__) {
            var x = this.value();
            return c.apply(xe(x) ? x : [], _);
          }
          return this[p](function(A) {
            return c.apply(xe(A) ? A : [], _);
          });
        };
      }), _r(Ne.prototype, function(a, c) {
        var p = D[c];
        if (p) {
          var v = p.name + "";
          qe.call(As, v) || (As[v] = []), As[v].push({ name: c, func: p });
        }
      }), As[tl(t, T).name] = [{
        name: "wrapper",
        func: t
      }], Ne.prototype.clone = S_, Ne.prototype.reverse = A_, Ne.prototype.value = E_, D.prototype.at = rC, D.prototype.chain = iC, D.prototype.commit = sC, D.prototype.next = oC, D.prototype.plant = lC, D.prototype.reverse = uC, D.prototype.toJSON = D.prototype.valueOf = D.prototype.value = cC, D.prototype.first = D.prototype.head, Eo && (D.prototype[Eo] = aC), D;
    }, xs = s_();
    Ni ? ((Ni.exports = xs)._ = xs, Ku._ = xs) : Ft._ = xs;
  }).call(Xi);
})(AL, eu);
var EL = "tippy-box", ub = "tippy-content", TL = "tippy-backdrop", cb = "tippy-arrow", db = "tippy-svg-arrow", Gi = {
  passive: !0,
  capture: !0
}, fb = function() {
  return document.body;
};
function ML(n, e) {
  return {}.hasOwnProperty.call(n, e);
}
function Dd(n, e, t) {
  if (Array.isArray(n)) {
    var r = n[e];
    return r ?? (Array.isArray(t) ? t[e] : t);
  }
  return n;
}
function Qf(n, e) {
  var t = {}.toString.call(n);
  return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1;
}
function pb(n, e) {
  return typeof n == "function" ? n.apply(void 0, e) : n;
}
function mv(n, e) {
  if (e === 0)
    return n;
  var t;
  return function(r) {
    clearTimeout(t), t = setTimeout(function() {
      n(r);
    }, e);
  };
}
function OL(n, e) {
  var t = Object.assign({}, n);
  return e.forEach(function(r) {
    delete t[r];
  }), t;
}
function FL(n) {
  return n.split(/\s+/).filter(Boolean);
}
function Ls(n) {
  return [].concat(n);
}
function gv(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function IL(n) {
  return n.filter(function(e, t) {
    return n.indexOf(e) === t;
  });
}
function RL(n) {
  return n.split("-")[0];
}
function tu(n) {
  return [].slice.call(n);
}
function vv(n) {
  return Object.keys(n).reduce(function(e, t) {
    return n[t] !== void 0 && (e[t] = n[t]), e;
  }, {});
}
function sa() {
  return document.createElement("div");
}
function va(n) {
  return ["Element", "Fragment"].some(function(e) {
    return Qf(n, e);
  });
}
function NL(n) {
  return Qf(n, "NodeList");
}
function BL(n) {
  return Qf(n, "MouseEvent");
}
function $L(n) {
  return !!(n && n._tippy && n._tippy.reference === n);
}
function LL(n) {
  return va(n) ? [n] : NL(n) ? tu(n) : Array.isArray(n) ? n : tu(document.querySelectorAll(n));
}
function Cd(n, e) {
  n.forEach(function(t) {
    t && (t.style.transitionDuration = e + "ms");
  });
}
function yv(n, e) {
  n.forEach(function(t) {
    t && t.setAttribute("data-state", e);
  });
}
function PL(n) {
  var e, t = Ls(n), r = t[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function zL(n, e) {
  var t = e.clientX, r = e.clientY;
  return n.every(function(i) {
    var s = i.popperRect, o = i.popperState, l = i.props, u = l.interactiveBorder, d = RL(o.placement), f = o.modifiersData.offset;
    if (!f)
      return !0;
    var h = d === "bottom" ? f.top.y : 0, m = d === "top" ? f.bottom.y : 0, g = d === "right" ? f.left.x : 0, y = d === "left" ? f.right.x : 0, b = s.top - r + h > u, w = r - s.bottom - m > u, T = s.left - t + g > u, k = t - s.right - y > u;
    return b || w || T || k;
  });
}
function xd(n, e, t) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    n[r](i, t);
  });
}
function bv(n, e) {
  for (var t = e; t; ) {
    var r;
    if (n.contains(t))
      return !0;
    t = t.getRootNode == null || (r = t.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var kr = {
  isTouch: !1
}, _v = 0;
function VL() {
  kr.isTouch || (kr.isTouch = !0, window.performance && document.addEventListener("mousemove", hb));
}
function hb() {
  var n = performance.now();
  n - _v < 20 && (kr.isTouch = !1, document.removeEventListener("mousemove", hb)), _v = n;
}
function HL() {
  var n = document.activeElement;
  if ($L(n)) {
    var e = n._tippy;
    n.blur && !e.state.isVisible && n.blur();
  }
}
function WL() {
  document.addEventListener("touchstart", VL, Gi), window.addEventListener("blur", HL);
}
var UL = typeof window < "u" && typeof document < "u", jL = UL ? !!window.msCrypto : !1;
function Ns(n) {
  var e = n === "destroy" ? "n already-" : " ";
  return [n + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function wv(n) {
  var e = /[ \t]{2,}/g, t = /^[ \t]*/gm;
  return n.replace(e, " ").replace(t, "").trim();
}
function qL(n) {
  return wv(`
  %ctippy.js

  %c` + wv(n) + `

  %c This is a development-only message. It will be removed in production.
  `);
}
function mb(n) {
  return [
    qL(n),
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    "line-height: 1.5",
    "color: #a6a095;"
  ];
}
var ya;
process.env.NODE_ENV !== "production" && KL();
function KL() {
  ya = /* @__PURE__ */ new Set();
}
function qr(n, e) {
  if (n && !ya.has(e)) {
    var t;
    ya.add(e), (t = console).warn.apply(t, mb(e));
  }
}
function sf(n, e) {
  if (n && !ya.has(e)) {
    var t;
    ya.add(e), (t = console).error.apply(t, mb(e));
  }
}
function GL(n) {
  var e = !n, t = Object.prototype.toString.call(n) === "[object Object]" && !n.addEventListener;
  sf(e, ["tippy() was passed", "`" + String(n) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), sf(t, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var gb = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, JL = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, An = Object.assign({
  appendTo: fb,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, gb, JL), YL = Object.keys(An), XL = function(e) {
  process.env.NODE_ENV !== "production" && yb(e, []);
  var t = Object.keys(e);
  t.forEach(function(r) {
    An[r] = e[r];
  });
};
function vb(n) {
  var e = n.plugins || [], t = e.reduce(function(r, i) {
    var s = i.name, o = i.defaultValue;
    if (s) {
      var l;
      r[s] = n[s] !== void 0 ? n[s] : (l = An[s]) != null ? l : o;
    }
    return r;
  }, {});
  return Object.assign({}, n, t);
}
function ZL(n, e) {
  var t = e ? Object.keys(vb(Object.assign({}, An, {
    plugins: e
  }))) : YL, r = t.reduce(function(i, s) {
    var o = (n.getAttribute("data-tippy-" + s) || "").trim();
    if (!o)
      return i;
    if (s === "content")
      i[s] = o;
    else
      try {
        i[s] = JSON.parse(o);
      } catch {
        i[s] = o;
      }
    return i;
  }, {});
  return r;
}
function Dv(n, e) {
  var t = Object.assign({}, e, {
    content: pb(e.content, [n])
  }, e.ignoreAttributes ? {} : ZL(n, e.plugins));
  return t.aria = Object.assign({}, An.aria, t.aria), t.aria = {
    expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded,
    content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content
  }, t;
}
function yb(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = []);
  var t = Object.keys(n);
  t.forEach(function(r) {
    var i = OL(An, Object.keys(gb)), s = !ML(i, r);
    s && (s = e.filter(function(o) {
      return o.name === r;
    }).length === 0), qr(s, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var QL = function() {
  return "innerHTML";
};
function of(n, e) {
  n[QL()] = e;
}
function Cv(n) {
  var e = sa();
  return n === !0 ? e.className = cb : (e.className = db, va(n) ? e.appendChild(n) : of(e, n)), e;
}
function xv(n, e) {
  va(e.content) ? (of(n, ""), n.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? of(n, e.content) : n.textContent = e.content);
}
function af(n) {
  var e = n.firstElementChild, t = tu(e.children);
  return {
    box: e,
    content: t.find(function(r) {
      return r.classList.contains(ub);
    }),
    arrow: t.find(function(r) {
      return r.classList.contains(cb) || r.classList.contains(db);
    }),
    backdrop: t.find(function(r) {
      return r.classList.contains(TL);
    })
  };
}
function bb(n) {
  var e = sa(), t = sa();
  t.className = EL, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1");
  var r = sa();
  r.className = ub, r.setAttribute("data-state", "hidden"), xv(r, n.props), e.appendChild(t), t.appendChild(r), i(n.props, n.props);
  function i(s, o) {
    var l = af(e), u = l.box, d = l.content, f = l.arrow;
    o.theme ? u.setAttribute("data-theme", o.theme) : u.removeAttribute("data-theme"), typeof o.animation == "string" ? u.setAttribute("data-animation", o.animation) : u.removeAttribute("data-animation"), o.inertia ? u.setAttribute("data-inertia", "") : u.removeAttribute("data-inertia"), u.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? u.setAttribute("role", o.role) : u.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && xv(d, n.props), o.arrow ? f ? s.arrow !== o.arrow && (u.removeChild(f), u.appendChild(Cv(o.arrow))) : u.appendChild(Cv(o.arrow)) : f && u.removeChild(f);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
bb.$$tippy = !0;
var eP = 1, xl = [], kd = [];
function tP(n, e) {
  var t = Dv(n, Object.assign({}, An, vb(vv(e)))), r, i, s, o = !1, l = !1, u = !1, d = !1, f, h, m, g = [], y = mv(Pt, t.interactiveDebounce), b, w = eP++, T = null, k = IL(t.plugins), S = {
    isEnabled: !0,
    isVisible: !1,
    isDestroyed: !1,
    isMounted: !1,
    isShown: !1
  }, C = {
    id: w,
    reference: n,
    popper: sa(),
    popperInstance: T,
    props: t,
    state: S,
    plugins: k,
    clearDelayTimeouts: vs,
    setProps: br,
    setContent: nr,
    show: bo,
    hide: _o,
    hideWithInteractivity: wo,
    enable: Ri,
    disable: yr,
    unmount: Do,
    destroy: Co
  };
  if (!t.render)
    return process.env.NODE_ENV !== "production" && sf(!0, "render() function has not been supplied."), C;
  var R = t.render(C), I = R.popper, P = R.onUpdate;
  I.setAttribute("data-tippy-root", ""), I.id = "tippy-" + C.id, C.popper = I, n._tippy = C, I._tippy = C;
  var L = k.map(function(z) {
    return z.fn(C);
  }), q = n.hasAttribute("aria-expanded");
  return Lt(), Oe(), He(), De("onCreate", [C]), t.showOnCreate && tr(), I.addEventListener("mouseenter", function() {
    C.props.interactive && C.state.isVisible && C.clearDelayTimeouts();
  }), I.addEventListener("mouseleave", function() {
    C.props.interactive && C.props.trigger.indexOf("mouseenter") >= 0 && rt().addEventListener("mousemove", y);
  }), C;
  function oe() {
    var z = C.props.touch;
    return Array.isArray(z) ? z : [z, 0];
  }
  function ae() {
    return oe()[0] === "hold";
  }
  function ke() {
    var z;
    return !!((z = C.props.render) != null && z.$$tippy);
  }
  function Ee() {
    return b || n;
  }
  function rt() {
    var z = Ee().parentNode;
    return z ? PL(z) : document;
  }
  function Qe() {
    return af(I);
  }
  function Ke(z) {
    return C.state.isMounted && !C.state.isVisible || kr.isTouch || f && f.type === "focus" ? 0 : Dd(C.props.delay, z ? 0 : 1, An.delay);
  }
  function He(z) {
    z === void 0 && (z = !1), I.style.pointerEvents = C.props.interactive && !z ? "" : "none", I.style.zIndex = "" + C.props.zIndex;
  }
  function De(z, ie, pe) {
    if (pe === void 0 && (pe = !0), L.forEach(function(Be) {
      Be[z] && Be[z].apply(Be, ie);
    }), pe) {
      var Pe;
      (Pe = C.props)[z].apply(Pe, ie);
    }
  }
  function Te() {
    var z = C.props.aria;
    if (z.content) {
      var ie = "aria-" + z.content, pe = I.id, Pe = Ls(C.props.triggerTarget || n);
      Pe.forEach(function(Be) {
        var Ot = Be.getAttribute(ie);
        if (C.state.isVisible)
          Be.setAttribute(ie, Ot ? Ot + " " + pe : pe);
        else {
          var un = Ot && Ot.replace(pe, "").trim();
          un ? Be.setAttribute(ie, un) : Be.removeAttribute(ie);
        }
      });
    }
  }
  function Oe() {
    if (!(q || !C.props.aria.expanded)) {
      var z = Ls(C.props.triggerTarget || n);
      z.forEach(function(ie) {
        C.props.interactive ? ie.setAttribute("aria-expanded", C.state.isVisible && ie === Ee() ? "true" : "false") : ie.removeAttribute("aria-expanded");
      });
    }
  }
  function je() {
    rt().removeEventListener("mousemove", y), xl = xl.filter(function(z) {
      return z !== y;
    });
  }
  function it(z) {
    if (!(kr.isTouch && (u || z.type === "mousedown"))) {
      var ie = z.composedPath && z.composedPath()[0] || z.target;
      if (!(C.props.interactive && bv(I, ie))) {
        if (Ls(C.props.triggerTarget || n).some(function(pe) {
          return bv(pe, ie);
        })) {
          if (kr.isTouch || C.state.isVisible && C.props.trigger.indexOf("click") >= 0)
            return;
        } else
          De("onClickOutside", [C, z]);
        C.props.hideOnClick === !0 && (C.clearDelayTimeouts(), C.hide(), l = !0, setTimeout(function() {
          l = !1;
        }), C.state.isMounted || _t());
      }
    }
  }
  function Qn() {
    u = !0;
  }
  function gt() {
    u = !1;
  }
  function st() {
    var z = rt();
    z.addEventListener("mousedown", it, !0), z.addEventListener("touchend", it, Gi), z.addEventListener("touchstart", gt, Gi), z.addEventListener("touchmove", Qn, Gi);
  }
  function _t() {
    var z = rt();
    z.removeEventListener("mousedown", it, !0), z.removeEventListener("touchend", it, Gi), z.removeEventListener("touchstart", gt, Gi), z.removeEventListener("touchmove", Qn, Gi);
  }
  function bn(z, ie) {
    Jt(z, function() {
      !C.state.isVisible && I.parentNode && I.parentNode.contains(I) && ie();
    });
  }
  function wt(z, ie) {
    Jt(z, ie);
  }
  function Jt(z, ie) {
    var pe = Qe().box;
    function Pe(Be) {
      Be.target === pe && (xd(pe, "remove", Pe), ie());
    }
    if (z === 0)
      return ie();
    xd(pe, "remove", h), xd(pe, "add", Pe), h = Pe;
  }
  function ln(z, ie, pe) {
    pe === void 0 && (pe = !1);
    var Pe = Ls(C.props.triggerTarget || n);
    Pe.forEach(function(Be) {
      Be.addEventListener(z, ie, pe), g.push({
        node: Be,
        eventType: z,
        handler: ie,
        options: pe
      });
    });
  }
  function Lt() {
    ae() && (ln("touchstart", In, {
      passive: !0
    }), ln("touchend", vr, {
      passive: !0
    })), FL(C.props.trigger).forEach(function(z) {
      if (z !== "manual")
        switch (ln(z, In), z) {
          case "mouseenter":
            ln("mouseleave", vr);
            break;
          case "focus":
            ln(jL ? "focusout" : "blur", Fi);
            break;
          case "focusin":
            ln("focusout", Fi);
            break;
        }
    });
  }
  function er() {
    g.forEach(function(z) {
      var ie = z.node, pe = z.eventType, Pe = z.handler, Be = z.options;
      ie.removeEventListener(pe, Pe, Be);
    }), g = [];
  }
  function In(z) {
    var ie, pe = !1;
    if (!(!C.state.isEnabled || Yt(z) || l)) {
      var Pe = ((ie = f) == null ? void 0 : ie.type) === "focus";
      f = z, b = z.currentTarget, Oe(), !C.state.isVisible && BL(z) && xl.forEach(function(Be) {
        return Be(z);
      }), z.type === "click" && (C.props.trigger.indexOf("mouseenter") < 0 || o) && C.props.hideOnClick !== !1 && C.state.isVisible ? pe = !0 : tr(z), z.type === "click" && (o = !pe), pe && !Pe && Rn(z);
    }
  }
  function Pt(z) {
    var ie = z.target, pe = Ee().contains(ie) || I.contains(ie);
    if (!(z.type === "mousemove" && pe)) {
      var Pe = vt().concat(I).map(function(Be) {
        var Ot, un = Be._tippy, Rr = (Ot = un.popperInstance) == null ? void 0 : Ot.state;
        return Rr ? {
          popperRect: Be.getBoundingClientRect(),
          popperState: Rr,
          props: t
        } : null;
      }).filter(Boolean);
      zL(Pe, z) && (je(), Rn(z));
    }
  }
  function vr(z) {
    var ie = Yt(z) || C.props.trigger.indexOf("click") >= 0 && o;
    if (!ie) {
      if (C.props.interactive) {
        C.hideWithInteractivity(z);
        return;
      }
      Rn(z);
    }
  }
  function Fi(z) {
    C.props.trigger.indexOf("focusin") < 0 && z.target !== Ee() || C.props.interactive && z.relatedTarget && I.contains(z.relatedTarget) || Rn(z);
  }
  function Yt(z) {
    return kr.isTouch ? ae() !== z.type.indexOf("touch") >= 0 : !1;
  }
  function Ii() {
    gs();
    var z = C.props, ie = z.popperOptions, pe = z.placement, Pe = z.offset, Be = z.getReferenceClientRect, Ot = z.moveTransition, un = ke() ? af(I).arrow : null, Rr = Be ? {
      getBoundingClientRect: Be,
      contextElement: Be.contextElement || Ee()
    } : n, xo = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(ys) {
        var Qr = ys.state;
        if (ke()) {
          var Aa = Qe(), So = Aa.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(bs) {
            bs === "placement" ? So.setAttribute("data-placement", Qr.placement) : Qr.attributes.popper["data-popper-" + bs] ? So.setAttribute("data-" + bs, "") : So.removeAttribute("data-" + bs);
          }), Qr.attributes.popper = {};
        }
      }
    }, Nr = [{
      name: "offset",
      options: {
        offset: Pe
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Ot
      }
    }, xo];
    ke() && un && Nr.push({
      name: "arrow",
      options: {
        element: un,
        padding: 3
      }
    }), Nr.push.apply(Nr, (ie == null ? void 0 : ie.modifiers) || []), C.popperInstance = _0(Rr, I, Object.assign({}, ie, {
      placement: pe,
      onFirstUpdate: m,
      modifiers: Nr
    }));
  }
  function gs() {
    C.popperInstance && (C.popperInstance.destroy(), C.popperInstance = null);
  }
  function Xt() {
    var z = C.props.appendTo, ie, pe = Ee();
    C.props.interactive && z === fb || z === "parent" ? ie = pe.parentNode : ie = pb(z, [pe]), ie.contains(I) || ie.appendChild(I), C.state.isMounted = !0, Ii(), process.env.NODE_ENV !== "production" && qr(C.props.interactive && z === An.appendTo && pe.nextElementSibling !== I, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function vt() {
    return tu(I.querySelectorAll("[data-tippy-root]"));
  }
  function tr(z) {
    C.clearDelayTimeouts(), z && De("onTrigger", [C, z]), st();
    var ie = Ke(!0), pe = oe(), Pe = pe[0], Be = pe[1];
    kr.isTouch && Pe === "hold" && Be && (ie = Be), ie ? r = setTimeout(function() {
      C.show();
    }, ie) : C.show();
  }
  function Rn(z) {
    if (C.clearDelayTimeouts(), De("onUntrigger", [C, z]), !C.state.isVisible) {
      _t();
      return;
    }
    if (!(C.props.trigger.indexOf("mouseenter") >= 0 && C.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(z.type) >= 0 && o)) {
      var ie = Ke(!1);
      ie ? i = setTimeout(function() {
        C.state.isVisible && C.hide();
      }, ie) : s = requestAnimationFrame(function() {
        C.hide();
      });
    }
  }
  function Ri() {
    C.state.isEnabled = !0;
  }
  function yr() {
    C.hide(), C.state.isEnabled = !1;
  }
  function vs() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(s);
  }
  function br(z) {
    if (process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("setProps")), !C.state.isDestroyed) {
      De("onBeforeUpdate", [C, z]), er();
      var ie = C.props, pe = Dv(n, Object.assign({}, ie, vv(z), {
        ignoreAttributes: !0
      }));
      C.props = pe, Lt(), ie.interactiveDebounce !== pe.interactiveDebounce && (je(), y = mv(Pt, pe.interactiveDebounce)), ie.triggerTarget && !pe.triggerTarget ? Ls(ie.triggerTarget).forEach(function(Pe) {
        Pe.removeAttribute("aria-expanded");
      }) : pe.triggerTarget && n.removeAttribute("aria-expanded"), Oe(), He(), P && P(ie, pe), C.popperInstance && (Ii(), vt().forEach(function(Pe) {
        requestAnimationFrame(Pe._tippy.popperInstance.forceUpdate);
      })), De("onAfterUpdate", [C, z]);
    }
  }
  function nr(z) {
    C.setProps({
      content: z
    });
  }
  function bo() {
    process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("show"));
    var z = C.state.isVisible, ie = C.state.isDestroyed, pe = !C.state.isEnabled, Pe = kr.isTouch && !C.props.touch, Be = Dd(C.props.duration, 0, An.duration);
    if (!(z || ie || pe || Pe) && !Ee().hasAttribute("disabled") && (De("onShow", [C], !1), C.props.onShow(C) !== !1)) {
      if (C.state.isVisible = !0, ke() && (I.style.visibility = "visible"), He(), st(), C.state.isMounted || (I.style.transition = "none"), ke()) {
        var Ot = Qe(), un = Ot.box, Rr = Ot.content;
        Cd([un, Rr], 0);
      }
      m = function() {
        var Nr;
        if (!(!C.state.isVisible || d)) {
          if (d = !0, I.style.transition = C.props.moveTransition, ke() && C.props.animation) {
            var ko = Qe(), ys = ko.box, Qr = ko.content;
            Cd([ys, Qr], Be), yv([ys, Qr], "visible");
          }
          Te(), Oe(), gv(kd, C), (Nr = C.popperInstance) == null || Nr.forceUpdate(), De("onMount", [C]), C.props.animation && ke() && wt(Be, function() {
            C.state.isShown = !0, De("onShown", [C]);
          });
        }
      }, Xt();
    }
  }
  function _o() {
    process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("hide"));
    var z = !C.state.isVisible, ie = C.state.isDestroyed, pe = !C.state.isEnabled, Pe = Dd(C.props.duration, 1, An.duration);
    if (!(z || ie || pe) && (De("onHide", [C], !1), C.props.onHide(C) !== !1)) {
      if (C.state.isVisible = !1, C.state.isShown = !1, d = !1, o = !1, ke() && (I.style.visibility = "hidden"), je(), _t(), He(!0), ke()) {
        var Be = Qe(), Ot = Be.box, un = Be.content;
        C.props.animation && (Cd([Ot, un], Pe), yv([Ot, un], "hidden"));
      }
      Te(), Oe(), C.props.animation ? ke() && bn(Pe, C.unmount) : C.unmount();
    }
  }
  function wo(z) {
    process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("hideWithInteractivity")), rt().addEventListener("mousemove", y), gv(xl, y), y(z);
  }
  function Do() {
    process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("unmount")), C.state.isVisible && C.hide(), C.state.isMounted && (gs(), vt().forEach(function(z) {
      z._tippy.unmount();
    }), I.parentNode && I.parentNode.removeChild(I), kd = kd.filter(function(z) {
      return z !== C;
    }), C.state.isMounted = !1, De("onHidden", [C]));
  }
  function Co() {
    process.env.NODE_ENV !== "production" && qr(C.state.isDestroyed, Ns("destroy")), !C.state.isDestroyed && (C.clearDelayTimeouts(), C.unmount(), er(), delete n._tippy, C.state.isDestroyed = !0, De("onDestroy", [C]));
  }
}
function vo(n, e) {
  e === void 0 && (e = {});
  var t = An.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (GL(n), yb(e, t)), WL();
  var r = Object.assign({}, e, {
    plugins: t
  }), i = LL(n);
  if (process.env.NODE_ENV !== "production") {
    var s = va(r.content), o = i.length > 1;
    qr(s && o, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var l = i.reduce(function(u, d) {
    var f = d && tP(d, r);
    return f && u.push(f), u;
  }, []);
  return va(n) ? l[0] : l;
}
vo.defaultProps = An;
vo.setDefaultProps = XL;
vo.currentInput = kr;
Object.assign({}, f0, {
  effect: function(e) {
    var t = e.state, r = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow);
  }
});
vo.setDefaultProps({
  render: bb
});
class nP {
  constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, updateDelay: s = 250, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: l, state: u, from: d, to: f }) => {
      const { doc: h, selection: m } = u, { empty: g } = m, y = !h.textBetween(d, f).length && Kf(u.selection), b = this.element.contains(document.activeElement);
      return !(!(l.hasFocus() || b) || g || y || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: l }) => {
      var u;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      l != null && l.relatedTarget && (!((u = this.element.parentNode) === null || u === void 0) && u.contains(l.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (l) => {
      this.blurHandler({ event: l });
    }, this.updateHandler = (l, u) => {
      var d, f, h;
      const { state: m, composing: g } = l, { doc: y, selection: b } = m, w = u && u.doc.eq(y) && u.selection.eq(b);
      if (g || w)
        return;
      this.createTooltip();
      const { ranges: T } = b, k = Math.min(...T.map((R) => R.$from.pos)), S = Math.max(...T.map((R) => R.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        view: l,
        state: m,
        oldState: u,
        from: k,
        to: S
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((h = this.tippyOptions) === null || h === void 0 ? void 0 : h.getReferenceClientRect) || (() => {
          if (X$(m.selection)) {
            const R = l.nodeDOM(k);
            if (R)
              return R.getBoundingClientRect();
          }
          return lb(l, k, S);
        })
      }), this.show();
    }, this.editor = e, this.element = t, this.view = r, this.updateDelay = s, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.tippy || !t || (this.tippy = vo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    const { state: r } = e, i = r.selection.$from.pos !== r.selection.$to.pos;
    this.updateDelay > 0 && i ? eu.debounce(this.updateHandler, this.updateDelay)(e, t) : this.updateHandler(e, t);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const _b = (n) => new kt({
  key: typeof n.pluginKey == "string" ? new Gt(n.pluginKey) : n.pluginKey,
  view: (e) => new nP({ view: e, ...n })
});
$t.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      _b({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class rP {
  constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: o, state: l }) => {
      const { selection: u } = l, { $anchor: d, empty: f } = u, h = d.depth === 1, m = d.parent.isTextblock && !d.parent.type.spec.code && !d.parent.textContent;
      return !(!o.hasFocus() || !f || !h || !m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      o != null && o.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(o.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = t, this.view = r, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.tippy || !t || (this.tippy = vo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    var r, i, s;
    const { state: o } = e, { doc: l, selection: u } = o, { from: d, to: f } = u;
    if (t && t.doc.eq(l) && t.selection.eq(u))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: t
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => lb(e, d, f))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const wb = (n) => new kt({
  key: typeof n.pluginKey == "string" ? new Gt(n.pluginKey) : n.pluginKey,
  view: (e) => new rP({ view: e, ...n })
});
$t.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      wb({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
K({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: null,
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = G(null);
    return bt(() => {
      const {
        updateDelay: r,
        editor: i,
        pluginKey: s,
        shouldShow: o,
        tippyOptions: l
      } = n;
      i.registerPlugin(_b({
        updateDelay: r,
        editor: i,
        element: t.value,
        pluginKey: s,
        shouldShow: o,
        tippyOptions: l
      }));
    }), wa(() => {
      const { pluginKey: r, editor: i } = n;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Gn("div", { ref: t }, (r = e.default) == null ? void 0 : r.call(e));
    };
  }
});
function kv(n) {
  return DS((e, t) => ({
    get() {
      return e(), n;
    },
    set(r) {
      n = r, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          t();
        });
      });
    }
  }));
}
var iP = class extends SL {
  constructor(n = {}) {
    return super(n), this.vueRenderers = e0(/* @__PURE__ */ new Map()), this.contentComponent = null, this.reactiveState = kv(this.view.state), this.reactiveExtensionStorage = kv(this.extensionStorage), this.on("transaction", () => {
      this.reactiveState.value = this.view.state, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), wS(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  registerPlugin(n, e) {
    super.registerPlugin(n, e), this.reactiveState.value = this.view.state;
  }
  unregisterPlugin(n) {
    super.unregisterPlugin(n), this.reactiveState.value = this.view.state;
  }
}, sP = K({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(n) {
    const e = G(), t = _S();
    return Xv(() => {
      const r = n.editor;
      r && r.options.element && e.value && Ks(() => {
        if (!e.value || !r.options.element.firstChild)
          return;
        const i = X(e.value);
        e.value.append(...r.options.element.childNodes), r.contentComponent = t.ctx._, r.setOptions({
          element: i
        }), r.createNodeViews();
      });
    }), wa(() => {
      const r = n.editor;
      if (!r || (r.isDestroyed || r.view.setProps({
        nodeViews: {}
      }), r.contentComponent = null, !r.options.element.firstChild))
        return;
      const i = document.createElement("div");
      i.append(...r.options.element.childNodes), r.setOptions({
        element: i
      });
    }), { rootEl: e };
  },
  render() {
    const n = [];
    return this.editor && this.editor.vueRenderers.forEach((e) => {
      const t = Gn(
        Zv,
        {
          to: e.teleportElement,
          key: e.id
        },
        Gn(
          e.component,
          {
            ref: e.id,
            ...e.props
          }
        )
      );
      n.push(t);
    }), Gn(
      "div",
      {
        ref: (e) => {
          this.rootEl = e;
        }
      },
      ...n
    );
  }
});
K({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = G(null);
    return bt(() => {
      const {
        pluginKey: r,
        editor: i,
        tippyOptions: s,
        shouldShow: o
      } = n;
      i.registerPlugin(wb({
        pluginKey: r,
        editor: i,
        element: t.value,
        tippyOptions: s,
        shouldShow: o
      }));
    }), wa(() => {
      const { pluginKey: r, editor: i } = n;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Gn("div", { ref: t }, (r = e.default) == null ? void 0 : r.call(e));
    };
  }
});
K({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return Gn(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
K({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var n, e;
    return Gn(
      this.as,
      {
        class: this.decorationClasses,
        style: {
          whiteSpace: "normal"
        },
        "data-node-view-wrapper": "",
        onDragstart: this.onDragStart
      },
      (e = (n = this.$slots).default) == null ? void 0 : e.call(n)
    );
  }
});
var oP = (n = {}) => {
  const e = Od();
  return bt(() => {
    e.value = new iP(n);
  }), wa(() => {
    var t;
    (t = e.value) == null || t.destroy();
  }), e;
};
const aP = /^\s*>\s$/, lP = mt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["blockquote", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: n }) => n.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Zf({
        find: aP,
        type: this.type
      })
    ];
  }
}), uP = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/, cP = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g, dP = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/, fP = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g, pP = Xn.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (n) => n.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["strong", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: n }) => n.setMark(this.name),
      toggleBold: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetBold: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      fs({
        find: uP,
        type: this.type
      }),
      fs({
        find: dP,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ei({
        find: cP,
        type: this.type
      }),
      Ei({
        find: fP,
        type: this.type
      })
    ];
  }
}), hP = /^\s*([-+*])\s$/, mP = mt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: n }) => n.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    return [
      Zf({
        find: hP,
        type: this.type
      })
    ];
  }
}), gP = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/, vP = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g, yP = Xn.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["code", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: n }) => n.setMark(this.name),
      toggleCode: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetCode: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      fs({
        find: gP,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ei({
        find: vP,
        type: this.type
      })
    ];
  }
}), bP = /^```([a-z]+)?[\s\n]$/, _P = /^~~~([a-z]+)?[\s\n]$/, wP = mt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (n) => {
          var e;
          const { languageClassPrefix: t } = this.options, s = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(t)).map((o) => o.replace(t, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [
      "pre",
      nt(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (n) => ({ commands: e }) => e.setNode(this.name, n),
      toggleCodeBlock: (n) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      Backspace: () => {
        const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
        return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t;
        if (!i || r.parent.type !== this.type)
          return !1;
        const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
        return !s || !o ? !1 : n.chain().command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      ArrowDown: ({ editor: n }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: s } = t;
        if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const l = i.after();
        return l === void 0 || r.nodeAt(l) ? !1 : n.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      rf({
        find: bP,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      }),
      rf({
        find: _P,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      new kt({
        key: new Gt("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (n, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i == null ? void 0 : i.mode;
            if (!t || !s)
              return !1;
            const { tr: o } = n.state;
            return o.replaceSelectionWith(this.type.create({ language: s })), o.setSelection(we.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.insertText(t.replace(/\r\n?/g, `
`)), o.setMeta("paste", !0), n.dispatch(o), !0;
          }
        }
      })
    ];
  }
}), DP = mt.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function CP(n = {}) {
  return new kt({
    view(e) {
      return new xP(e, n);
    }
  });
}
class xP {
  constructor(e, t) {
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = t.width || 1, this.color = t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let i = (s) => {
        this[r](s);
      };
      return e.dom.addEventListener(r, i), { name: r, handler: i };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r;
    if (t) {
      let l = e.nodeBefore, u = e.nodeAfter;
      if (l || u) {
        let d = this.editorView.nodeDOM(this.cursorPos - (l ? l.nodeSize : 0));
        if (d) {
          let f = d.getBoundingClientRect(), h = l ? f.bottom : f.top;
          l && u && (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: f.left, right: f.right, top: h - this.width / 2, bottom: h + this.width / 2 };
        }
      }
    }
    if (!r) {
      let l = this.editorView.coordsAtPos(this.cursorPos);
      r = { left: l.left - this.width / 2, right: l.left + this.width / 2, top: l.top, bottom: l.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let s, o;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      s = -pageXOffset, o = -pageYOffset;
    else {
      let l = i.getBoundingClientRect();
      s = l.left - i.scrollLeft, o = l.top - i.scrollTop;
    }
    this.element.style.left = r.left - s + "px", this.element.style.top = r.top - o + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !s) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice && (o = uy(this.editorView.state.doc, o, this.editorView.dragging.slice), o == null))
        return this.setCursor(null);
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const kP = $t.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      CP(this.options)
    ];
  }
});
class dt extends _e {
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return dt.valid(r) ? new dt(r) : _e.near(r);
  }
  content() {
    return Z.empty;
  }
  eq(e) {
    return e instanceof dt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new dt(e.resolve(t.pos));
  }
  getBookmark() {
    return new ep(this.anchor);
  }
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !SP(e) || !AP(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  static findGapCursorFrom(e, t, r = !1) {
    e:
      for (; ; ) {
        if (!r && dt.valid(e))
          return e;
        let i = e.pos, s = null;
        for (let o = e.depth; ; o--) {
          let l = e.node(o);
          if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) {
            s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
            break;
          } else if (o == 0)
            return null;
          i += t;
          let u = e.doc.resolve(i);
          if (dt.valid(u))
            return u;
        }
        for (; ; ) {
          let o = t > 0 ? s.firstChild : s.lastChild;
          if (!o) {
            if (s.isAtom && !s.isText && !ve.isSelectable(s)) {
              e = e.doc.resolve(i + s.nodeSize * t), r = !1;
              continue e;
            }
            break;
          }
          s = o, i += t;
          let l = e.doc.resolve(i);
          if (dt.valid(l))
            return l;
        }
        return null;
      }
  }
}
dt.prototype.visible = !1;
dt.findFrom = dt.findGapCursorFrom;
_e.jsonID("gapcursor", dt);
class ep {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new ep(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return dt.valid(t) ? new dt(t) : _e.near(t);
  }
}
function SP(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function AP(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function EP() {
  return new kt({
    props: {
      decorations: FP,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && dt.valid(t) ? new dt(t) : null;
      },
      handleClick: MP,
      handleKeyDown: TP,
      handleDOMEvents: { beforeinput: OP }
    }
  });
}
const TP = Uf({
  ArrowLeft: kl("horiz", -1),
  ArrowRight: kl("horiz", 1),
  ArrowUp: kl("vert", -1),
  ArrowDown: kl("vert", 1)
});
function kl(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, l = e > 0 ? o.$to : o.$from, u = o.empty;
    if (o instanceof we) {
      if (!s.endOfTextblock(t) || l.depth == 0)
        return !1;
      u = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let d = dt.findGapCursorFrom(l, e, u);
    return d ? (i && i(r.tr.setSelection(new dt(d))), !0) : !1;
  };
}
function MP(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!dt.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && ve.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new dt(r))), !0);
}
function OP(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof dt))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = U.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = U.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new Z(i, 0, 0));
  return s.setSelection(we.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function FP(n) {
  if (!(n.selection instanceof dt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", ct.create(n.doc, [hn.widget(n.selection.head, e, { key: "gapcursor" })]);
}
const IP = $t.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      EP()
    ];
  },
  extendNodeSchema(n) {
    var e;
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      allowGapCursor: (e = Ae(se(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
    };
  }
}), RP = mt.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["br", nt(this.options.HTMLAttributes, n)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: n, chain: e, state: t, editor: r }) => n.first([
        () => n.exitCode(),
        () => n.command(() => {
          const { selection: i, storedMarks: s } = t;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: l } = r.extensionManager, u = s || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: d, dispatch: f }) => {
            if (f && u && o) {
              const h = u.filter((m) => l.includes(m.type.name));
              d.ensureMarks(h);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), NP = mt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((n) => ({
      tag: `h${n}`,
      attrs: { level: n }
    }));
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, nt(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1,
      toggleHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((n, e) => ({
      ...n,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((n) => rf({
      find: new RegExp(`^(#{1,${n}})\\s$`),
      type: this.type,
      getAttributes: {
        level: n
      }
    }));
  }
});
var nu = 200, Bt = function() {
};
Bt.prototype.append = function(e) {
  return e.length ? (e = Bt.from(e), !this.length && e || e.length < nu && this.leafAppend(e) || this.length < nu && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Bt.prototype.prepend = function(e) {
  return e.length ? Bt.from(e).append(this) : this;
};
Bt.prototype.appendInner = function(e) {
  return new BP(this, e);
};
Bt.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Bt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Bt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Bt.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Bt.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
Bt.from = function(e) {
  return e instanceof Bt ? e : e && e.length ? new Db(e) : Bt.empty;
};
var Db = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, l) {
    for (var u = s; u < o; u++)
      if (i(this.values[u], l + u) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, l) {
    for (var u = s - 1; u >= o; u--)
      if (i(this.values[u], l + u) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= nu)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= nu)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(Bt);
Bt.empty = new Db([]);
var BP = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(Bt), Cb = Bt;
const $P = 500;
class ur {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, l, u, d = [], f = [];
    return this.items.forEach((h, m) => {
      if (!h.step) {
        i || (i = this.remapping(r, m + 1), s = i.maps.length), s--, f.push(h);
        return;
      }
      if (i) {
        f.push(new Cr(h.map));
        let g = h.step.map(i.slice(s)), y;
        g && o.maybeStep(g).doc && (y = o.mapping.maps[o.mapping.maps.length - 1], d.push(new Cr(y, void 0, void 0, d.length + f.length))), s--, y && i.appendMap(y, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return l = i ? h.selection.map(i.slice(s)) : h.selection, u = new ur(this.items.slice(0, r).append(f.reverse().concat(d)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: u, transform: o, selection: l };
  }
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, l = this.items, u = !i && l.length ? l.get(l.length - 1) : null;
    for (let f = 0; f < e.steps.length; f++) {
      let h = e.steps[f].invert(e.docs[f]), m = new Cr(e.mapping.maps[f], h, t), g;
      (g = u && u.merge(m)) && (m = g, f ? s.pop() : l = l.slice(0, l.length - 1)), s.push(m), t && (o++, t = void 0), i || (u = m);
    }
    let d = o - r.depth;
    return d > PP && (l = LP(l, d), o -= d), new ur(l.append(s), o);
  }
  remapping(e, t) {
    let r = new Ys();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new ur(this.items.append(e.map((t) => new Cr(t))), this.eventCount);
  }
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount;
    this.items.forEach((m) => {
      m.selection && l--;
    }, i);
    let u = t;
    this.items.forEach((m) => {
      let g = s.getMirror(--u);
      if (g == null)
        return;
      o = Math.min(o, g);
      let y = s.maps[g];
      if (m.step) {
        let b = e.steps[g].invert(e.docs[g]), w = m.selection && m.selection.map(s.slice(u + 1, g));
        w && l++, r.push(new Cr(y, b, w));
      } else
        r.push(new Cr(y));
    }, i);
    let d = [];
    for (let m = t; m < o; m++)
      d.push(new Cr(s.maps[m]));
    let f = this.items.slice(0, i).append(d).append(r), h = new ur(f, l);
    return h.emptyItemCount() > $P && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, l) => {
      if (l >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let u = o.step.map(t.slice(r)), d = u && u.getMap();
        if (r--, d && t.appendMap(d, r), u) {
          let f = o.selection && o.selection.map(t.slice(r));
          f && s++;
          let h = new Cr(d.invert(), u, f), m, g = i.length - 1;
          (m = i.length && i[g].merge(h)) ? i[g] = m : i.push(h);
        }
      } else
        o.map && r--;
    }, this.items.length, 0), new ur(Cb.from(i.reverse()), s);
  }
}
ur.empty = new ur(Cb.empty, 0);
function LP(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class Cr {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Cr(t.getMap().invert(), t, this.selection);
    }
  }
}
class hi {
  constructor(e, t, r, i) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i;
  }
}
const PP = 20;
function zP(n, e, t, r) {
  let i = t.getMeta(xi), s;
  if (i)
    return i.historyState;
  t.getMeta(HP) && (n = new hi(n.done, n.undone, null, 0));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(xi))
    return o.getMeta(xi).redo ? new hi(n.done.addTransform(t, void 0, r, Il(e)), n.undone, Sv(t.mapping.maps[t.steps.length - 1]), n.prevTime) : new hi(n.done, n.undone.addTransform(t, void 0, r, Il(e)), null, n.prevTime);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let l = n.prevTime == 0 || !o && (n.prevTime < (t.time || 0) - r.newGroupDelay || !VP(t, n.prevRanges)), u = o ? Sd(n.prevRanges, t.mapping) : Sv(t.mapping.maps[t.steps.length - 1]);
    return new hi(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, r, Il(e)), ur.empty, u, t.time);
  } else
    return (s = t.getMeta("rebased")) ? new hi(n.done.rebased(t, s), n.undone.rebased(t, s), Sd(n.prevRanges, t.mapping), n.prevTime) : new hi(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Sd(n.prevRanges, t.mapping), n.prevTime);
}
function VP(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function Sv(n) {
  let e = [];
  return n.forEach((t, r, i, s) => e.push(i, s)), e;
}
function Sd(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function xb(n, e, t, r) {
  let i = Il(e), s = xi.get(e).spec.config, o = (r ? n.undone : n.done).popEvent(e, i);
  if (!o)
    return;
  let l = o.selection.resolve(o.transform.doc), u = (r ? n.done : n.undone).addTransform(o.transform, e.selection.getBookmark(), s, i), d = new hi(r ? u : o.remaining, r ? o.remaining : u, null, 0);
  t(o.transform.setSelection(l).setMeta(xi, { redo: r, historyState: d }).scrollIntoView());
}
let Ad = !1, Av = null;
function Il(n) {
  let e = n.plugins;
  if (Av != e) {
    Ad = !1, Av = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Ad = !0;
        break;
      }
  }
  return Ad;
}
const xi = new Gt("history"), HP = new Gt("closeHistory");
function WP(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new kt({
    key: xi,
    state: {
      init() {
        return new hi(ur.empty, ur.empty, null, 0);
      },
      apply(e, t, r) {
        return zP(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? kb : r == "historyRedo" ? Sb : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const kb = (n, e) => {
  let t = xi.getState(n);
  return !t || t.done.eventCount == 0 ? !1 : (e && xb(t, n, e, !1), !0);
}, Sb = (n, e) => {
  let t = xi.getState(n);
  return !t || t.undone.eventCount == 0 ? !1 : (e && xb(t, n, e, !0), !0);
}, UP = $t.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: n, dispatch: e }) => kb(n, e),
      redo: () => ({ state: n, dispatch: e }) => Sb(n, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      WP(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), jP = mt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["hr", nt(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: n }) => n().insertContent({ type: this.name }).command(({ tr: e, dispatch: t }) => {
        var r;
        if (t) {
          const { $to: i } = e.selection, s = i.end();
          if (i.nodeAfter)
            e.setSelection(we.create(e.doc, i.pos));
          else {
            const o = (r = i.parent.type.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.create();
            o && (e.insert(s, o), e.setSelection(we.create(e.doc, s)));
          }
          e.scrollIntoView();
        }
        return !0;
      }).run()
    };
  },
  addInputRules() {
    return [
      Xf({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), qP = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/, KP = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g, GP = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/, JP = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g, YP = Xn.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (n) => n.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["em", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: n }) => n.setMark(this.name),
      toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      fs({
        find: qP,
        type: this.type
      }),
      fs({
        find: GP,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ei({
        find: KP,
        type: this.type
      }),
      Ei({
        find: JP,
        type: this.type
      })
    ];
  }
}), XP = mt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", nt(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), ZP = /^(\d+)\.\s$/, QP = mt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (n) => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { start: e, ...t } = n;
    return e === 1 ? ["ol", nt(this.options.HTMLAttributes, t), 0] : ["ol", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: n }) => n.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    return [
      Zf({
        find: ZP,
        type: this.type,
        getAttributes: (n) => ({ start: +n[1] }),
        joinPredicate: (n, e) => e.childCount + e.attrs.start === +n[1]
      })
    ];
  }
}), e3 = mt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["p", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: n }) => n.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), t3 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/, n3 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g, r3 = Xn.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["s", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: n }) => n.setMark(this.name),
      toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      fs({
        find: t3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ei({
        find: n3,
        type: this.type
      })
    ];
  }
}), i3 = mt.create({
  name: "text",
  group: "inline"
});
var s3 = $t.create({
  name: "starterKit",
  addExtensions() {
    var n, e, t, r, i, s, o, l, u, d, f, h, m, g, y, b, w, T;
    const k = [];
    return this.options.blockquote !== !1 && k.push(lP.configure((n = this.options) == null ? void 0 : n.blockquote)), this.options.bold !== !1 && k.push(pP.configure((e = this.options) == null ? void 0 : e.bold)), this.options.bulletList !== !1 && k.push(mP.configure((t = this.options) == null ? void 0 : t.bulletList)), this.options.code !== !1 && k.push(yP.configure((r = this.options) == null ? void 0 : r.code)), this.options.codeBlock !== !1 && k.push(wP.configure((i = this.options) == null ? void 0 : i.codeBlock)), this.options.document !== !1 && k.push(DP.configure((s = this.options) == null ? void 0 : s.document)), this.options.dropcursor !== !1 && k.push(kP.configure((o = this.options) == null ? void 0 : o.dropcursor)), this.options.gapcursor !== !1 && k.push(IP.configure((l = this.options) == null ? void 0 : l.gapcursor)), this.options.hardBreak !== !1 && k.push(RP.configure((u = this.options) == null ? void 0 : u.hardBreak)), this.options.heading !== !1 && k.push(NP.configure((d = this.options) == null ? void 0 : d.heading)), this.options.history !== !1 && k.push(UP.configure((f = this.options) == null ? void 0 : f.history)), this.options.horizontalRule !== !1 && k.push(jP.configure((h = this.options) == null ? void 0 : h.horizontalRule)), this.options.italic !== !1 && k.push(YP.configure((m = this.options) == null ? void 0 : m.italic)), this.options.listItem !== !1 && k.push(XP.configure((g = this.options) == null ? void 0 : g.listItem)), this.options.orderedList !== !1 && k.push(QP.configure((y = this.options) == null ? void 0 : y.orderedList)), this.options.paragraph !== !1 && k.push(e3.configure((b = this.options) == null ? void 0 : b.paragraph)), this.options.strike !== !1 && k.push(r3.configure((w = this.options) == null ? void 0 : w.strike)), this.options.text !== !1 && k.push(i3.configure((T = this.options) == null ? void 0 : T.text)), k;
  }
}), o3 = s3, a3 = Xn.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["u", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: n }) => n.setMark(this.name),
      toggleUnderline: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetUnderline: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), l3 = a3, u3 = mt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["hr", nt(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: n }) => n().insertContent({ type: this.name }).command(({ tr: e, dispatch: t }) => {
        var r;
        if (t) {
          const { $to: i } = e.selection, s = i.end();
          if (i.nodeAfter)
            e.setSelection(we.create(e.doc, i.pos));
          else {
            const o = (r = i.parent.type.contentMatch.defaultType) == null ? void 0 : r.create();
            o && (e.insert(s, o), e.setSelection(we.create(e.doc, s)));
          }
          e.scrollIntoView();
        }
        return !0;
      }).run()
    };
  },
  addInputRules() {
    return [
      Xf({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), c3 = u3;
const d3 = $t.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (n) => n.style.textAlign || this.options.defaultAlignment,
            renderHTML: (n) => n.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${n.textAlign}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (n) => ({ commands: e }) => this.options.alignments.includes(n) ? this.options.types.every((t) => e.updateAttributes(t, { textAlign: n })) : !1,
      unsetTextAlign: () => ({ commands: n }) => this.options.types.every((e) => n.resetAttributes(e, "textAlign"))
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var f3 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/, p3 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g, h3 = Xn.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (n) => n.getAttribute("data-color") || n.style.backgroundColor,
        renderHTML: (n) => n.color ? {
          "data-color": n.color,
          style: `background-color: ${n.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["mark", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setHighlight: (n) => ({ commands: e }) => e.setMark(this.name, n),
      toggleHighlight: (n) => ({ commands: e }) => e.toggleMark(this.name, n),
      unsetHighlight: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      fs({
        find: f3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ei({
        find: p3,
        type: this.type
      })
    ];
  }
}), m3 = h3, g3 = Xn.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => n.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: n, commands: e }) => {
        const t = Yf(n, this.type);
        return Object.entries(t).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), v3 = g3, y3 = $t.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (n) => {
              var e;
              return (e = n.style.color) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (n) => n.color ? {
              style: `color: ${n.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (n) => ({ chain: e }) => e().setMark("textStyle", { color: n }).run(),
      unsetColor: () => ({ chain: n }) => n().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), b3 = y3, lf, uf;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  lf = (e) => n.get(e), uf = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  lf = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r)
        return n[i + 1];
  }, uf = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var ft = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n)
        continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let l = 1; s < this.width && this.map[e + l] == t; l++)
        s++;
      for (let l = 1; o < this.height && this.map[e + this.width * l] == t; l++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: l,
      top: u,
      bottom: d
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, u),
      right: Math.max(r, l),
      bottom: Math.max(s, d)
    };
  }
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const l = (n + 1) * this.width;
        for (; o < l && this.map[o] < i; )
          o++;
        return o == l ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  static get(n) {
    return lf(n) || uf(n, _3(n));
  }
};
function _3(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = w3(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let d = 0, f = e * t; d < f; d++)
    r[d] = 0;
  for (let d = 0, f = 0; d < t; d++) {
    const h = n.child(d);
    f++;
    for (let y = 0; ; y++) {
      for (; i < r.length && r[i] != 0; )
        i++;
      if (y == h.childCount)
        break;
      const b = h.child(y), { colspan: w, rowspan: T, colwidth: k } = b.attrs;
      for (let S = 0; S < T; S++) {
        if (S + d >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: f,
            n: T - S
          });
          break;
        }
        const C = i + S * e;
        for (let R = 0; R < w; R++) {
          r[C + R] == 0 ? r[C + R] = f : (s || (s = [])).push({
            type: "collision",
            row: d,
            pos: f,
            n: w - R
          });
          const I = k && k[R];
          if (I) {
            const P = (C + R) % e * 2, L = o[P];
            L == null || L != I && o[P + 1] == 1 ? (o[P] = I, o[P + 1] = 1) : L == I && o[P + 1]++;
          }
        }
      }
      i += w, f += b.nodeSize;
    }
    const m = (d + 1) * e;
    let g = 0;
    for (; i < m; )
      r[i++] == 0 && g++;
    g && (s || (s = [])).push({ type: "missing", row: d, n: g }), f++;
  }
  const l = new ft(e, t, r, s);
  let u = !1;
  for (let d = 0; !u && d < o.length; d += 2)
    o[d] != null && o[d + 1] < t && (u = !0);
  return u && D3(l, o, n), l;
}
function w3(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const l = n.child(o);
        for (let u = 0; u < l.childCount; u++) {
          const d = l.child(u);
          o + d.attrs.rowspan > r && (s += d.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const l = i.child(o);
      s += l.attrs.colspan, l.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function D3(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s])
      continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let l = null;
    const u = o.attrs;
    for (let d = 0; d < u.colspan; d++) {
      const f = (i + d) % n.width, h = e[f * 2];
      h != null && (!u.colwidth || u.colwidth[d] != h) && ((l || (l = C3(u)))[d] = h);
    }
    l && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: l
    });
  }
}
function C3(n) {
  if (n.colwidth)
    return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++)
    e.push(0);
  return e;
}
function qt(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var vi = new Gt("selectingCells");
function yo(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function x3(n) {
  for (let e = n.depth; e > 0; e--) {
    const t = n.node(e).type.spec.tableRole;
    if (t === "cell" || t === "header_cell")
      return n.node(e);
  }
  return null;
}
function gr(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function Pu(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = yo(e.$head) || k3(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function k3(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function cf(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function S3(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function tp(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function Ab(n, e, t) {
  const r = n.node(-1), i = ft.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function ps(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function Eb(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++)
      r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function A3(n, e, t) {
  const r = qt(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var Le = class extends _e {
  constructor(n, e = n) {
    const t = n.node(-1), r = ft.get(t), i = n.start(-1), s = r.rectBetween(
      n.pos - i,
      e.pos - i
    ), o = n.node(0), l = r.cellsInRect(s).filter((d) => d != e.pos - i);
    l.unshift(e.pos - i);
    const u = l.map((d) => {
      const f = t.nodeAt(d);
      if (!f)
        throw RangeError(`No cell with offset ${d} found`);
      const h = i + d + 1;
      return new hy(
        o.resolve(h),
        o.resolve(h + f.content.size)
      );
    });
    super(u[0].$from, u[0].$to, u), this.$anchorCell = n, this.$headCell = e;
  }
  map(n, e) {
    const t = n.resolve(e.map(this.$anchorCell.pos)), r = n.resolve(e.map(this.$headCell.pos));
    if (cf(t) && cf(r) && tp(t, r)) {
      const i = this.$anchorCell.node(-1) != t.node(-1);
      return i && this.isRowSelection() ? Le.rowSelection(t, r) : i && this.isColSelection() ? Le.colSelection(t, r) : new Le(t, r);
    }
    return we.between(t, r);
  }
  content() {
    const n = this.$anchorCell.node(-1), e = ft.get(n), t = this.$anchorCell.start(-1), r = e.rectBetween(
      this.$anchorCell.pos - t,
      this.$headCell.pos - t
    ), i = {}, s = [];
    for (let l = r.top; l < r.bottom; l++) {
      const u = [];
      for (let d = l * e.width + r.left, f = r.left; f < r.right; f++, d++) {
        const h = e.map[d];
        if (i[h])
          continue;
        i[h] = !0;
        const m = e.findCell(h);
        let g = n.nodeAt(h);
        if (!g)
          throw RangeError(`No cell with offset ${h} found`);
        const y = r.left - m.left, b = m.right - r.right;
        if (y > 0 || b > 0) {
          let w = g.attrs;
          if (y > 0 && (w = ps(w, 0, y)), b > 0 && (w = ps(
            w,
            w.colspan - b,
            b
          )), m.left < r.left) {
            if (g = g.type.createAndFill(w), !g)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(w)}`
              );
          } else
            g = g.type.create(w, g.content);
        }
        if (m.top < r.top || m.bottom > r.bottom) {
          const w = {
            ...g.attrs,
            rowspan: Math.min(m.bottom, r.bottom) - Math.max(m.top, r.top)
          };
          m.top < r.top ? g = g.type.createAndFill(w) : g = g.type.create(w, g.content);
        }
        u.push(g);
      }
      s.push(n.child(l).copy(U.from(u)));
    }
    const o = this.isColSelection() && this.isRowSelection() ? n : s;
    return new Z(U.from(o), 1, 1);
  }
  replace(n, e = Z.empty) {
    const t = n.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      const { $from: o, $to: l } = r[s], u = n.mapping.slice(t);
      n.replace(
        u.map(o.pos),
        u.map(l.pos),
        s ? Z.empty : e
      );
    }
    const i = _e.findFrom(
      n.doc.resolve(n.mapping.slice(t).map(this.to)),
      -1
    );
    i && n.setSelection(i);
  }
  replaceWith(n, e) {
    this.replace(n, new Z(U.from(e), 0, 0));
  }
  forEachCell(n) {
    const e = this.$anchorCell.node(-1), t = ft.get(e), r = this.$anchorCell.start(-1), i = t.cellsInRect(
      t.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let s = 0; s < i.length; s++)
      n(e.nodeAt(i[s]), r + i[s]);
  }
  isColSelection() {
    const n = this.$anchorCell.index(-1), e = this.$headCell.index(-1);
    if (Math.min(n, e) > 0)
      return !1;
    const t = n + this.$anchorCell.nodeAfter.attrs.rowspan, r = e + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(t, r) == this.$headCell.node(-1).childCount;
  }
  static colSelection(n, e = n) {
    const t = n.node(-1), r = ft.get(t), i = n.start(-1), s = r.findCell(n.pos - i), o = r.findCell(e.pos - i), l = n.node(0);
    return s.top <= o.top ? (s.top > 0 && (n = l.resolve(i + r.map[s.left])), o.bottom < r.height && (e = l.resolve(
      i + r.map[r.width * (r.height - 1) + o.right - 1]
    ))) : (o.top > 0 && (e = l.resolve(i + r.map[o.left])), s.bottom < r.height && (n = l.resolve(
      i + r.map[r.width * (r.height - 1) + s.right - 1]
    ))), new Le(n, e);
  }
  isRowSelection() {
    const n = this.$anchorCell.node(-1), e = ft.get(n), t = this.$anchorCell.start(-1), r = e.colCount(this.$anchorCell.pos - t), i = e.colCount(this.$headCell.pos - t);
    if (Math.min(r, i) > 0)
      return !1;
    const s = r + this.$anchorCell.nodeAfter.attrs.colspan, o = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, o) == e.width;
  }
  eq(n) {
    return n instanceof Le && n.$anchorCell.pos == this.$anchorCell.pos && n.$headCell.pos == this.$headCell.pos;
  }
  static rowSelection(n, e = n) {
    const t = n.node(-1), r = ft.get(t), i = n.start(-1), s = r.findCell(n.pos - i), o = r.findCell(e.pos - i), l = n.node(0);
    return s.left <= o.left ? (s.left > 0 && (n = l.resolve(
      i + r.map[s.top * r.width]
    )), o.right < r.width && (e = l.resolve(
      i + r.map[r.width * (o.top + 1) - 1]
    ))) : (o.left > 0 && (e = l.resolve(i + r.map[o.top * r.width])), s.right < r.width && (n = l.resolve(
      i + r.map[r.width * (s.top + 1) - 1]
    ))), new Le(n, e);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(n, e) {
    return new Le(n.resolve(e.anchor), n.resolve(e.head));
  }
  static create(n, e, t = e) {
    return new Le(n.resolve(e), n.resolve(t));
  }
  getBookmark() {
    return new Tb(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Le.prototype.visible = !1;
_e.jsonID("cell", Le);
var Tb = class {
  constructor(n, e) {
    this.anchor = n, this.head = e;
  }
  map(n) {
    return new Tb(n.map(this.anchor), n.map(this.head));
  }
  resolve(n) {
    const e = n.resolve(this.anchor), t = n.resolve(this.head);
    return e.parent.type.spec.tableRole == "row" && t.parent.type.spec.tableRole == "row" && e.index() < e.parent.childCount && t.index() < t.parent.childCount && tp(e, t) ? new Le(e, t) : _e.near(t, 1);
  }
};
function E3(n) {
  if (!(n.selection instanceof Le))
    return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      hn.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), ct.create(n.doc, e);
}
function T3({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < n.pos - 6)
    return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function M3({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function O3(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof ve && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = Le.create(i, r.from);
    else if (o == "row") {
      const l = i.resolve(r.from + 1);
      s = Le.rowSelection(l, l);
    } else if (!t) {
      const l = ft.get(r.node), u = r.from + 1, d = u + l.map[l.width * l.height - 1];
      s = Le.create(i, u + 1, d);
    }
  } else
    r instanceof we && T3(r) ? s = we.create(i, r.from) : r instanceof we && M3(r) && (s = we.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var F3 = new Gt("fix-tables");
function Mb(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e:
    for (let o = 0, l = 0; o < s; o++) {
      const u = e.child(o);
      for (let d = l, f = Math.min(i, o + 3); d < f; d++)
        if (n.child(d) == u) {
          l = d + 1, t += u.nodeSize;
          continue e;
        }
      r(u, t), l < i && n.child(l).sameMarkup(u) ? Mb(n.child(l), u, t + 1, r) : u.nodesBetween(0, u.content.size, r, t + 1), t += u.nodeSize;
    }
}
function Ob(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = I3(n, i, s, t));
  };
  return e ? e.doc != n.doc && Mb(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function I3(n, e, t, r) {
  const i = ft.get(e);
  if (!i.problems)
    return r;
  r || (r = n.tr);
  const s = [];
  for (let u = 0; u < i.height; u++)
    s.push(0);
  for (let u = 0; u < i.problems.length; u++) {
    const d = i.problems[u];
    if (d.type == "collision") {
      const f = e.nodeAt(d.pos);
      if (!f)
        continue;
      const h = f.attrs;
      for (let m = 0; m < h.rowspan; m++)
        s[d.row + m] += d.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + d.pos),
        null,
        ps(h, h.colspan - d.n, d.n)
      );
    } else if (d.type == "missing")
      s[d.row] += d.n;
    else if (d.type == "overlong_rowspan") {
      const f = e.nodeAt(d.pos);
      if (!f)
        continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + d.pos), null, {
        ...f.attrs,
        rowspan: f.attrs.rowspan - d.n
      });
    } else if (d.type == "colwidth mismatch") {
      const f = e.nodeAt(d.pos);
      if (!f)
        continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + d.pos), null, {
        ...f.attrs,
        colwidth: d.colwidth
      });
    }
  }
  let o, l;
  for (let u = 0; u < s.length; u++)
    s[u] && (o == null && (o = u), l = u);
  for (let u = 0, d = t + 1; u < i.height; u++) {
    const f = e.child(u), h = d + f.nodeSize, m = s[u];
    if (m > 0) {
      let g = "cell";
      f.firstChild && (g = f.firstChild.type.spec.tableRole);
      const y = [];
      for (let w = 0; w < m; w++) {
        const T = qt(n.schema)[g].createAndFill();
        T && y.push(T);
      }
      const b = (u == 0 || o == u - 1) && l == u ? d + 1 : h - 1;
      r.insert(r.mapping.map(b), y);
    }
    d = h;
  }
  return r.setMeta(F3, { fixTables: !0 });
}
function R3(n) {
  if (!n.size)
    return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, l = [];
  if (s == "row")
    for (let u = 0; u < e.childCount; u++) {
      let d = e.child(u).content;
      const f = u ? 0 : Math.max(0, t - 1), h = u < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (f || h) && (d = df(
        qt(o).row,
        new Z(d, f, h)
      ).content), l.push(d);
    }
  else if (s == "cell" || s == "header_cell")
    l.push(
      t || r ? df(
        qt(o).row,
        new Z(e, t, r)
      ).content : e
    );
  else
    return null;
  return N3(o, l);
}
function N3(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: l, colspan: u } = s.child(o).attrs;
      for (let d = i; d < i + l; d++)
        t[d] = (t[d] || 0) + u;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++)
    r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(U.empty), t[i] < r) {
      const s = qt(n).cell.createAndFill(), o = [];
      for (let l = t[i]; l < r; l++)
        o.push(s);
      e[i] = e[i].append(U.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function df(n, e) {
  const t = n.createAndFill();
  return new If(t).replace(0, t.content.size, e).doc;
}
function B3({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l], d = [];
      for (let f = s[l] || 0, h = 0; f < r; h++) {
        let m = u.child(h % u.childCount);
        f + m.attrs.colspan > r && (m = m.type.createChecked(
          ps(
            m.attrs,
            m.attrs.colspan,
            f + m.attrs.colspan - r
          ),
          m.content
        )), d.push(m), f += m.attrs.colspan;
        for (let g = 1; g < m.attrs.rowspan; g++)
          s[l + g] = (s[l + g] || 0) + m.attrs.colspan;
      }
      o.push(U.from(d));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, l = 0; o < i; o++, l++) {
      const u = [], d = t[l % e];
      for (let f = 0; f < d.childCount; f++) {
        let h = d.child(f);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), u.push(h);
      }
      s.push(U.from(u));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function $3(n, e, t, r, i, s, o) {
  const l = n.doc.type.schema, u = qt(l);
  let d, f;
  if (i > e.width)
    for (let h = 0, m = 0; h < e.height; h++) {
      const g = t.child(h);
      m += g.nodeSize;
      const y = [];
      let b;
      g.lastChild == null || g.lastChild.type == u.cell ? b = d || (d = u.cell.createAndFill()) : b = f || (f = u.header_cell.createAndFill());
      for (let w = e.width; w < i; w++)
        y.push(b);
      n.insert(n.mapping.slice(o).map(m - 1 + r), y);
    }
  if (s > e.height) {
    const h = [];
    for (let y = 0, b = (e.height - 1) * e.width; y < Math.max(e.width, i); y++) {
      const w = y >= e.width ? !1 : t.nodeAt(e.map[b + y]).type == u.header_cell;
      h.push(
        w ? f || (f = u.header_cell.createAndFill()) : d || (d = u.cell.createAndFill())
      );
    }
    const m = u.row.create(null, U.from(h)), g = [];
    for (let y = e.height; y < s; y++)
      g.push(m);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), g);
  }
  return !!(d || f);
}
function Ev(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.height)
    return !1;
  let u = !1;
  for (let d = i; d < s; d++) {
    const f = o * e.width + d, h = e.map[f];
    if (e.map[f - e.width] == h) {
      u = !0;
      const m = t.nodeAt(h), { top: g, left: y } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
        ...m.attrs,
        rowspan: o - g
      }), n.insert(
        n.mapping.slice(l).map(e.positionAt(o, y, t)),
        m.type.createAndFill({
          ...m.attrs,
          rowspan: g + m.attrs.rowspan - o
        })
      ), d += m.attrs.colspan - 1;
    }
  }
  return u;
}
function Tv(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.width)
    return !1;
  let u = !1;
  for (let d = i; d < s; d++) {
    const f = d * e.width + o, h = e.map[f];
    if (e.map[f - 1] == h) {
      u = !0;
      const m = t.nodeAt(h), g = e.colCount(h), y = n.mapping.slice(l).map(h + r);
      n.setNodeMarkup(
        y,
        null,
        ps(
          m.attrs,
          o - g,
          m.attrs.colspan - (o - g)
        )
      ), n.insert(
        y + m.nodeSize,
        m.type.createAndFill(
          ps(m.attrs, 0, o - g)
        )
      ), d += m.attrs.rowspan - 1;
    }
  }
  return u;
}
function Mv(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = ft.get(s);
  const { top: l, left: u } = r, d = u + i.width, f = l + i.height, h = n.tr;
  let m = 0;
  function g() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = ft.get(s), m = h.mapping.maps.length;
  }
  $3(h, o, s, t, d, f, m) && g(), Ev(h, o, s, t, u, d, l, m) && g(), Ev(h, o, s, t, u, d, f, m) && g(), Tv(h, o, s, t, l, f, u, m) && g(), Tv(h, o, s, t, l, f, d, m) && g();
  for (let y = l; y < f; y++) {
    const b = o.positionAt(y, u, s), w = o.positionAt(y, d, s);
    h.replace(
      h.mapping.slice(m).map(b + t),
      h.mapping.slice(m).map(w + t),
      new Z(i.rows[y - l], 0, 0)
    );
  }
  g(), h.setSelection(
    new Le(
      h.doc.resolve(t + o.positionAt(l, u, s)),
      h.doc.resolve(t + o.positionAt(f - 1, d - 1, s))
    )
  ), e(h);
}
var L3 = Uf({
  ArrowLeft: Sl("horiz", -1),
  ArrowRight: Sl("horiz", 1),
  ArrowUp: Sl("vert", -1),
  ArrowDown: Sl("vert", 1),
  "Shift-ArrowLeft": Al("horiz", -1),
  "Shift-ArrowRight": Al("horiz", 1),
  "Shift-ArrowUp": Al("vert", -1),
  "Shift-ArrowDown": Al("vert", 1),
  Backspace: El,
  "Mod-Backspace": El,
  Delete: El,
  "Mod-Delete": El
});
function Rl(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function Sl(n, e) {
  return (t, r, i) => {
    if (!i)
      return !1;
    const s = t.selection;
    if (s instanceof Le)
      return Rl(
        t,
        r,
        _e.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty)
      return !1;
    const o = Fb(i, n, e);
    if (o == null)
      return !1;
    if (n == "horiz")
      return Rl(
        t,
        r,
        _e.near(t.doc.resolve(s.head + e), e)
      );
    {
      const l = t.doc.resolve(o), u = Ab(l, n, e);
      let d;
      return u ? d = _e.near(u, 1) : e < 0 ? d = _e.near(t.doc.resolve(l.before(-1)), -1) : d = _e.near(t.doc.resolve(l.after(-1)), 1), Rl(t, r, d);
    }
  };
}
function Al(n, e) {
  return (t, r, i) => {
    if (!i)
      return !1;
    const s = t.selection;
    let o;
    if (s instanceof Le)
      o = s;
    else {
      const u = Fb(i, n, e);
      if (u == null)
        return !1;
      o = new Le(t.doc.resolve(u));
    }
    const l = Ab(o.$headCell, n, e);
    return l ? Rl(
      t,
      r,
      new Le(o.$anchorCell, l)
    ) : !1;
  };
}
function El(n, e) {
  const t = n.selection;
  if (!(t instanceof Le))
    return !1;
  if (e) {
    const r = n.tr, i = qt(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new Z(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function P3(n, e) {
  const t = n.state.doc, r = yo(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new Le(r))), !0) : !1;
}
function z3(n, e, t) {
  if (!gr(n.state))
    return !1;
  let r = R3(t);
  const i = n.state.selection;
  if (i instanceof Le) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        U.from(
          df(qt(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), l = ft.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = B3(r, l.right - l.left, l.bottom - l.top), Mv(n.state, n.dispatch, o, l, r), !0;
  } else if (r) {
    const s = Pu(n.state), o = s.start(-1);
    return Mv(
      n.state,
      n.dispatch,
      o,
      ft.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function V3(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey)
    return;
  const r = Ov(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof Le)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = yo(n.state.selection.$anchor)) != null && ((t = Ed(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(u, d) {
    let f = Ed(n, d);
    const h = vi.getState(n.state) == null;
    if (!f || !tp(u, f))
      if (h)
        f = u;
      else
        return;
    const m = new Le(u, f);
    if (h || !n.state.selection.eq(m)) {
      const g = n.state.tr.setSelection(m);
      h && g.setMeta(vi, u.pos), n.dispatch(g);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", l), vi.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(vi, -1));
  }
  function l(u) {
    const d = u, f = vi.getState(n.state);
    let h;
    if (f != null)
      h = n.state.doc.resolve(f);
    else if (Ov(n, d.target) != r && (h = Ed(n, e), !h))
      return o();
    h && s(h, d);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", l);
}
function Fb(n, e, t) {
  if (!(n.state.selection instanceof we))
    return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount))
      return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const l = r.before(i), u = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(u) ? l : null;
    }
  }
  return null;
}
function Ov(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Ed(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? yo(n.state.doc.resolve(t.pos)) : null;
}
var H3 = class {
  constructor(e, t) {
    this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), ff(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, ff(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function ff(n, e, t, r, i, s) {
  var o;
  let l = 0, u = !0, d = e.firstChild;
  const f = n.firstChild;
  if (f) {
    for (let h = 0, m = 0; h < f.childCount; h++) {
      const { colspan: g, colwidth: y } = f.child(h).attrs;
      for (let b = 0; b < g; b++, m++) {
        const w = i == m ? s : y && y[b], T = w ? w + "px" : "";
        l += w || r, w || (u = !1), d ? (d.style.width != T && (d.style.width = T), d = d.nextSibling) : e.appendChild(document.createElement("col")).style.width = T;
      }
    }
    for (; d; ) {
      const h = d.nextSibling;
      (o = d.parentNode) == null || o.removeChild(d), d = h;
    }
    u ? (t.style.width = l + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = l + "px");
  }
}
var qn = new Gt(
  "tableColumnResizing"
);
function W3({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  View: t = H3,
  lastColumnResizable: r = !0
} = {}) {
  const i = new kt({
    key: qn,
    state: {
      init(s, o) {
        return i.spec.props.nodeViews[qt(o.schema).table.name] = (l, u) => new t(l, e, u), new Nl(-1, !1);
      },
      apply(s, o) {
        return o.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const o = qn.getState(s);
        return o && o.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, o) => {
          U3(
            s,
            o,
            n,
            e,
            r
          );
        },
        mouseleave: (s) => {
          j3(s);
        },
        mousedown: (s, o) => {
          q3(s, o, e);
        }
      },
      decorations: (s) => {
        const o = qn.getState(s);
        if (o && o.activeHandle > -1)
          return Z3(s, o.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var Nl = class {
  constructor(n, e) {
    this.activeHandle = n, this.dragging = e;
  }
  apply(n) {
    const e = this, t = n.getMeta(qn);
    if (t && t.setHandle != null)
      return new Nl(t.setHandle, !1);
    if (t && t.setDragging !== void 0)
      return new Nl(e.activeHandle, t.setDragging);
    if (e.activeHandle > -1 && n.docChanged) {
      let r = n.mapping.map(e.activeHandle, -1);
      return cf(n.doc.resolve(r)) || (r = -1), new Nl(r, e.dragging);
    }
    return e;
  }
};
function U3(n, e, t, r, i) {
  const s = qn.getState(n.state);
  if (s && !s.dragging) {
    const o = G3(e.target);
    let l = -1;
    if (o) {
      const { left: u, right: d } = o.getBoundingClientRect();
      e.clientX - u <= t ? l = Fv(n, e, "left") : d - e.clientX <= t && (l = Fv(n, e, "right"));
    }
    if (l != s.activeHandle) {
      if (!i && l !== -1) {
        const u = n.state.doc.resolve(l), d = u.node(-1), f = ft.get(d), h = u.start(-1);
        if (f.colCount(u.pos - h) + u.nodeAfter.attrs.colspan - 1 == f.width - 1)
          return;
      }
      Ib(n, l);
    }
  }
}
function j3(n) {
  const e = qn.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && Ib(n, -1);
}
function q3(n, e, t) {
  const r = qn.getState(n.state);
  if (!r || r.activeHandle == -1 || r.dragging)
    return !1;
  const i = n.state.doc.nodeAt(r.activeHandle), s = K3(n, r.activeHandle, i.attrs);
  n.dispatch(
    n.state.tr.setMeta(qn, {
      setDragging: { startX: e.clientX, startWidth: s }
    })
  );
  function o(u) {
    window.removeEventListener("mouseup", o), window.removeEventListener("mousemove", l);
    const d = qn.getState(n.state);
    d != null && d.dragging && (J3(
      n,
      d.activeHandle,
      Iv(d.dragging, u, t)
    ), n.dispatch(
      n.state.tr.setMeta(qn, { setDragging: null })
    ));
  }
  function l(u) {
    if (!u.which)
      return o(u);
    const d = qn.getState(n.state);
    if (d && d.dragging) {
      const f = Iv(d.dragging, u, t);
      Y3(n, d.activeHandle, f, t);
    }
  }
  return window.addEventListener("mouseup", o), window.addEventListener("mousemove", l), e.preventDefault(), !0;
}
function K3(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i)
    return i;
  const s = n.domAtPos(e);
  let l = s.node.childNodes[s.offset].offsetWidth, u = t;
  if (r)
    for (let d = 0; d < t; d++)
      r[d] && (l -= r[d], u--);
  return l / u;
}
function G3(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function Fv(n, e, t) {
  const r = n.posAtCoords({ left: e.clientX, top: e.clientY });
  if (!r)
    return -1;
  const { pos: i } = r, s = yo(n.state.doc.resolve(i));
  if (!s)
    return -1;
  if (t == "right")
    return s.pos;
  const o = ft.get(s.node(-1)), l = s.start(-1), u = o.map.indexOf(s.pos - l);
  return u % o.width == 0 ? -1 : l + o.map[u - 1];
}
function Iv(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function Ib(n, e) {
  n.dispatch(
    n.state.tr.setMeta(qn, { setHandle: e })
  );
}
function J3(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = ft.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, u = n.state.tr;
  for (let d = 0; d < s.height; d++) {
    const f = d * s.width + l;
    if (d && s.map[f] == s.map[f - s.width])
      continue;
    const h = s.map[f], m = i.nodeAt(h).attrs, g = m.colspan == 1 ? 0 : l - s.colCount(h);
    if (m.colwidth && m.colwidth[g] == t)
      continue;
    const y = m.colwidth ? m.colwidth.slice() : X3(m.colspan);
    y[g] = t, u.setNodeMarkup(o + h, null, { ...m, colwidth: y });
  }
  u.docChanged && n.dispatch(u);
}
function Y3(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), l = ft.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let u = n.domAtPos(i.start(-1)).node;
  for (; u && u.nodeName != "TABLE"; )
    u = u.parentNode;
  u && ff(
    s,
    u.firstChild,
    u,
    r,
    l,
    t
  );
}
function X3(n) {
  return Array(n).fill(0);
}
function Z3(n, e) {
  const t = [], r = n.doc.resolve(e), i = r.node(-1);
  if (!i)
    return ct.empty;
  const s = ft.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan;
  for (let u = 0; u < s.height; u++) {
    const d = l + u * s.width - 1;
    if ((l == s.width || s.map[d] != s.map[d + 1]) && (u == 0 || s.map[d - 1] != s.map[d - 1 - s.width])) {
      const f = s.map[d], h = o + f + i.nodeAt(f).nodeSize - 1, m = document.createElement("div");
      m.className = "column-resize-handle", t.push(hn.widget(h, m));
    }
  }
  return ct.create(n.doc, t);
}
function Ir(n) {
  const e = n.selection, t = Pu(n), r = t.node(-1), i = t.start(-1), s = ft.get(r);
  return { ...e instanceof Le ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function Rb(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  A3(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const l = o * e.width + i;
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const u = e.map[l], d = r.nodeAt(u);
      n.setNodeMarkup(
        n.mapping.map(t + u),
        null,
        Eb(d.attrs, i - e.colCount(u))
      ), o += d.attrs.rowspan - 1;
    } else {
      const u = s == null ? qt(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, d = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + d), u.createAndFill());
    }
  }
  return n;
}
function Q3(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n);
    e(Rb(n.tr, t, t.left));
  }
  return !0;
}
function ez(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n);
    e(Rb(n.tr, t, t.right));
  }
  return !0;
}
function tz(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const l = o * e.width + i, u = e.map[l], d = t.nodeAt(u), f = d.attrs;
    if (i > 0 && e.map[l - 1] == u || i < e.width - 1 && e.map[l + 1] == u)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + u),
        null,
        ps(f, i - e.colCount(u))
      );
    else {
      const h = n.mapping.slice(s).map(r + u);
      n.delete(h, h + d.nodeSize);
    }
    o += f.rowspan;
  }
}
function nz(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width)
      return !1;
    for (let i = t.right - 1; tz(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = ft.get(s);
    }
    e(r);
  }
  return !0;
}
function rz(n, e, t) {
  var r;
  const i = qt(e.type.schema).header_cell;
  for (let s = 0; s < n.width; s++)
    if (((r = e.nodeAt(n.map[s + t * n.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function Nb(n, { map: e, tableStart: t, table: r }, i) {
  var s;
  let o = t;
  for (let d = 0; d < i; d++)
    o += r.child(d).nodeSize;
  const l = [];
  let u = i > 0 ? -1 : 0;
  rz(e, r, i + u) && (u = i == 0 || i == e.height ? null : 0);
  for (let d = 0, f = e.width * i; d < e.width; d++, f++)
    if (i > 0 && i < e.height && e.map[f] == e.map[f - e.width]) {
      const h = e.map[f], m = r.nodeAt(h).attrs;
      n.setNodeMarkup(t + h, null, {
        ...m,
        rowspan: m.rowspan + 1
      }), d += m.colspan - 1;
    } else {
      const h = u == null ? qt(r.type.schema).cell : (s = r.nodeAt(e.map[f + u * e.width])) == null ? void 0 : s.type, m = h == null ? void 0 : h.createAndFill();
      m && l.push(m);
    }
  return n.insert(o, qt(r.type.schema).row.create(null, l)), n;
}
function iz(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n);
    e(Nb(n.tr, t, t.top));
  }
  return !0;
}
function sz(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n);
    e(Nb(n.tr, t, t.bottom));
  }
  return !0;
}
function oz(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let u = 0; u < i; u++)
    s += t.child(u).nodeSize;
  const o = s + t.child(i).nodeSize, l = n.mapping.maps.length;
  n.delete(s + r, o + r);
  for (let u = 0, d = i * e.width; u < e.width; u++, d++) {
    const f = e.map[d];
    if (i > 0 && f == e.map[d - e.width]) {
      const h = t.nodeAt(f).attrs;
      n.setNodeMarkup(n.mapping.slice(l).map(f + r), null, {
        ...h,
        rowspan: h.rowspan - 1
      }), u += h.colspan - 1;
    } else if (i < e.width && f == e.map[d + e.width]) {
      const h = t.nodeAt(f), m = h.attrs, g = h.type.create(
        { ...m, rowspan: h.attrs.rowspan - 1 },
        h.content
      ), y = e.positionAt(i + 1, u, t);
      n.insert(n.mapping.slice(l).map(r + y), g), u += m.colspan - 1;
    }
  }
}
function az(n, e) {
  if (!gr(n))
    return !1;
  if (e) {
    const t = Ir(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height)
      return !1;
    for (let i = t.bottom - 1; oz(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = ft.get(t.table);
    }
    e(r);
  }
  return !0;
}
function Rv(n) {
  const e = n.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function lz({ width: n, height: e, map: t }, r) {
  let i = r.top * n + r.left, s = i, o = (r.bottom - 1) * n + r.left, l = i + (r.right - r.left - 1);
  for (let u = r.top; u < r.bottom; u++) {
    if (r.left > 0 && t[s] == t[s - 1] || r.right < n && t[l] == t[l + 1])
      return !0;
    s += n, l += n;
  }
  for (let u = r.left; u < r.right; u++) {
    if (r.top > 0 && t[i] == t[i - n] || r.bottom < e && t[o] == t[o + n])
      return !0;
    i++, o++;
  }
  return !1;
}
function Nv(n, e) {
  const t = n.selection;
  if (!(t instanceof Le) || t.$anchorCell.pos == t.$headCell.pos)
    return !1;
  const r = Ir(n), { map: i } = r;
  if (lz(i, r))
    return !1;
  if (e) {
    const s = n.tr, o = {};
    let l = U.empty, u, d;
    for (let f = r.top; f < r.bottom; f++)
      for (let h = r.left; h < r.right; h++) {
        const m = i.map[f * i.width + h], g = r.table.nodeAt(m);
        if (!(o[m] || !g))
          if (o[m] = !0, u == null)
            u = m, d = g;
          else {
            Rv(g) || (l = l.append(g.content));
            const y = s.mapping.map(m + r.tableStart);
            s.delete(y, y + g.nodeSize);
          }
      }
    if (u == null || d == null)
      return !0;
    if (s.setNodeMarkup(u + r.tableStart, null, {
      ...Eb(
        d.attrs,
        d.attrs.colspan,
        r.right - r.left - d.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), l.size) {
      const f = u + 1 + d.content.size, h = Rv(d) ? u + 1 : f;
      s.replaceWith(h + r.tableStart, f + r.tableStart, l);
    }
    s.setSelection(
      new Le(s.doc.resolve(u + r.tableStart))
    ), e(s);
  }
  return !0;
}
function Bv(n, e) {
  const t = qt(n.schema);
  return uz(({ node: r }) => t[r.type.spec.tableRole])(n, e);
}
function uz(n) {
  return (e, t) => {
    var r;
    const i = e.selection;
    let s, o;
    if (i instanceof Le) {
      if (i.$anchorCell.pos != i.$headCell.pos)
        return !1;
      s = i.$anchorCell.nodeAfter, o = i.$anchorCell.pos;
    } else {
      if (s = x3(i.$from), !s)
        return !1;
      o = (r = yo(i.$from)) == null ? void 0 : r.pos;
    }
    if (s == null || o == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
      return !1;
    if (t) {
      let l = s.attrs;
      const u = [], d = l.colwidth;
      l.rowspan > 1 && (l = { ...l, rowspan: 1 }), l.colspan > 1 && (l = { ...l, colspan: 1 });
      const f = Ir(e), h = e.tr;
      for (let g = 0; g < f.right - f.left; g++)
        u.push(
          d ? {
            ...l,
            colwidth: d && d[g] ? [d[g]] : null
          } : l
        );
      let m;
      for (let g = f.top; g < f.bottom; g++) {
        let y = f.map.positionAt(g, f.left, f.table);
        g == f.top && (y += s.nodeSize);
        for (let b = f.left, w = 0; b < f.right; b++, w++)
          b == f.left && g == f.top || h.insert(
            m = h.mapping.map(y + f.tableStart, 1),
            n({ node: s, row: g, col: b }).createAndFill(u[w])
          );
      }
      h.setNodeMarkup(
        o,
        n({ node: s, row: f.top, col: f.left }),
        u[0]
      ), i instanceof Le && h.setSelection(
        new Le(
          h.doc.resolve(i.$anchorCell.pos),
          m ? h.doc.resolve(m) : void 0
        )
      ), t(h);
    }
    return !0;
  };
}
function cz(n, e) {
  return function(t, r) {
    if (!gr(t))
      return !1;
    const i = Pu(t);
    if (i.nodeAfter.attrs[n] === e)
      return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof Le ? t.selection.forEachCell((o, l) => {
        o.attrs[n] !== e && s.setNodeMarkup(l, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function dz(n) {
  return function(e, t) {
    if (!gr(e))
      return !1;
    if (t) {
      const r = qt(e.schema), i = Ir(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), l = o.map((u) => i.table.nodeAt(u));
      for (let u = 0; u < o.length; u++)
        l[u].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[u],
          r.cell,
          l[u].attrs
        );
      if (s.steps.length == 0)
        for (let u = 0; u < o.length; u++)
          s.setNodeMarkup(
            i.tableStart + o[u],
            r.header_cell,
            l[u].attrs
          );
      t(s);
    }
    return !0;
  };
}
function $v(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function ba(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? dz(n) : function(t, r) {
    if (!gr(t))
      return !1;
    if (r) {
      const i = qt(t.schema), s = Ir(t), o = t.tr, l = $v("row", s, i), u = $v(
        "column",
        s,
        i
      ), f = (n === "column" ? l : n === "row" ? u : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: f,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: f,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, m = n == "column" ? u ? i.cell : i.header_cell : n == "row" ? l ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((g) => {
        const y = g + s.tableStart, b = o.doc.nodeAt(y);
        b && o.setNodeMarkup(y, m, b.attrs);
      }), r(o);
    }
    return !0;
  };
}
ba("row", {
  useDeprecatedLogic: !0
});
ba("column", {
  useDeprecatedLogic: !0
});
var fz = ba("cell", {
  useDeprecatedLogic: !0
});
function pz(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t)
      return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount)
        return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function Lv(n) {
  return function(e, t) {
    if (!gr(e))
      return !1;
    const r = pz(Pu(e), n);
    if (r == null)
      return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(we.between(i, S3(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function hz(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function mz({
  allowTableNodeSelection: n = !1
} = {}) {
  return new kt({
    key: vi,
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(vi);
        if (r != null)
          return r == -1 ? null : r;
        if (t == null || !e.docChanged)
          return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: E3,
      handleDOMEvents: {
        mousedown: V3
      },
      createSelectionBetween(e) {
        return vi.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: P3,
      handleKeyDown: L3,
      handlePaste: z3
    },
    appendTransaction(e, t, r) {
      return O3(
        r,
        Ob(r, t),
        n
      );
    }
  });
}
function Pv(n, e, t, r, i, s) {
  let o = 0, l = !0, u = e.firstChild;
  const d = n.firstChild;
  for (let f = 0, h = 0; f < d.childCount; f += 1) {
    const { colspan: m, colwidth: g } = d.child(f).attrs;
    for (let y = 0; y < m; y += 1, h += 1) {
      const b = i === h ? s : g && g[y], w = b ? `${b}px` : "";
      o += b || r, b || (l = !1), u ? (u.style.width !== w && (u.style.width = w), u = u.nextSibling) : e.appendChild(document.createElement("col")).style.width = w;
    }
  }
  for (; u; ) {
    const f = u.nextSibling;
    u.parentNode.removeChild(u), u = f;
  }
  l ? (t.style.width = `${o}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${o}px`);
}
var gz = class {
  constructor(n, e) {
    this.node = n, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Pv(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type !== this.node.type ? !1 : (this.node = n, Pv(n, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(n) {
    return n.type === "attributes" && (n.target === this.table || this.colgroup.contains(n.target));
  }
};
function zv(n, e) {
  return e ? n.createChecked(null, e) : n.createAndFill();
}
function vz(n) {
  if (n.cached.tableNodeTypes)
    return n.cached.tableNodeTypes;
  const e = {};
  return Object.keys(n.nodes).forEach((t) => {
    const r = n.nodes[t];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), n.cached.tableNodeTypes = e, e;
}
function yz(n, e, t, r, i) {
  const s = vz(n), o = [], l = [];
  for (let d = 0; d < t; d += 1) {
    const f = zv(s.cell, i);
    if (f && l.push(f), r) {
      const h = zv(s.header_cell, i);
      h && o.push(h);
    }
  }
  const u = [];
  for (let d = 0; d < e; d += 1)
    u.push(s.row.createChecked(null, r && d === 0 ? o : l));
  return s.table.createChecked(null, u);
}
function bz(n) {
  return n instanceof Le;
}
var Tl = ({ editor: n }) => {
  const { selection: e } = n.state;
  if (!bz(e))
    return !1;
  let t = 0;
  const r = ob(e.ranges[0].$from, (s) => s.type.name === "table");
  return r == null || r.node.descendants((s) => {
    if (s.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(s.type.name) && (t += 1);
  }), t === e.ranges.length ? (n.commands.deleteTable(), !0) : !1;
}, _z = mt.create({
  name: "table",
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      View: gz,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["table", nt(this.options.HTMLAttributes, n), ["tbody", 0]];
  },
  addCommands() {
    return {
      insertTable: ({ rows: n = 3, cols: e = 3, withHeaderRow: t = !0 } = {}) => ({ tr: r, dispatch: i, editor: s }) => {
        const o = yz(s.schema, n, e, t);
        if (i) {
          const l = r.selection.anchor + 1;
          r.replaceSelectionWith(o).scrollIntoView().setSelection(we.near(r.doc.resolve(l)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: n, dispatch: e }) => Q3(n, e),
      addColumnAfter: () => ({ state: n, dispatch: e }) => ez(n, e),
      deleteColumn: () => ({ state: n, dispatch: e }) => nz(n, e),
      addRowBefore: () => ({ state: n, dispatch: e }) => iz(n, e),
      addRowAfter: () => ({ state: n, dispatch: e }) => sz(n, e),
      deleteRow: () => ({ state: n, dispatch: e }) => az(n, e),
      deleteTable: () => ({ state: n, dispatch: e }) => hz(n, e),
      mergeCells: () => ({ state: n, dispatch: e }) => Nv(n, e),
      splitCell: () => ({ state: n, dispatch: e }) => Bv(n, e),
      toggleHeaderColumn: () => ({ state: n, dispatch: e }) => ba("column")(n, e),
      toggleHeaderRow: () => ({ state: n, dispatch: e }) => ba("row")(n, e),
      toggleHeaderCell: () => ({ state: n, dispatch: e }) => fz(n, e),
      mergeOrSplit: () => ({ state: n, dispatch: e }) => Nv(n, e) ? !0 : Bv(n, e),
      setCellAttribute: (n, e) => ({ state: t, dispatch: r }) => cz(n, e)(t, r),
      goToNextCell: () => ({ state: n, dispatch: e }) => Lv(1)(n, e),
      goToPreviousCell: () => ({ state: n, dispatch: e }) => Lv(-1)(n, e),
      fixTables: () => ({ state: n, dispatch: e }) => (e && Ob(n), !0),
      setCellSelection: (n) => ({ tr: e, dispatch: t }) => {
        if (t) {
          const r = Le.create(e.doc, n.anchorCell, n.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: Tl,
      "Mod-Backspace": Tl,
      Delete: Tl,
      "Mod-Delete": Tl
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        W3({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      mz({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(n) {
    const e = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      tableRole: Ae(se(n, "tableRole", e))
    };
  }
}), wz = _z, Dz = mt.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? [parseInt(e, 10)] : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["td", nt(this.options.HTMLAttributes, n), 0];
  }
}), Cz = Dz, xz = mt.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? [parseInt(e, 10)] : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["th", nt(this.options.HTMLAttributes, n), 0];
  }
}), kz = xz, Sz = mt.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["tr", nt(this.options.HTMLAttributes, n), 0];
  }
}), Az = Sz, Ez = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, Tz = mt.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["img", nt(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setImage: (n) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: n
      })
    };
  },
  addInputRules() {
    return [
      Xf({
        find: Ez,
        type: this.type,
        getAttributes: (n) => {
          const [, , e, t, r] = n;
          return { src: t, alt: e, title: r };
        }
      })
    ];
  }
}), Mz = Tz;
function np(n) {
  this.j = {}, this.jr = [], this.jd = null, this.t = n;
}
np.prototype = {
  accepts: function() {
    return !!this.t;
  },
  tt: function(e, t) {
    if (t && t.j)
      return this.j[e] = t, t;
    var r = t, i = this.j[e];
    if (i)
      return r && (i.t = r), i;
    i = Ge();
    var s = ru(this, e);
    return s ? (Object.assign(i.j, s.j), i.jr.append(s.jr), i.jr = s.jd, i.t = r || s.t) : i.t = r, this.j[e] = i, i;
  }
};
var Ge = function() {
  return new np();
}, me = function(e) {
  return new np(e);
}, Y = function(e, t, r) {
  e.j[t] || (e.j[t] = r);
}, At = function(e, t, r) {
  e.jr.push([t, r]);
}, ru = function(e, t) {
  var r = e.j[t];
  if (r)
    return r;
  for (var i = 0; i < e.jr.length; i++) {
    var s = e.jr[i][0], o = e.jr[i][1];
    if (s.test(t))
      return o;
  }
  return e.jd;
}, Re = function(e, t, r) {
  for (var i = 0; i < t.length; i++)
    Y(e, t[i], r);
}, Oz = function(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r][0], s = t[r][1];
    Y(e, i, s);
  }
}, ji = function(e, t, r, i) {
  for (var s = 0, o = t.length, l; s < o && (l = e.j[t[s]]); )
    e = l, s++;
  if (s >= o)
    return [];
  for (; s < o - 1; )
    l = i(), Y(e, t[s], l), e = l, s++;
  Y(e, t[o - 1], r);
}, ar = "DOMAIN", Kr = "LOCALHOST", xr = "TLD", Wn = "NUM", fo = "PROTOCOL", rp = "MAILTO", Bb = "WS", ip = "NL", Hs = "OPENBRACE", oa = "OPENBRACKET", aa = "OPENANGLEBRACKET", la = "OPENPAREN", Zi = "CLOSEBRACE", Ws = "CLOSEBRACKET", Us = "CLOSEANGLEBRACKET", js = "CLOSEPAREN", iu = "AMPERSAND", su = "APOSTROPHE", ou = "ASTERISK", qs = "AT", au = "BACKSLASH", lu = "BACKTICK", uu = "CARET", ua = "COLON", sp = "COMMA", cu = "DOLLAR", mi = "DOT", du = "EQUALS", op = "EXCLAMATION", fu = "HYPHEN", pu = "PERCENT", hu = "PIPE", mu = "PLUS", gu = "POUND", vu = "QUERY", ap = "QUOTE", lp = "SEMI", Gr = "SLASH", yu = "TILDE", bu = "UNDERSCORE", _u = "SYM", Fz = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DOMAIN: ar,
  LOCALHOST: Kr,
  TLD: xr,
  NUM: Wn,
  PROTOCOL: fo,
  MAILTO: rp,
  WS: Bb,
  NL: ip,
  OPENBRACE: Hs,
  OPENBRACKET: oa,
  OPENANGLEBRACKET: aa,
  OPENPAREN: la,
  CLOSEBRACE: Zi,
  CLOSEBRACKET: Ws,
  CLOSEANGLEBRACKET: Us,
  CLOSEPAREN: js,
  AMPERSAND: iu,
  APOSTROPHE: su,
  ASTERISK: ou,
  AT: qs,
  BACKSLASH: au,
  BACKTICK: lu,
  CARET: uu,
  COLON: ua,
  COMMA: sp,
  DOLLAR: cu,
  DOT: mi,
  EQUALS: du,
  EXCLAMATION: op,
  HYPHEN: fu,
  PERCENT: pu,
  PIPE: hu,
  PLUS: mu,
  POUND: gu,
  QUERY: vu,
  QUOTE: ap,
  SEMI: lp,
  SLASH: Gr,
  TILDE: yu,
  UNDERSCORE: bu,
  SYM: _u
}), Vv = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermgensberater-ctb vermgensberatung-pwb                                                                                                                                                        ".split(" "), Uo = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/, jo = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/, qo = /\uFE0F/, Ko = /\d/, Hv = /\s/;
function Iz() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = Ge(), t = me(Wn), r = me(ar), i = Ge(), s = me(Bb), o = [[Ko, r], [Uo, r], [jo, r], [qo, r]], l = function() {
    var C = me(ar);
    return C.j = {
      "-": i
    }, C.jr = [].concat(o), C;
  }, u = function(C) {
    var R = l();
    return R.t = C, R;
  };
  Oz(e, [["'", me(su)], ["{", me(Hs)], ["[", me(oa)], ["<", me(aa)], ["(", me(la)], ["}", me(Zi)], ["]", me(Ws)], [">", me(Us)], [")", me(js)], ["&", me(iu)], ["*", me(ou)], ["@", me(qs)], ["`", me(lu)], ["^", me(uu)], [":", me(ua)], [",", me(sp)], ["$", me(cu)], [".", me(mi)], ["=", me(du)], ["!", me(op)], ["-", me(fu)], ["%", me(pu)], ["|", me(hu)], ["+", me(mu)], ["#", me(gu)], ["?", me(vu)], ['"', me(ap)], ["/", me(Gr)], [";", me(lp)], ["~", me(yu)], ["_", me(bu)], ["\\", me(au)]]), Y(e, `
`, me(ip)), At(e, Hv, s), Y(s, `
`, Ge()), At(s, Hv, s);
  for (var d = 0; d < Vv.length; d++)
    ji(e, Vv[d], u(xr), l);
  var f = l(), h = l(), m = l(), g = l();
  ji(e, "file", f, l), ji(e, "ftp", h, l), ji(e, "http", m, l), ji(e, "mailto", g, l);
  var y = l(), b = me(fo), w = me(rp);
  Y(h, "s", y), Y(h, ":", b), Y(m, "s", y), Y(m, ":", b), Y(f, ":", b), Y(y, ":", b), Y(g, ":", w);
  for (var T = l(), k = 0; k < n.length; k++)
    ji(e, n[k], T, l);
  return Y(T, ":", b), ji(e, "localhost", u(Kr), l), At(e, Ko, t), At(e, Uo, r), At(e, jo, r), At(e, qo, r), At(t, Ko, t), At(t, Uo, r), At(t, jo, r), At(t, qo, r), Y(t, "-", i), Y(r, "-", i), Y(i, "-", i), At(r, Ko, r), At(r, Uo, r), At(r, jo, r), At(r, qo, r), At(i, Ko, r), At(i, Uo, r), At(i, jo, r), At(i, qo, r), e.jd = me(_u), e;
}
function Rz(n, e) {
  for (var t = Nz(e.replace(/[A-Z]/g, function(g) {
    return g.toLowerCase();
  })), r = t.length, i = [], s = 0, o = 0; o < r; ) {
    for (var l = n, u = null, d = 0, f = null, h = -1, m = -1; o < r && (u = ru(l, t[o])); )
      l = u, l.accepts() ? (h = 0, m = 0, f = l) : h >= 0 && (h += t[o].length, m++), d += t[o].length, s += t[o].length, o++;
    s -= h, o -= m, d -= h, i.push({
      t: f.t,
      v: e.substr(s - d, d),
      s: s - d,
      e: s
    });
  }
  return i;
}
function Nz(n) {
  for (var e = [], t = n.length, r = 0; r < t; ) {
    var i = n.charCodeAt(r), s = void 0, o = i < 55296 || i > 56319 || r + 1 === t || (s = n.charCodeAt(r + 1)) < 56320 || s > 57343 ? n[r] : n.slice(r, r + 2);
    e.push(o), r += o.length;
  }
  return e;
}
function Bl(n) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Bl = function(e) {
    return typeof e;
  } : Bl = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Bl(n);
}
var Ht = {
  defaultProtocol: "http",
  events: null,
  format: Wv,
  formatHref: Wv,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
function Bz(n) {
  n = n || {}, this.defaultProtocol = "defaultProtocol" in n ? n.defaultProtocol : Ht.defaultProtocol, this.events = "events" in n ? n.events : Ht.events, this.format = "format" in n ? n.format : Ht.format, this.formatHref = "formatHref" in n ? n.formatHref : Ht.formatHref, this.nl2br = "nl2br" in n ? n.nl2br : Ht.nl2br, this.tagName = "tagName" in n ? n.tagName : Ht.tagName, this.target = "target" in n ? n.target : Ht.target, this.rel = "rel" in n ? n.rel : Ht.rel, this.validate = "validate" in n ? n.validate : Ht.validate, this.truncate = "truncate" in n ? n.truncate : Ht.truncate, this.className = "className" in n ? n.className : Ht.className, this.attributes = n.attributes || Ht.attributes, this.ignoreTags = [];
  for (var e = ("ignoreTags" in n) ? n.ignoreTags : Ht.ignoreTags, t = 0; t < e.length; t++)
    this.ignoreTags.push(e[t].toUpperCase());
}
Bz.prototype = {
  resolve: function(e) {
    var t = e.toHref(this.defaultProtocol);
    return {
      formatted: this.get("format", e.toString(), e),
      formattedHref: this.get("formatHref", t, e),
      tagName: this.get("tagName", t, e),
      className: this.get("className", t, e),
      target: this.get("target", t, e),
      rel: this.get("rel", t, e),
      events: this.getObject("events", t, e),
      attributes: this.getObject("attributes", t, e),
      truncate: this.get("truncate", t, e)
    };
  },
  check: function(e) {
    return this.get("validate", e.toString(), e);
  },
  get: function(e, t, r) {
    var i = this[e];
    if (!i)
      return i;
    var s;
    switch (Bl(i)) {
      case "function":
        return i(t, r.t);
      case "object":
        return s = r.t in i ? i[r.t] : Ht[e], typeof s == "function" ? s(t, r.t) : s;
    }
    return i;
  },
  getObject: function(e, t, r) {
    var i = this[e];
    return typeof i == "function" ? i(t, r.t) : i;
  }
};
function Wv(n) {
  return n;
}
function $z(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = Object.create(n.prototype);
  for (var i in t)
    r[i] = t[i];
  return r.constructor = e, e.prototype = r, e;
}
function wu() {
}
wu.prototype = {
  t: "token",
  isLink: !1,
  toString: function() {
    return this.v;
  },
  toHref: function() {
    return this.toString();
  },
  startIndex: function() {
    return this.tk[0].s;
  },
  endIndex: function() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ht.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
};
function ms(n, e) {
  function t(r, i) {
    this.t = n, this.v = r, this.tk = i;
  }
  return $z(wu, t, e), t;
}
var $b = ms("email", {
  isLink: !0
}), pf = ms("email", {
  isLink: !0,
  toHref: function() {
    return "mailto:" + this.toString();
  }
}), hf = ms("text"), Lb = ms("nl"), pi = ms("url", {
  isLink: !0,
  toHref: function() {
    for (var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ht.defaultProtocol, t = this.tk, r = !1, i = !1, s = [], o = 0; t[o].t === fo; )
      r = !0, s.push(t[o].v), o++;
    for (; t[o].t === Gr; )
      i = !0, s.push(t[o].v), o++;
    for (; o < t.length; o++)
      s.push(t[o].v);
    return s = s.join(""), r || i || (s = "".concat(e, "://").concat(s)), s;
  },
  hasProtocol: function() {
    return this.tk[0].t === fo;
  }
}), Lz = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MultiToken: wu,
  Base: wu,
  createTokenClass: ms,
  MailtoEmail: $b,
  Email: pf,
  Text: hf,
  Nl: Lb,
  Url: pi
});
function Pz() {
  var n = Ge(), e = Ge(), t = Ge(), r = Ge(), i = Ge(), s = Ge(), o = Ge(), l = me(pi), u = Ge(), d = me(pi), f = me(pi), h = Ge(), m = Ge(), g = Ge(), y = Ge(), b = Ge(), w = me(pi), T = me(pi), k = me(pi), S = me(pi), C = Ge(), R = Ge(), I = Ge(), P = Ge(), L = Ge(), q = Ge(), oe = me(pf), ae = Ge(), ke = me(pf), Ee = me($b), rt = Ge(), Qe = Ge(), Ke = Ge(), He = Ge(), De = me(Lb);
  Y(n, ip, De), Y(n, fo, e), Y(n, rp, t), Y(e, Gr, r), Y(r, Gr, i), Y(n, xr, s), Y(n, ar, s), Y(n, Kr, l), Y(n, Wn, s), Y(i, xr, f), Y(i, ar, f), Y(i, Wn, f), Y(i, Kr, f), Y(s, mi, o), Y(L, mi, q), Y(o, xr, l), Y(o, ar, s), Y(o, Wn, s), Y(o, Kr, s), Y(q, xr, oe), Y(q, ar, L), Y(q, Wn, L), Y(q, Kr, L), Y(l, mi, o), Y(oe, mi, q), Y(l, ua, u), Y(l, Gr, f), Y(u, Wn, d), Y(d, Gr, f), Y(oe, ua, ae), Y(ae, Wn, ke);
  var Te = [iu, ou, qs, au, lu, uu, cu, ar, du, fu, Kr, Wn, pu, hu, mu, gu, fo, Gr, _u, yu, xr, bu], Oe = [su, Us, Zi, Ws, js, ua, sp, mi, op, aa, Hs, oa, la, vu, ap, lp];
  Y(f, Hs, m), Y(f, oa, g), Y(f, aa, y), Y(f, la, b), Y(h, Hs, m), Y(h, oa, g), Y(h, aa, y), Y(h, la, b), Y(m, Zi, f), Y(g, Ws, f), Y(y, Us, f), Y(b, js, f), Y(w, Zi, f), Y(T, Ws, f), Y(k, Us, f), Y(S, js, f), Y(C, Zi, f), Y(R, Ws, f), Y(I, Us, f), Y(P, js, f), Re(m, Te, w), Re(g, Te, T), Re(y, Te, k), Re(b, Te, S), Re(m, Oe, C), Re(g, Oe, R), Re(y, Oe, I), Re(b, Oe, P), Re(w, Te, w), Re(T, Te, T), Re(k, Te, k), Re(S, Te, S), Re(w, Oe, w), Re(T, Oe, T), Re(k, Oe, k), Re(S, Oe, S), Re(C, Te, w), Re(R, Te, T), Re(I, Te, k), Re(P, Te, S), Re(C, Oe, C), Re(R, Oe, R), Re(I, Oe, I), Re(P, Oe, P), Re(f, Te, f), Re(h, Te, f), Re(f, Oe, h), Re(h, Oe, h), Y(t, xr, Ee), Y(t, ar, Ee), Y(t, Wn, Ee), Y(t, Kr, Ee), Re(Ee, Te, Ee), Re(Ee, Oe, rt), Re(rt, Te, Ee), Re(rt, Oe, rt);
  var je = [iu, su, ou, au, lu, uu, Zi, cu, ar, du, fu, Wn, Hs, pu, hu, mu, gu, vu, Gr, _u, yu, xr, bu];
  return Re(s, je, Qe), Y(s, qs, Ke), Re(l, je, Qe), Y(l, qs, Ke), Re(o, je, Qe), Re(Qe, je, Qe), Y(Qe, qs, Ke), Y(Qe, mi, He), Re(He, je, Qe), Y(Ke, xr, L), Y(Ke, ar, L), Y(Ke, Wn, L), Y(Ke, Kr, oe), n;
}
function zz(n, e, t) {
  for (var r = t.length, i = 0, s = [], o = []; i < r; ) {
    for (var l = n, u = null, d = null, f = 0, h = null, m = -1; i < r && !(u = ru(l, t[i].t)); )
      o.push(t[i++]);
    for (; i < r && (d = u || ru(l, t[i].t)); )
      u = null, l = d, l.accepts() ? (m = 0, h = l) : m >= 0 && m++, i++, f++;
    if (m < 0)
      for (var g = i - f; g < i; g++)
        o.push(t[g]);
    else {
      o.length > 0 && (s.push(Td(hf, e, o)), o = []), i -= m, f -= m;
      var y = h.t, b = t.slice(i - f, i);
      s.push(Td(y, e, b));
    }
  }
  return o.length > 0 && s.push(Td(hf, e, o)), s;
}
function Td(n, e, t) {
  var r = t[0].s, i = t[t.length - 1].e, s = e.substr(r, i - r);
  return new n(s, t);
}
var Vz = typeof console < "u" && console && console.warn || function() {
}, Et = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: !1
};
function Hz() {
  Et.scanner = null, Et.parser = null, Et.pluginQueue = [], Et.customProtocols = [], Et.initialized = !1;
}
function Wz(n) {
  if (Et.initialized && Vz('linkifyjs: already initialized - will not register custom protocol "'.concat(n, '" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')), !/^[a-z-]+$/.test(n))
    throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");
  Et.customProtocols.push(n);
}
function Uz() {
  Et.scanner = {
    start: Iz(Et.customProtocols),
    tokens: Fz
  }, Et.parser = {
    start: Pz(),
    tokens: Lz
  };
  for (var n = {
    createTokenClass: ms
  }, e = 0; e < Et.pluginQueue.length; e++)
    Et.pluginQueue[e][1]({
      scanner: Et.scanner,
      parser: Et.parser,
      utils: n
    });
  Et.initialized = !0;
}
function Pb(n) {
  return Et.initialized || Uz(), zz(Et.parser.start, n, Rz(Et.scanner.start, n));
}
function up(n) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = Pb(n), r = [], i = 0; i < t.length; i++) {
    var s = t[i];
    s.isLink && (!e || s.t === e) && r.push(s.toObject());
  }
  return r;
}
function Uv(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = Pb(n);
  return t.length === 1 && t[0].isLink && (!e || t[0].t === e);
}
function jz(n) {
  return new kt({
    key: new Gt("autolink"),
    appendTransaction: (e, t, r) => {
      const i = e.some((f) => f.docChanged) && !t.doc.eq(r.doc), s = e.some((f) => f.getMeta("preventAutolink"));
      if (!i || s)
        return;
      const { tr: o } = r, l = z$(t.doc, [...e]), { mapping: u } = l;
      if (G$(l).forEach(({ oldRange: f, newRange: h }) => {
        Ql(f.from, f.to, t.doc).filter((b) => b.mark.type === n.type).forEach((b) => {
          const w = u.map(b.from), T = u.map(b.to), k = Ql(w, T, r.doc).filter(
            (L) => L.mark.type === n.type
          );
          if (!k.length)
            return;
          const S = k[0], C = t.doc.textBetween(b.from, b.to, void 0, " "), R = r.doc.textBetween(S.from, S.to, void 0, " "), I = Uv(C), P = Uv(R);
          I && !P && o.removeMark(S.from, S.to, n.type);
        });
        const m = H$(
          r.doc,
          h,
          (b) => b.isTextblock
        );
        let g, y;
        if (m.length > 1 ? (g = m[0], y = r.doc.textBetween(
          g.pos,
          g.pos + g.node.nodeSize,
          void 0,
          " "
        )) : m.length && r.doc.textBetween(h.from, h.to, " ", " ").endsWith(" ") && (g = m[0], y = r.doc.textBetween(
          g.pos,
          h.to,
          void 0,
          " "
        )), g && y) {
          const b = y.split(" ").filter((k) => k !== "");
          if (b.length <= 0)
            return !1;
          const w = b[b.length - 1], T = g.pos + y.lastIndexOf(w);
          if (!w)
            return !1;
          up(w).filter((k) => k.isLink).filter((k) => n.validate ? n.validate(k.value) : !0).map((k) => ({
            ...k,
            from: T + k.start + 1,
            to: T + k.end + 1
          })).forEach((k) => {
            o.addMark(
              k.from,
              k.to,
              n.type.create({
                href: k.href
              })
            );
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function qz(n) {
  return new kt({
    key: new Gt("handleClickLink"),
    props: {
      handleClick: (e, t, r) => {
        var i;
        const s = ab(e.state, n.type.name);
        return ((i = r.target) == null ? void 0 : i.closest("a")) && s.href ? (window.open(s.href, s.target), !0) : !1;
      }
    }
  });
}
function Kz(n) {
  return new kt({
    key: new Gt("handlePasteLink"),
    props: {
      handlePaste: (e, t, r) => {
        const { state: i } = e, { selection: s } = i, { empty: o } = s;
        if (o)
          return !1;
        let l = "";
        r.content.forEach((d) => {
          l += d.textContent;
        });
        const u = up(l).find((d) => d.isLink && d.value === l);
        return !l || !u ? !1 : (n.editor.commands.setMark(n.type, {
          href: u.href
        }), !0);
      }
    }
  });
}
var Gz = Xn.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  onCreate() {
    this.options.protocols.forEach(Wz);
  },
  onDestroy() {
    Hz();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["a", nt(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setLink: (n) => ({ chain: e }) => e().setMark(this.name, n).setMeta("preventAutolink", !0).run(),
      toggleLink: (n) => ({ chain: e }) => e().toggleMark(this.name, n, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: n }) => n().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ei({
        find: (n) => up(n).filter((e) => this.options.validate ? this.options.validate(e.value) : !0).filter((e) => e.isLink).map((e) => ({
          text: e.value,
          index: e.start,
          data: e
        })),
        type: this.type,
        getAttributes: (n) => {
          var e;
          return {
            href: (e = n.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const n = [];
    return this.options.autolink && n.push(
      jz({
        type: this.type,
        validate: this.options.validate
      })
    ), this.options.openOnClick && n.push(
      qz({
        type: this.type
      })
    ), this.options.linkOnPaste && n.push(
      Kz({
        editor: this.editor,
        type: this.type
      })
    ), n;
  }
}), Jz = Gz;
const zb = (n) => (Ye("data-v-3a30da4e"), n = n(), Xe(), n), Yz = { class: "input-table" }, Xz = /* @__PURE__ */ zb(() => /* @__PURE__ */ O("i", { class: "i-youcan-table" }, null, -1)), Zz = /* @__PURE__ */ zb(() => /* @__PURE__ */ O("i", { class: "i-youcan-plus" }, null, -1)), Qz = /* @__PURE__ */ K({
  __name: "Table",
  emits: ["insert"],
  setup(n, { emit: e }) {
    const t = e, r = G(), i = G(), s = G(), o = G(!1), l = () => {
      t("insert", { rows: r.value, cols: i.value });
    }, u = (d = !o.value) => o.value = d;
    return mr(s, () => {
      u(!1);
    }), (d, f) => (E(), F("div", Yz, [
      ce(X(rn), {
        size: "sm",
        "icon-position": "only",
        onClick: f[0] || (f[0] = (h) => u())
      }, {
        icon: ee(() => [
          Xz
        ]),
        _: 1
      }),
      yt(O("div", {
        ref_key: "dropdownRef",
        ref: s,
        class: "table-dropdown"
      }, [
        ce(ss, {
          modelValue: r.value,
          "onUpdate:modelValue": f[1] || (f[1] = (h) => r.value = h),
          type: "number",
          placeholder: "rows"
        }, null, 8, ["modelValue"]),
        ce(ss, {
          modelValue: i.value,
          "onUpdate:modelValue": f[2] || (f[2] = (h) => i.value = h),
          type: "number",
          placeholder: "columns"
        }, null, 8, ["modelValue"]),
        ce(X(Ca), {
          onClick: f[3] || (f[3] = (h) => l())
        }, {
          icon: ee(() => [
            Zz
          ]),
          default: ee(() => [
            nn(" Insert table ")
          ]),
          _: 1
        })
      ], 512), [
        [Kn, o.value]
      ])
    ]));
  }
});
const e8 = /* @__PURE__ */ J(Qz, [["__scopeId", "data-v-3a30da4e"]]), t8 = v3.extend({
  addAttributes() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      fontSize: {
        default: null,
        parseHTML: (e) => e.style.fontSize.replace("px", ""),
        renderHTML: (e) => e.fontSize ? {
          style: `font-size: ${e.fontSize}px`
        } : {}
      }
    };
  },
  addCommands() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      setFontSize: (e) => ({ commands: t }) => t.setMark(this.name, { fontSize: e }),
      unsetFontSize: () => ({ chain: e }) => e().setMark(this.name, { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), n8 = ["#61BD6D", "#1ABC9C", "#54ACD2", "#2C82C9", "#9365B8", "#475577", "#CCCCCC", "#41A85F", "#00A885", "#3D8EB9", "#2969B0", "#553982", "#28324E"], r8 = { class: "input-color" }, i8 = { class: "swatches" }, s8 = ["onClick"], o8 = /* @__PURE__ */ K({
  __name: "Color",
  props: {
    modelValue: {},
    icon: {},
    swatches: { default: () => n8 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(""), s = G(), o = G(!1), l = ue({
      get: () => t.modelValue,
      set: (f) => {
        r("update:modelValue", f), i.value = f;
      }
    }), u = (f) => {
      l.value = f;
    }, d = (f = !o.value) => o.value = f;
    return mr(s, () => {
      d(!1);
    }), En(i, (f) => {
      l.value = f;
    }), (f, h) => (E(), F("div", r8, [
      ce(X(rn), {
        size: "sm",
        "icon-position": "only",
        onClick: h[0] || (h[0] = (m) => d())
      }, {
        icon: ee(() => [
          O("i", {
            class: de(f.icon)
          }, null, 2)
        ]),
        _: 1
      }),
      yt(O("div", {
        ref_key: "dropdownRef",
        ref: s,
        class: "colors-dropdown"
      }, [
        O("ul", i8, [
          (E(!0), F(ze, null, Je(f.swatches, (m, g) => (E(), F("li", {
            key: g,
            class: "swatch",
            style: Tn({ backgroundColor: m }),
            onClick: (y) => u(m)
          }, null, 12, s8))), 128))
        ]),
        ce(D0, {
          modelValue: i.value,
          "onUpdate:modelValue": h[1] || (h[1] = (m) => i.value = m),
          placeholder: "hex color"
        }, null, 8, ["modelValue"])
      ], 512), [
        [Kn, o.value]
      ])
    ]));
  }
});
const a8 = /* @__PURE__ */ J(o8, [["__scopeId", "data-v-088c0b1f"]]), l8 = 10, jv = 2e3, qv = 2e3;
function u8(n, e, t, r, i) {
  if (!r && e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]) {
    const s = e.dataTransfer.files[0], o = (s.size / 1024 / 1024).toFixed(4);
    if (s.type !== "image/jpeg" && s.type !== "image/png" || Number(o) < l8)
      return alert("image not valid");
    const l = window.URL || window.webkitURL, u = new Image();
    return u.src = l.createObjectURL(s), u.onload = async function() {
      if (u.width > jv || u.height > qv)
        alert(`image not valid max image size is ${jv} x ${qv}`);
      else {
        const d = await i(s);
        if (!d)
          return alert("failed to update the image");
        const { schema: f } = n.state, h = n.posAtCoords({ left: e.clientX, top: e.clientY }), m = f.nodes.image.create({ src: d }), g = n.state.tr.insert(h.pos, m);
        return n.dispatch(g);
      }
    }, !0;
  }
  return !1;
}
const c8 = mt.create({
  name: "iframe",
  group: "block",
  atom: !0,
  addOptions() {
    return {
      allowFullscreen: !0,
      HTMLAttributes: {
        class: "iframe-wrapper"
      }
    };
  },
  addAttributes() {
    return {
      src: {
        default: null
      },
      frameborder: {
        default: 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [{
      tag: "iframe"
    }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["div", this.options.HTMLAttributes, ["iframe", n]];
  },
  addCommands() {
    return {
      setIframe: (n) => ({ tr: e, dispatch: t }) => {
        const { selection: r } = e, i = this.type.create(n);
        return t && e.replaceRangeWith(r.from, r.to, i), !0;
      }
    };
  }
}), d8 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f8 = { class: "input-emoji" }, p8 = { class: "emojis" }, h8 = ["onClick"], m8 = /* @__PURE__ */ K({
  __name: "EmojiPicker",
  props: {
    icon: {},
    emojis: { default: () => d8 }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = e, r = G(), i = G(!1), s = ue({
      get: () => "",
      set: (u) => {
        t("select", u);
      }
    }), o = (u) => {
      s.value = u;
    }, l = (u = !i.value) => i.value = u;
    return mr(r, () => {
      l(!1);
    }), (u, d) => (E(), F("div", f8, [
      ce(rn, {
        size: "sm",
        "icon-position": "only",
        onClick: d[0] || (d[0] = (f) => l())
      }, {
        icon: ee(() => [
          O("i", {
            class: de(u.icon)
          }, null, 2)
        ]),
        _: 1
      }),
      yt(O("div", {
        ref_key: "dropdownRef",
        ref: r,
        class: "emojis-dropdown"
      }, [
        O("ul", p8, [
          (E(!0), F(ze, null, Je(u.emojis, (f, h) => (E(), F("li", {
            key: h,
            class: "emoji",
            onClick: (m) => o(f)
          }, re(f), 9, h8))), 128))
        ])
      ], 512), [
        [Kn, i.value]
      ])
    ]));
  }
});
const g8 = /* @__PURE__ */ J(m8, [["__scopeId", "data-v-a62e838e"]]), v8 = { class: "tooltip" }, y8 = { class: "label" }, b8 = /* @__PURE__ */ K({
  __name: "Tooltip",
  props: {
    label: {}
  },
  setup(n) {
    return (e, t) => (E(), F("div", v8, [
      O("span", y8, re(e.label), 1),
      fe(e.$slots, "default", {}, void 0, !0)
    ]));
  }
});
const _8 = /* @__PURE__ */ J(b8, [["__scopeId", "data-v-71a5a39e"]]), Kv = (() => {
  const n = [];
  for (let e = 8; e < 100; e++)
    e % 2 === 0 && n.push({ label: String(e), value: e });
  return n;
})(), Gv = [
  { icon: "i-youcan-text-align-left", label: "left", value: "left" },
  { icon: "i-youcan-text-align-center", label: "center", value: "center" },
  { icon: "i-youcan-text-align-right", label: "right", value: "right" },
  { icon: "i-youcan-text-align-justify", label: "justify", value: "justify" }
];
function w8(n) {
  return e0({
    bold: {
      tooltip: "Bold (ctrl+B)",
      type: "TertiaryButton",
      icon: "i-youcan-text-bolder",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleBold().run();
      }
    },
    italic: {
      tooltip: "Italic (ctrl+I)",
      type: "TertiaryButton",
      icon: "i-youcan-text-italic",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleItalic().run();
      }
    },
    underline: {
      tooltip: "Underline (ctrl+U)",
      type: "TertiaryButton",
      icon: "i-youcan-text-underline",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().setUnderline().run();
      }
    },
    strike: {
      tooltip: "Strikethrough (ctrl+shift+X)",
      type: "TertiaryButton",
      icon: "i-youcan-text-strikethrough",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleStrike().run();
      }
    },
    color: {
      tooltip: "Text color",
      type: "Colors",
      model: "#000000",
      icon: "i-youcan-eyedropper-sample"
    },
    highlight: {
      tooltip: "Background color",
      type: "Colors",
      model: "#000000",
      icon: "i-youcan-paint-bucket"
    },
    fontSize: {
      tooltip: "Font size",
      type: "Dropdown",
      items: Kv,
      model: Kv[0]
    },
    textAlign: {
      tooltip: "Text alignment",
      type: "Dropdown",
      items: Gv,
      model: Gv[0]
    },
    ol: {
      tooltip: "Ordered list",
      type: "TertiaryButton",
      icon: "i-youcan-list-numbers",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleOrderedList().run();
      }
    },
    ul: {
      tooltip: "Unordered list",
      type: "TertiaryButton",
      icon: "i-youcan-list-numbers",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleBulletList().run();
      }
    },
    undo: {
      tooltip: "Undo",
      type: "TertiaryButton",
      icon: "i-youcan-arrow-bend-up-left",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().undo().run();
      }
    },
    redo: {
      tooltip: "Redo",
      type: "TertiaryButton",
      icon: "i-youcan-arrow-bend-up-right",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().redo().run();
      }
    },
    emoji: {
      tooltip: "Insert emojis",
      type: "EmojiPicker",
      icon: "i-youcan-smiley-sticker"
    },
    link: {
      tooltip: "Insert link",
      type: "TertiaryButton",
      icon: "i-youcan-link-simple",
      action: () => {
        var r;
        const e = (r = n == null ? void 0 : n.value) == null ? void 0 : r.getAttributes("link").href, t = window.prompt("URL", e);
        if (t !== null) {
          if (t === "")
            return n == null ? void 0 : n.value.chain().focus().extendMarkRange("link").unsetLink().run();
          n == null || n.value.chain().focus().extendMarkRange("link").setLink({ href: t }).run();
        }
      }
    },
    hr: {
      tooltip: "Insert divider",
      type: "TertiaryButton",
      icon: "i-youcan-minus",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().setHorizontalRule().run();
      }
    },
    table: {
      tooltip: "Insert table",
      type: "table",
      model: { rows: "2", cols: "2" }
    },
    code: {
      tooltip: "Code",
      type: "TertiaryButton",
      icon: "i-youcan-code",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().toggleCodeBlock().run();
      }
    },
    image: {
      tooltip: "Insert image",
      type: "TertiaryButton",
      icon: "i-youcan-image",
      action: () => {
        var t;
        const e = window.prompt("URL");
        e && ((t = n.value) == null || t.chain().focus().setImage({ src: e }).run());
      }
    },
    embed: {
      tooltip: "Embed video",
      type: "TertiaryButton",
      icon: "i-youcan-video-camera",
      action: () => {
        var t;
        const e = window.prompt("URL");
        e && ((t = n.value) == null || t.chain().focus().setIframe({ src: e }).run());
      }
    },
    clear: {
      tooltip: "Clear formatting",
      type: "SecondaryButton",
      label: "clear formatting",
      action: () => {
        var e;
        return (e = n.value) == null ? void 0 : e.chain().focus().clearNodes().unsetAllMarks().run();
      }
    }
  });
}
const D8 = { class: "rich-text-editor" }, C8 = { class: "tool-bar" }, x8 = /* @__PURE__ */ K({
  __name: "RichText",
  props: {
    modelValue: {},
    dir: { default: "ltr" },
    uploadImageHandler: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = oP({
      content: t.modelValue,
      onUpdate: ({ editor: u }) => {
        const d = u.getHTML();
        r("update:modelValue", d);
      },
      editorProps: {
        handleDrop: (u, d, f, h) => u8(u, d, f, h, t.uploadImageHandler)
      },
      extensions: [
        o3,
        l3,
        c3,
        t8,
        d3.configure({
          types: ["heading", "paragraph"],
          alignments: ["left", "center", "right", "justify"]
        }),
        m3.configure({ multicolor: !0 }),
        b3.configure({
          types: ["textStyle"]
        }),
        wz.configure({
          resizable: !0
        }),
        Az,
        kz,
        Cz,
        Mz.configure({
          allowBase64: !0,
          inline: !0
        }),
        Jz.configure({
          openOnClick: !1
        }),
        c8
      ]
    });
    wa(() => {
      var u;
      (u = i.value) == null || u.destroy();
    });
    function s(u) {
      var h;
      const { rows: d, cols: f } = u;
      (h = i.value) == null || h.chain().focus().insertTable({ rows: Number(d), cols: Number(f), withHeaderRow: !0 }).run();
    }
    function o(u) {
      var d;
      (d = i.value) == null || d.commands.insertContent(u);
    }
    const l = w8(i);
    return En(l.fontSize, (u) => {
      var d;
      (d = i.value) == null || d.commands.setFontSize(String(u.model.value));
    }), En(l.textAlign, (u) => {
      var d;
      (d = i.value) == null || d.chain().focus().setTextAlign(u.model.value).run();
    }), En(l.highlight, (u) => {
      var d;
      (d = i.value) == null || d.chain().focus().toggleHighlight({ color: u.model.toLowerCase() }).run();
    }), En(l.color, (u) => {
      var d;
      (d = i.value) == null || d.commands.setColor(u.model.toLowerCase());
    }), (u, d) => (E(), F("div", D8, [
      O("div", C8, [
        (E(!0), F(ze, null, Je(Object.values(X(l)), (f, h) => (E(), F("div", { key: h }, [
          ce(_8, {
            label: f.tooltip
          }, {
            default: ee(() => [
              f.type === "TertiaryButton" ? (E(), ge(rn, {
                key: 0,
                "icon-position": "only",
                size: "sm",
                onClick: (m) => f.action()
              }, {
                icon: ee(() => [
                  O("i", {
                    class: de(`${f.icon}`)
                  }, null, 2)
                ]),
                _: 2
              }, 1032, ["onClick"])) : ne("", !0),
              f.type === "Dropdown" ? (E(), ge(X(n0), {
                key: 1,
                modelValue: f.model,
                "onUpdate:modelValue": (m) => f.model = m,
                items: f.items,
                placeholder: ""
              }, null, 8, ["modelValue", "onUpdate:modelValue", "items"])) : ne("", !0),
              f.type === "Colors" ? (E(), ge(a8, {
                key: 2,
                modelValue: f.model,
                "onUpdate:modelValue": (m) => f.model = m,
                icon: f.icon
              }, null, 8, ["modelValue", "onUpdate:modelValue", "icon"])) : ne("", !0),
              f.type === "table" ? (E(), ge(e8, {
                key: 3,
                modelValue: f.model,
                "onUpdate:modelValue": (m) => f.model = m,
                onInsert: s
              }, null, 8, ["modelValue", "onUpdate:modelValue"])) : ne("", !0),
              f.type === "SecondaryButton" ? (E(), ge(Zr, {
                key: 4,
                size: "sm",
                onClick: (m) => f.action()
              }, {
                default: ee(() => [
                  nn(re(f.label), 1)
                ]),
                _: 2
              }, 1032, ["onClick"])) : ne("", !0),
              f.type === "EmojiPicker" ? (E(), ge(g8, {
                key: 5,
                icon: f.icon,
                onSelect: o
              }, null, 8, ["icon"])) : ne("", !0)
            ]),
            _: 2
          }, 1032, ["label"])
        ]))), 128))
      ]),
      ce(X(sP), {
        class: "editor-content",
        editor: X(i),
        style: Tn({ direction: u.dir })
      }, null, 8, ["editor", "style"])
    ]));
  }
});
const k8 = {}, S8 = { class: "tooltip" }, A8 = { class: "label" };
function E8(n, e) {
  return E(), F("div", S8, [
    O("span", A8, [
      fe(n.$slots, "default", {}, void 0, !0)
    ])
  ]);
}
const T8 = /* @__PURE__ */ J(k8, [["render", E8], ["__scopeId", "data-v-2ed43544"]]), M8 = { class: "label" }, O8 = ["min", "max"], F8 = { class: "selected-rail" }, I8 = { class: "label" }, R8 = /* @__PURE__ */ K({
  __name: "Slider",
  props: {
    modelValue: { default: 0 },
    min: { default: 0 },
    max: { default: 100 },
    disabled: { type: Boolean, default: !1 },
    prefix: { default: "" },
    suffix: { default: "" }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    Zn((l) => ({
      "008a3ae4": i.value
    }));
    const t = n, r = e, i = G("0%"), s = ue({
      get: () => t.modelValue,
      set: (l) => {
        const { max: u, min: d, disabled: f } = t;
        if (f)
          return;
        const h = Math.abs(Math.abs(l) - Math.abs(d)) / Math.abs(Math.abs(u) - Math.abs(d)) * 100;
        i.value = `${h > 100 ? 100 : h}%`, r("update:modelValue", l);
      }
    }), o = ue(() => {
      const { prefix: l, suffix: u } = t;
      return `${l}${s.value}${u}`;
    });
    return bt(() => {
      const { max: l, min: u, modelValue: d } = t;
      s.value = d > l ? l : d < u ? u : d;
    }), (l, u) => (E(), F("div", {
      class: de(["slider-container", { disabled: l.disabled }])
    }, [
      O("span", M8, re(`${l.prefix}${l.min}${l.suffix}`), 1),
      O("div", {
        class: de(["slider", { disabled: l.disabled }])
      }, [
        yt(O("input", {
          "onUpdate:modelValue": u[0] || (u[0] = (d) => s.value = d),
          type: "range",
          min: l.min,
          max: l.max
        }, null, 8, O8), [
          [_a, s.value]
        ]),
        O("div", F8, [
          ce(T8, null, {
            default: ee(() => [
              nn(re(o.value), 1)
            ]),
            _: 1
          })
        ])
      ], 2),
      O("span", I8, re(`${l.prefix}${l.max}${l.suffix}`), 1)
    ], 2));
  }
});
const N8 = /* @__PURE__ */ J(R8, [["__scopeId", "data-v-3ab8fdcf"]]), B8 = { class: "overlay" }, $8 = { class: "body" }, L8 = /* @__PURE__ */ K({
  __name: "Overlay",
  emits: ["onBackdropClick"],
  setup(n, { emit: e }) {
    const t = e;
    return (r, i) => (E(), F("div", B8, [
      O("div", {
        class: "backdrop",
        onClick: i[0] || (i[0] = (s) => t("onBackdropClick"))
      }),
      O("div", $8, [
        fe(r.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
});
const Vb = /* @__PURE__ */ J(L8, [["__scopeId", "data-v-0d71e4ed"]]), P8 = (n) => (Ye("data-v-2774de43"), n = n(), Xe(), n), z8 = {
  key: 0,
  class: "modal"
}, V8 = { class: "header" }, H8 = /* @__PURE__ */ P8(() => /* @__PURE__ */ O("i", { class: "i-youcan-x" }, null, -1)), W8 = { class: "title" }, U8 = { class: "body" }, j8 = { class: "footer" }, q8 = /* @__PURE__ */ K({
  __name: "Modal",
  props: {
    title: { default: "Customer address" },
    visible: { type: Boolean },
    confirmLabel: { default: "Save" },
    confirmIcon: {},
    cancelLabel: { default: "Cancel" },
    cancelOnly: { type: Boolean }
  },
  emits: ["update:visible", "onConfirm"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = () => {
      r("update:visible", !1);
    }, s = (o) => {
      t.visible && o.key === "Escape" && i();
    };
    return bt(() => {
      window.addEventListener("keydown", s);
    }), po(() => {
      window.removeEventListener("keydown", s);
    }), (o, l) => (E(), ge(eo, { name: "fade" }, {
      default: ee(() => [
        yt(ce(Vb, { onOnBackdropClick: i }, {
          default: ee(() => [
            ce(eo, { name: "slide-up" }, {
              default: ee(() => [
                o.visible ? (E(), F("div", z8, [
                  O("div", V8, [
                    ce(X(rn), { onClick: i }, {
                      default: ee(() => [
                        H8
                      ]),
                      _: 1
                    }),
                    O("span", W8, re(o.title), 1)
                  ]),
                  O("div", U8, [
                    fe(o.$slots, "default", {}, void 0, !0)
                  ]),
                  O("div", j8, [
                    o.cancelOnly ? ne("", !0) : (E(), ge(X(Ca), {
                      key: 0,
                      onClick: l[0] || (l[0] = (u) => r("onConfirm"))
                    }, Fr({
                      default: ee(() => [
                        O("span", null, re(o.confirmLabel), 1)
                      ]),
                      _: 2
                    }, [
                      o.confirmIcon ? {
                        name: "icon",
                        fn: ee(() => [
                          O("i", {
                            class: de(o.confirmIcon)
                          }, null, 2)
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1024)),
                    ce(X(Zr), { onClick: i }, {
                      default: ee(() => [
                        O("span", null, re(o.cancelLabel), 1)
                      ]),
                      _: 1
                    })
                  ])
                ])) : ne("", !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 512), [
          [Kn, o.visible]
        ])
      ]),
      _: 3
    }));
  }
});
const K8 = /* @__PURE__ */ J(q8, [["__scopeId", "data-v-2774de43"]]), G8 = { class: "content" }, J8 = { class: "info" }, Y8 = { class: "name" }, X8 = { class: "inventory-price" }, Z8 = {
  key: 0,
  class: "stock"
}, Q8 = {
  key: 1,
  class: "price"
}, e5 = /* @__PURE__ */ K({
  __name: "Resource",
  props: {
    resource: {},
    isChecked: { type: Boolean },
    showStock: { type: Boolean, default: !1 },
    showThumbnail: { type: Boolean, default: !0 },
    stockLabel: { default: "Stock" },
    modelValue: { type: Boolean },
    indeterminate: { type: Boolean }
  },
  emits: ["change", "update:model-value"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ue({
      get: () => t.modelValue,
      set: (o) => r("update:model-value", o)
    });
    function s(o) {
      r("change", o, t.resource);
    }
    return (o, l) => (E(), ge(X(ho), {
      modelValue: i.value,
      "onUpdate:modelValue": l[0] || (l[0] = (u) => i.value = u),
      class: de(["container", !o.showThumbnail && "variant"]),
      indeterminate: o.indeterminate,
      onChange: ki(s, ["stop"])
    }, {
      label: ee(() => [
        O("div", G8, [
          O("div", J8, [
            o.showThumbnail ? (E(), ge(X(mo), {
              key: 0,
              src: o.resource.thumbnailUrl
            }, null, 8, ["src"])) : ne("", !0),
            O("p", Y8, re(o.resource.name), 1)
          ]),
          O("div", X8, [
            o.showStock && o.resource.stock ? (E(), F("span", Z8, re(o.resource.stock) + " " + re(o.stockLabel), 1)) : ne("", !0),
            o.resource.price ? (E(), F("p", Q8, re(o.resource.price), 1)) : ne("", !0)
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "class", "indeterminate"]));
  }
});
const Jv = /* @__PURE__ */ J(e5, [["__scopeId", "data-v-956a7203"]]), Md = (n) => n === void 0 || (n == null ? void 0 : n.length) <= 0, t5 = (n) => (Ye("data-v-f842b859"), n = n(), Xe(), n), n5 = { class: "picker" }, r5 = { class: "header" }, i5 = /* @__PURE__ */ t5(() => /* @__PURE__ */ O("i", { class: "i-youcan-x" }, null, -1)), s5 = { class: "search" }, o5 = {
  key: 0,
  class: "loading"
}, a5 = {
  key: 1,
  class: "list"
}, l5 = { key: 0 }, u5 = {
  key: 2,
  class: "empty-state"
}, c5 = { class: "footer" }, d5 = { class: "selection" }, f5 = { class: "actions" }, p5 = /* @__PURE__ */ K({
  __name: "ResourcePicker",
  props: {
    visible: { type: Boolean, default: !1 },
    title: { default: "Choose resource" },
    resources: {},
    selectionLabel: { default: "resources selected" },
    stockLabel: {},
    confirmLabel: { default: "Add" },
    cancelLabel: { default: "Cancel" },
    isLoading: { type: Boolean, default: !0 },
    emptyStateLabel: { default: "No resources available" },
    searchPlaceholder: { default: "Search" }
  },
  emits: ["update:visible", "confirm", "search"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(""), s = ue(() => {
      var g;
      return (g = t.resources) == null ? void 0 : g.filter((y) => y.isChecked || y.isIndeterminate);
    }), o = ue(() => t.isLoading || Md(t.resources) || Md(s.value)), l = () => {
      i.value = "", r("update:visible", !1);
    }, u = () => {
      var g;
      i.value = "";
      const m = (g = s.value) == null ? void 0 : g.map((y) => y.variants ? {
        ...y,
        variants: y.variants.filter((b) => b.isChecked).map((b) => Fd(b))
      } : Fd(y));
      r("confirm", m);
    }, d = (m, g, y) => {
      var b, w, T;
      if (y) {
        const k = (b = y == null ? void 0 : y.variants) == null ? void 0 : b.every((S) => S.isChecked);
        if (k)
          y.isChecked = k, y.isIndeterminate = !1;
        else {
          const S = (w = y == null ? void 0 : y.variants) == null ? void 0 : w.some((C) => C.isChecked);
          y.isChecked = S, y.isIndeterminate = S;
        }
        return;
      }
      g.variants && (g.isIndeterminate = !1, (T = t.resources) == null || T.forEach((k) => {
        var S;
        k.id === g.id && (k.isChecked = g.isChecked, (S = k.variants) == null || S.forEach((C) => {
          C.isChecked = g.isChecked;
        }));
      }));
    }, f = (m) => {
      const { target: g } = m, y = g.value;
      r("search", y);
    }, h = (m) => {
      t.visible && m.key === "Escape" && l();
    };
    return bt(() => {
      window.addEventListener("keydown", h);
    }), po(() => {
      window.removeEventListener("keydown", h);
    }), (m, g) => (E(), ge(eo, { name: "fade" }, {
      default: ee(() => [
        yt(ce(Vb, null, {
          default: ee(() => {
            var y;
            return [
              O("div", n5, [
                O("div", r5, [
                  O("span", null, re(m.title), 1),
                  ce(X(rn), { onClick: l }, {
                    default: ee(() => [
                      i5
                    ]),
                    _: 1
                  })
                ]),
                O("div", s5, [
                  ce(X(ss), {
                    modelValue: i.value,
                    "onUpdate:modelValue": g[0] || (g[0] = (b) => i.value = b),
                    modelModifiers: { trim: !0 },
                    placeholder: m.searchPlaceholder,
                    onInput: ki(f, ["stop"]),
                    onKeyup: CS(ki(f, ["stop"]), ["enter"])
                  }, null, 8, ["modelValue", "placeholder", "onKeyup"])
                ]),
                m.isLoading ? (E(), F("div", o5, [
                  ce(X(cp), { label: "" })
                ])) : X(Md)(m.resources) ? (E(), F("span", u5, re(m.emptyStateLabel), 1)) : (E(), F("ul", a5, [
                  (E(!0), F(ze, null, Je(m.resources, (b) => (E(), F("li", {
                    key: b.id,
                    class: "resource"
                  }, [
                    ce(Jv, {
                      modelValue: b.isChecked,
                      "onUpdate:modelValue": (w) => b.isChecked = w,
                      resource: b,
                      "thumbnail-url": b.thumbnailUrl,
                      "show-stock": "",
                      "stock-label": m.stockLabel,
                      indeterminate: b.isIndeterminate,
                      onChange: d
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "resource", "thumbnail-url", "stock-label", "indeterminate"]),
                    b.variants ? (E(), F("ul", l5, [
                      (E(!0), F(ze, null, Je(b.variants, (w, T) => (E(), F("li", {
                        key: w.id
                      }, [
                        ce(Jv, {
                          modelValue: b.variants[T].isChecked,
                          "onUpdate:modelValue": (k) => b.variants[T].isChecked = k,
                          resource: w,
                          "thumbnail-url": w.thumbnailUrl,
                          "show-stock": "",
                          "stock-label": m.stockLabel,
                          "show-thumbnail": !1,
                          onChange: (k) => d(k, w, b)
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "resource", "thumbnail-url", "stock-label", "onChange"])
                      ]))), 128))
                    ])) : ne("", !0)
                  ]))), 128))
                ])),
                O("div", c5, [
                  O("span", d5, re((y = s.value) == null ? void 0 : y.length) + " " + re(m.selectionLabel), 1),
                  O("div", f5, [
                    ce(X(Zr), { onClick: l }, {
                      default: ee(() => [
                        O("span", null, re(m.cancelLabel), 1)
                      ]),
                      _: 1
                    }),
                    ce(X(Ca), {
                      disabled: o.value,
                      onClick: u
                    }, {
                      default: ee(() => [
                        O("span", null, re(m.confirmLabel), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled"])
                  ])
                ])
              ])
            ];
          }),
          _: 1
        }, 512), [
          [Kn, m.visible]
        ])
      ]),
      _: 1
    }));
  }
});
const h5 = /* @__PURE__ */ J(p5, [["__scopeId", "data-v-f842b859"]]), m5 = { class: "content" }, g5 = {
  key: 0,
  class: "image"
}, v5 = ["src"], y5 = {
  key: 1,
  class: "title"
}, b5 = {
  key: 2,
  class: "description"
}, _5 = {
  key: 0,
  class: "footer"
}, w5 = /* @__PURE__ */ K({
  __name: "Popover",
  props: {
    position: { default: "left" },
    show: { type: Boolean },
    imgSrc: {},
    objectFit: { default: "cover" }
  },
  emits: ["update:show"],
  setup(n, { emit: e }) {
    Zn((g) => ({
      "33aac05a": l.value,
      "41b4dd6e": u.value,
      "0011bc50": g.objectFit
    }));
    const t = n, r = e, i = G(), s = G(), o = G(), l = G("0px"), u = G("0px"), d = G(""), f = Kt(), h = () => {
      if (o.value && s.value) {
        const g = R0(o.value, s.value, t.position, 22);
        l.value = `${g.top}px`, u.value = `${g.left}px`, d.value = g.currentPosition;
      }
    };
    mr(i, () => {
      r("update:show", !1);
    });
    const m = () => {
      r("update:show", !1);
    };
    return bt(() => {
      window.addEventListener("scroll", m), window.addEventListener("resize", h);
    }), po(() => {
      window.removeEventListener("scroll", m), window.removeEventListener("resize", h);
    }), (g, y) => (E(), F("div", {
      ref_key: "popover",
      ref: i,
      class: "popover"
    }, [
      ce(eo, { name: "fade" }, {
        default: ee(() => [
          g.show ? (E(), F("div", {
            key: 0,
            ref_key: "popoverTrigger",
            ref: o,
            class: de(["popover-trigger", [d.value, { "has-footer": X(f).footer }]])
          }, [
            O("div", m5, [
              g.imgSrc ? (E(), F("div", g5, [
                O("img", { src: g.imgSrc }, null, 8, v5)
              ])) : ne("", !0),
              X(f).title ? (E(), F("div", y5, [
                fe(g.$slots, "title", {}, void 0, !0)
              ])) : ne("", !0),
              X(f).description ? (E(), F("div", b5, [
                fe(g.$slots, "description", {}, void 0, !0)
              ])) : ne("", !0)
            ]),
            X(f).footer ? (E(), F("div", _5, [
              fe(g.$slots, "footer", {}, void 0, !0)
            ])) : ne("", !0)
          ], 2)) : ne("", !0)
        ]),
        _: 3
      }),
      O("div", {
        ref_key: "element",
        ref: s,
        onClick: y[0] || (y[0] = (b) => {
          h();
        })
      }, [
        fe(g.$slots, "default", {}, void 0, !0)
      ], 512)
    ], 512));
  }
});
const D5 = /* @__PURE__ */ J(w5, [["__scopeId", "data-v-df44724c"]]);
var mf = {}, C5 = {
  get exports() {
    return mf;
  },
  set exports(n) {
    mf = n;
  }
};
(function(n) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var t = function(r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, o = {}, l = {
      manual: r.Prism && r.Prism.manual,
      disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
      util: {
        encode: function k(S) {
          return S instanceof u ? new u(S.type, k(S.content), S.alias) : Array.isArray(S) ? S.map(k) : S.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        type: function(k) {
          return Object.prototype.toString.call(k).slice(8, -1);
        },
        objId: function(k) {
          return k.__id || Object.defineProperty(k, "__id", { value: ++s }), k.__id;
        },
        clone: function k(S, C) {
          C = C || {};
          var R, I;
          switch (l.util.type(S)) {
            case "Object":
              if (I = l.util.objId(S), C[I])
                return C[I];
              R = {}, C[I] = R;
              for (var P in S)
                S.hasOwnProperty(P) && (R[P] = k(S[P], C));
              return R;
            case "Array":
              return I = l.util.objId(S), C[I] ? C[I] : (R = [], C[I] = R, S.forEach(function(L, q) {
                R[q] = k(L, C);
              }), R);
            default:
              return S;
          }
        },
        getLanguage: function(k) {
          for (; k; ) {
            var S = i.exec(k.className);
            if (S)
              return S[1].toLowerCase();
            k = k.parentElement;
          }
          return "none";
        },
        setLanguage: function(k, S) {
          k.className = k.className.replace(RegExp(i, "gi"), ""), k.classList.add("language-" + S);
        },
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document && 1 < 2)
            return document.currentScript;
          try {
            throw new Error();
          } catch (R) {
            var k = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(R.stack) || [])[1];
            if (k) {
              var S = document.getElementsByTagName("script");
              for (var C in S)
                if (S[C].src == k)
                  return S[C];
            }
            return null;
          }
        },
        isActive: function(k, S, C) {
          for (var R = "no-" + S; k; ) {
            var I = k.classList;
            if (I.contains(S))
              return !0;
            if (I.contains(R))
              return !1;
            k = k.parentElement;
          }
          return !!C;
        }
      },
      languages: {
        plain: o,
        plaintext: o,
        text: o,
        txt: o,
        extend: function(k, S) {
          var C = l.util.clone(l.languages[k]);
          for (var R in S)
            C[R] = S[R];
          return C;
        },
        insertBefore: function(k, S, C, R) {
          R = R || l.languages;
          var I = R[k], P = {};
          for (var L in I)
            if (I.hasOwnProperty(L)) {
              if (L == S)
                for (var q in C)
                  C.hasOwnProperty(q) && (P[q] = C[q]);
              C.hasOwnProperty(L) || (P[L] = I[L]);
            }
          var oe = R[k];
          return R[k] = P, l.languages.DFS(l.languages, function(ae, ke) {
            ke === oe && ae != k && (this[ae] = P);
          }), P;
        },
        DFS: function k(S, C, R, I) {
          I = I || {};
          var P = l.util.objId;
          for (var L in S)
            if (S.hasOwnProperty(L)) {
              C.call(S, L, S[L], R || L);
              var q = S[L], oe = l.util.type(q);
              oe === "Object" && !I[P(q)] ? (I[P(q)] = !0, k(q, C, null, I)) : oe === "Array" && !I[P(q)] && (I[P(q)] = !0, k(q, C, L, I));
            }
        }
      },
      plugins: {},
      highlightAll: function(k, S) {
        l.highlightAllUnder(document, k, S);
      },
      highlightAllUnder: function(k, S, C) {
        var R = {
          callback: C,
          container: k,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        l.hooks.run("before-highlightall", R), R.elements = Array.prototype.slice.apply(R.container.querySelectorAll(R.selector)), l.hooks.run("before-all-elements-highlight", R);
        for (var I = 0, P; P = R.elements[I++]; )
          l.highlightElement(P, S === !0, R.callback);
      },
      highlightElement: function(k, S, C) {
        var R = l.util.getLanguage(k), I = l.languages[R];
        l.util.setLanguage(k, R);
        var P = k.parentElement;
        P && P.nodeName.toLowerCase() === "pre" && l.util.setLanguage(P, R);
        var L = k.textContent, q = {
          element: k,
          language: R,
          grammar: I,
          code: L
        };
        function oe(ke) {
          q.highlightedCode = ke, l.hooks.run("before-insert", q), q.element.innerHTML = q.highlightedCode, l.hooks.run("after-highlight", q), l.hooks.run("complete", q), C && C.call(q.element);
        }
        if (l.hooks.run("before-sanity-check", q), P = q.element.parentElement, P && P.nodeName.toLowerCase() === "pre" && !P.hasAttribute("tabindex") && P.setAttribute("tabindex", "0"), !q.code) {
          l.hooks.run("complete", q), C && C.call(q.element);
          return;
        }
        if (l.hooks.run("before-highlight", q), !q.grammar) {
          oe(l.util.encode(q.code));
          return;
        }
        if (S && r.Worker) {
          var ae = new Worker(l.filename);
          ae.onmessage = function(ke) {
            oe(ke.data);
          }, ae.postMessage(JSON.stringify({
            language: q.language,
            code: q.code,
            immediateClose: !0
          }));
        } else
          oe(l.highlight(q.code, q.grammar, q.language));
      },
      highlight: function(k, S, C) {
        var R = {
          code: k,
          grammar: S,
          language: C
        };
        if (l.hooks.run("before-tokenize", R), !R.grammar)
          throw new Error('The language "' + R.language + '" has no grammar.');
        return R.tokens = l.tokenize(R.code, R.grammar), l.hooks.run("after-tokenize", R), u.stringify(l.util.encode(R.tokens), R.language);
      },
      tokenize: function(k, S) {
        var C = S.rest;
        if (C) {
          for (var R in C)
            S[R] = C[R];
          delete S.rest;
        }
        var I = new h();
        return m(I, I.head, k), f(k, I, S, I.head, 0), y(I);
      },
      hooks: {
        all: {},
        add: function(k, S) {
          var C = l.hooks.all;
          C[k] = C[k] || [], C[k].push(S);
        },
        run: function(k, S) {
          var C = l.hooks.all[k];
          if (!(!C || !C.length))
            for (var R = 0, I; I = C[R++]; )
              I(S);
        }
      },
      Token: u
    };
    r.Prism = l;
    function u(k, S, C, R) {
      this.type = k, this.content = S, this.alias = C, this.length = (R || "").length | 0;
    }
    u.stringify = function k(S, C) {
      if (typeof S == "string")
        return S;
      if (Array.isArray(S)) {
        var R = "";
        return S.forEach(function(oe) {
          R += k(oe, C);
        }), R;
      }
      var I = {
        type: S.type,
        content: k(S.content, C),
        tag: "span",
        classes: ["token", S.type],
        attributes: {},
        language: C
      }, P = S.alias;
      P && (Array.isArray(P) ? Array.prototype.push.apply(I.classes, P) : I.classes.push(P)), l.hooks.run("wrap", I);
      var L = "";
      for (var q in I.attributes)
        L += " " + q + '="' + (I.attributes[q] || "").replace(/"/g, "&quot;") + '"';
      return "<" + I.tag + ' class="' + I.classes.join(" ") + '"' + L + ">" + I.content + "</" + I.tag + ">";
    };
    function d(k, S, C, R) {
      k.lastIndex = S;
      var I = k.exec(C);
      if (I && R && I[1]) {
        var P = I[1].length;
        I.index += P, I[0] = I[0].slice(P);
      }
      return I;
    }
    function f(k, S, C, R, I, P) {
      for (var L in C)
        if (!(!C.hasOwnProperty(L) || !C[L])) {
          var q = C[L];
          q = Array.isArray(q) ? q : [q];
          for (var oe = 0; oe < q.length; ++oe) {
            if (P && P.cause == L + "," + oe)
              return;
            var ae = q[oe], ke = ae.inside, Ee = !!ae.lookbehind, rt = !!ae.greedy, Qe = ae.alias;
            if (rt && !ae.pattern.global) {
              var Ke = ae.pattern.toString().match(/[imsuy]*$/)[0];
              ae.pattern = RegExp(ae.pattern.source, Ke + "g");
            }
            for (var He = ae.pattern || ae, De = R.next, Te = I; De !== S.tail && !(P && Te >= P.reach); Te += De.value.length, De = De.next) {
              var Oe = De.value;
              if (S.length > k.length)
                return;
              if (!(Oe instanceof u)) {
                var je = 1, it;
                if (rt) {
                  if (it = d(He, Te, k, Ee), !it || it.index >= k.length)
                    break;
                  var _t = it.index, Qn = it.index + it[0].length, gt = Te;
                  for (gt += De.value.length; _t >= gt; )
                    De = De.next, gt += De.value.length;
                  if (gt -= De.value.length, Te = gt, De.value instanceof u)
                    continue;
                  for (var st = De; st !== S.tail && (gt < Qn || typeof st.value == "string"); st = st.next)
                    je++, gt += st.value.length;
                  je--, Oe = k.slice(Te, gt), it.index -= Te;
                } else if (it = d(He, 0, Oe, Ee), !it)
                  continue;
                var _t = it.index, bn = it[0], wt = Oe.slice(0, _t), Jt = Oe.slice(_t + bn.length), ln = Te + Oe.length;
                P && ln > P.reach && (P.reach = ln);
                var Lt = De.prev;
                wt && (Lt = m(S, Lt, wt), Te += wt.length), g(S, Lt, je);
                var er = new u(L, ke ? l.tokenize(bn, ke) : bn, Qe, bn);
                if (De = m(S, Lt, er), Jt && m(S, De, Jt), je > 1) {
                  var In = {
                    cause: L + "," + oe,
                    reach: ln
                  };
                  f(k, S, C, De.prev, Te, In), P && In.reach > P.reach && (P.reach = In.reach);
                }
              }
            }
          }
        }
    }
    function h() {
      var k = { value: null, prev: null, next: null }, S = { value: null, prev: k, next: null };
      k.next = S, this.head = k, this.tail = S, this.length = 0;
    }
    function m(k, S, C) {
      var R = S.next, I = { value: C, prev: S, next: R };
      return S.next = I, R.prev = I, k.length++, I;
    }
    function g(k, S, C) {
      for (var R = S.next, I = 0; I < C && R !== k.tail; I++)
        R = R.next;
      S.next = R, R.prev = S, k.length -= I;
    }
    function y(k) {
      for (var S = [], C = k.head.next; C !== k.tail; )
        S.push(C.value), C = C.next;
      return S;
    }
    if (!r.document)
      return r.addEventListener && (l.disableWorkerMessageHandler || r.addEventListener("message", function(k) {
        var S = JSON.parse(k.data), C = S.language, R = S.code, I = S.immediateClose;
        r.postMessage(l.highlight(R, l.languages[C], C)), I && r.close();
      }, !1)), l;
    var b = l.util.currentScript();
    b && (l.filename = b.src, b.hasAttribute("data-manual") && (l.manual = !0));
    function w() {
      l.manual || l.highlightAll();
    }
    if (!l.manual) {
      var T = document.readyState;
      T === "loading" || T === "interactive" && b && b.defer ? document.addEventListener("DOMContentLoaded", w) : window.requestAnimationFrame ? window.requestAnimationFrame(w) : window.setTimeout(w, 16);
    }
    return l;
  }(e);
  n.exports && (n.exports = t), typeof Xi < "u" && (Xi.Prism = t), t.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity, t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup, t.hooks.add("wrap", function(r) {
    r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(t.languages.markup.tag, "addInlined", {
    value: function(i, s) {
      var o = {};
      o["language-" + s] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: t.languages[s]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var l = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      l["language-" + s] = {
        pattern: /[\s\S]+/,
        inside: t.languages[s]
      };
      var u = {};
      u[i] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return i;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: l
      }, t.languages.insertBefore("markup", "cdata", u);
    }
  }), Object.defineProperty(t.languages.markup.tag, "addAttribute", {
    value: function(r, i) {
      t.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [i, "language-" + i],
                inside: t.languages[i]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), t.languages.html = t.languages.markup, t.languages.mathml = t.languages.markup, t.languages.svg = t.languages.markup, t.languages.xml = t.languages.extend("markup", {}), t.languages.ssml = t.languages.xml, t.languages.atom = t.languages.xml, t.languages.rss = t.languages.xml, function(r) {
    var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    r.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
        }
      },
      url: {
        pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + i.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: i,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, r.languages.css.atrule.inside.rest = r.languages.css;
    var s = r.languages.markup;
    s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
  }(t), t.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, t.languages.javascript = t.languages.extend("clike", {
    "class-name": [
      t.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), t.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, t.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: t.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: t.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: t.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: t.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: t.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), t.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: t.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), t.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"), t.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), t.languages.js = t.languages.javascript, function() {
    if (typeof t > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var r = "Loading", i = function(b, w) {
      return " Error " + b + " while fetching file: " + w;
    }, s = " Error: File does not exist or is empty", o = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, l = "data-src-status", u = "loading", d = "loaded", f = "failed", h = "pre[data-src]:not([" + l + '="' + d + '"]):not([' + l + '="' + u + '"])';
    function m(b, w, T) {
      var k = new XMLHttpRequest();
      k.open("GET", b, !0), k.onreadystatechange = function() {
        k.readyState == 4 && (k.status < 400 && k.responseText ? w(k.responseText) : k.status >= 400 ? T(i(k.status, k.statusText)) : T(s));
      }, k.send(null);
    }
    function g(b) {
      var w = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(b || "");
      if (w) {
        var T = Number(w[1]), k = w[2], S = w[3];
        return k ? S ? [T, Number(S)] : [T, void 0] : [T, T];
      }
    }
    t.hooks.add("before-highlightall", function(b) {
      b.selector += ", " + h;
    }), t.hooks.add("before-sanity-check", function(b) {
      var w = b.element;
      if (w.matches(h)) {
        b.code = "", w.setAttribute(l, u);
        var T = w.appendChild(document.createElement("CODE"));
        T.textContent = r;
        var k = w.getAttribute("data-src"), S = b.language;
        if (S === "none") {
          var C = (/\.(\w+)$/.exec(k) || [, "none"])[1];
          S = o[C] || C;
        }
        t.util.setLanguage(T, S), t.util.setLanguage(w, S);
        var R = t.plugins.autoloader;
        R && R.loadLanguages(S), m(
          k,
          function(I) {
            w.setAttribute(l, d);
            var P = g(w.getAttribute("data-range"));
            if (P) {
              var L = I.split(/\r\n?|\n/g), q = P[0], oe = P[1] == null ? L.length : P[1];
              q < 0 && (q += L.length), q = Math.max(0, Math.min(q - 1, L.length)), oe < 0 && (oe += L.length), oe = Math.max(0, Math.min(oe, L.length)), I = L.slice(q, oe).join(`
`), w.hasAttribute("data-start") || w.setAttribute("data-start", String(q + 1));
            }
            T.textContent = I, t.highlightElement(T);
          },
          function(I) {
            w.setAttribute(l, f), T.textContent = I;
          }
        );
      }
    }), t.plugins.fileHighlight = {
      highlight: function(w) {
        for (var T = (w || document).querySelectorAll(h), k = 0, S; S = T[k++]; )
          t.highlightElement(S);
      }
    };
    var y = !1;
    t.fileHighlight = function() {
      y || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), y = !0), t.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(C5);
const x5 = mf;
(function(n) {
  n.languages.typescript = n.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  }), n.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    /\btype\b(?=\s*(?:[\{*]|$))/
  ), delete n.languages.typescript.parameter, delete n.languages.typescript["literal-property"];
  var e = n.languages.extend("typescript", {});
  delete e["class-name"], n.languages.typescript["class-name"].inside = e, n.languages.insertBefore("typescript", "function", {
    decorator: {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        at: {
          pattern: /^@/,
          alias: "operator"
        },
        function: /^[\s\S]+/
      }
    },
    "generic-function": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: !0,
      inside: {
        function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        generic: {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: e
        }
      }
    }
  }), n.languages.ts = n.languages.typescript;
})(Prism);
Prism.languages.git = {
  comment: /^#.*/m,
  deleted: /^[-].*/m,
  inserted: /^\+.*/m,
  string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  command: {
    pattern: /^.*\$ git .*$/m,
    inside: {
      parameter: /\s--?\w+/
    }
  },
  coord: /^@@.*@@$/m,
  "commit-sha1": /^commit \w{40}$/m
};
Prism.languages.scss = Prism.languages.extend("css", {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: !0
  },
  atrule: {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      rule: /@[\w-]+/
    }
  },
  url: /(?:[-a-z]+-)?url(?=\()/i,
  selector: {
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      parent: {
        pattern: /&/,
        alias: "important"
      },
      placeholder: /%[-\w]+/,
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  property: {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  keyword: [
    /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
    {
      pattern: /( )(?:from|through)(?= )/,
      lookbehind: !0
    }
  ]
});
Prism.languages.insertBefore("scss", "important", {
  variable: /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  placeholder: {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  statement: {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  boolean: /\b(?:false|true)\b/,
  null: {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  operator: {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: !0
  }
});
Prism.languages.scss.atrule.inside.rest = Prism.languages.scss;
(function(n) {
  var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function t(f) {
    return f = f.replace(/<inner>/g, function() {
      return e;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + f + ")");
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return r;
  }), s = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  n.languages.markdown = n.languages.extend("markup", {}), n.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        punctuation: /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: n.languages.yaml
        }
      }
    },
    blockquote: {
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    table: {
      pattern: RegExp("^" + i + s + "(?:" + i + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + i + s + ")(?:" + i + ")*$"),
          lookbehind: !0,
          inside: {
            "table-data": {
              pattern: RegExp(r),
              inside: n.languages.markdown
            },
            punctuation: /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + i + ")" + s + "$"),
          lookbehind: !0,
          inside: {
            punctuation: /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + i + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(r),
              alias: "important",
              inside: n.languages.markdown
            },
            punctuation: /\|/
          }
        }
      }
    },
    code: [
      {
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: !0,
        alias: "keyword"
      },
      {
        pattern: /^```[\s\S]*?^```$/m,
        greedy: !0,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: !0
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: !0
          },
          punctuation: /```/
        }
      }
    ],
    title: [
      {
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        pattern: /(^\s*)#.+/m,
        lookbehind: !0,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    hr: {
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    list: {
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    "url-reference": {
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        variable: {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: !0
        },
        string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        punctuation: /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    bold: {
      pattern: t(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: !0,
          inside: {}
        },
        punctuation: /\*\*|__/
      }
    },
    italic: {
      pattern: t(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: !0,
          inside: {}
        },
        punctuation: /[*_]/
      }
    },
    strike: {
      pattern: t(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: !0,
          inside: {}
        },
        punctuation: /~~?/
      }
    },
    "code-snippet": {
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: !0,
      greedy: !0,
      alias: ["code", "keyword"]
    },
    url: {
      pattern: t(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        operator: /^!/,
        content: {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: !0,
          inside: {}
        },
        variable: {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: !0
        },
        url: {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: !0
        },
        string: {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: !0
        }
      }
    }
  }), ["url", "bold", "italic", "strike"].forEach(function(f) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(h) {
      f !== h && (n.languages.markdown[f].inside.content.inside[h] = n.languages.markdown[h]);
    });
  }), n.hooks.add("after-tokenize", function(f) {
    if (f.language !== "markdown" && f.language !== "md")
      return;
    function h(m) {
      if (!(!m || typeof m == "string"))
        for (var g = 0, y = m.length; g < y; g++) {
          var b = m[g];
          if (b.type !== "code") {
            h(b.content);
            continue;
          }
          var w = b.content[1], T = b.content[3];
          if (w && T && w.type === "code-language" && T.type === "code-block" && typeof w.content == "string") {
            var k = w.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
            k = (/[a-z][\w-]*/i.exec(k) || [""])[0].toLowerCase();
            var S = "language-" + k;
            T.alias ? typeof T.alias == "string" ? T.alias = [T.alias, S] : T.alias.push(S) : T.alias = [S];
          }
        }
    }
    h(f.tokens);
  }), n.hooks.add("wrap", function(f) {
    if (f.type === "code-block") {
      for (var h = "", m = 0, g = f.classes.length; m < g; m++) {
        var y = f.classes[m], b = /language-(.+)/.exec(y);
        if (b) {
          h = b[1];
          break;
        }
      }
      var w = n.languages[h];
      if (w)
        f.content = n.highlight(d(f.content), w, h);
      else if (h && h !== "none" && n.plugins.autoloader) {
        var T = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
        f.attributes.id = T, n.plugins.autoloader.loadLanguages(h, function() {
          var k = document.getElementById(T);
          k && (k.innerHTML = n.highlight(k.textContent, n.languages[h], h));
        });
      }
    }
  });
  var o = RegExp(n.languages.markup.tag.pattern.source, "gi"), l = {
    amp: "&",
    lt: "<",
    gt: ">",
    quot: '"'
  }, u = String.fromCodePoint || String.fromCharCode;
  function d(f) {
    var h = f.replace(o, "");
    return h = h.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, g) {
      if (g = g.toLowerCase(), g[0] === "#") {
        var y;
        return g[1] === "x" ? y = parseInt(g.slice(2), 16) : y = Number(g.slice(1)), u(y);
      } else {
        var b = l[g];
        return b || m;
      }
    }), h;
  }
  n.languages.md = n.languages.markdown;
})(Prism);
(function() {
  if (typeof Prism > "u" || typeof document > "u")
    return;
  var n = "line-numbers", e = /\n(?!$)/g, t = Prism.plugins.lineNumbers = {
    getLine: function(o, l) {
      if (!(o.tagName !== "PRE" || !o.classList.contains(n))) {
        var u = o.querySelector(".line-numbers-rows");
        if (u) {
          var d = parseInt(o.getAttribute("data-start"), 10) || 1, f = d + (u.children.length - 1);
          l < d && (l = d), l > f && (l = f);
          var h = l - d;
          return u.children[h];
        }
      }
    },
    resize: function(o) {
      r([o]);
    },
    assumeViewportIndependence: !0
  };
  function r(o) {
    if (o = o.filter(function(u) {
      var d = i(u), f = d["white-space"];
      return f === "pre-wrap" || f === "pre-line";
    }), o.length != 0) {
      var l = o.map(function(u) {
        var d = u.querySelector("code"), f = u.querySelector(".line-numbers-rows");
        if (!(!d || !f)) {
          var h = u.querySelector(".line-numbers-sizer"), m = d.textContent.split(e);
          h || (h = document.createElement("span"), h.className = "line-numbers-sizer", d.appendChild(h)), h.innerHTML = "0", h.style.display = "block";
          var g = h.getBoundingClientRect().height;
          return h.innerHTML = "", {
            element: u,
            lines: m,
            lineHeights: [],
            oneLinerHeight: g,
            sizer: h
          };
        }
      }).filter(Boolean);
      l.forEach(function(u) {
        var d = u.sizer, f = u.lines, h = u.lineHeights, m = u.oneLinerHeight;
        h[f.length - 1] = void 0, f.forEach(function(g, y) {
          if (g && g.length > 1) {
            var b = d.appendChild(document.createElement("span"));
            b.style.display = "block", b.textContent = g;
          } else
            h[y] = m;
        });
      }), l.forEach(function(u) {
        for (var d = u.sizer, f = u.lineHeights, h = 0, m = 0; m < f.length; m++)
          f[m] === void 0 && (f[m] = d.children[h++].getBoundingClientRect().height);
      }), l.forEach(function(u) {
        var d = u.sizer, f = u.element.querySelector(".line-numbers-rows");
        d.style.display = "none", d.innerHTML = "", u.lineHeights.forEach(function(h, m) {
          f.children[m].style.height = h + "px";
        });
      });
    }
  }
  function i(o) {
    return o ? window.getComputedStyle ? getComputedStyle(o) : o.currentStyle || null : null;
  }
  var s = void 0;
  window.addEventListener("resize", function() {
    t.assumeViewportIndependence && s === window.innerWidth || (s = window.innerWidth, r(Array.prototype.slice.call(document.querySelectorAll("pre." + n))));
  }), Prism.hooks.add("complete", function(o) {
    if (o.code) {
      var l = o.element, u = l.parentNode;
      if (!(!u || !/pre/i.test(u.nodeName)) && !l.querySelector(".line-numbers-rows") && Prism.util.isActive(l, n)) {
        l.classList.remove(n), u.classList.add(n);
        var d = o.code.match(e), f = d ? d.length + 1 : 1, h, m = new Array(f + 1).join("<span></span>");
        h = document.createElement("span"), h.setAttribute("aria-hidden", "true"), h.className = "line-numbers-rows", h.innerHTML = m, u.hasAttribute("data-start") && (u.style.counterReset = "linenumber " + (parseInt(u.getAttribute("data-start"), 10) - 1)), o.element.appendChild(h), r([u]), Prism.hooks.run("line-numbers", o);
      }
    }
  }), Prism.hooks.add("line-numbers", function(o) {
    o.plugins = o.plugins || {}, o.plugins.lineNumbers = !0;
  });
})();
const k5 = /* @__PURE__ */ K({
  __name: "Code",
  props: {
    code: { default: "const data = 1;" },
    language: { default: "js" },
    showLineNumbers: { type: Boolean, default: !0 }
  },
  setup(n) {
    const e = n, t = G();
    return bt(() => {
      t.value && (t.value.innerHTML = t.value.innerHTML.trim(), x5.highlightAll());
    }), (r, i) => (E(), F("div", null, [
      O("pre", {
        class: de([`language-${e.language}`, { "line-numbers": e.showLineNumbers }])
      }, [
        nn("      "),
        O("code", {
          ref_key: "codeRef",
          ref: t
        }, re(r.code), 513),
        nn(`
    `)
      ], 2)
    ]));
  }
});
const S5 = /* @__PURE__ */ J(k5, [["__scopeId", "data-v-eb431f8a"]]), A5 = /* @__PURE__ */ K({
  __name: "Divider",
  props: {
    orientation: { default: "horizontal" },
    borderStyle: { default: "solid" },
    thickness: { default: "regular" }
  },
  setup(n) {
    return (e, t) => (E(), F("div", {
      class: de([e.orientation, e.borderStyle, e.thickness])
    }, null, 2));
  }
});
const E5 = /* @__PURE__ */ J(A5, [["__scopeId", "data-v-316d6e1c"]]), T5 = (n) => (Ye("data-v-25fa4832"), n = n(), Xe(), n), M5 = {
  key: 0,
  class: "content"
}, O5 = {
  key: 1,
  class: "media pulse"
}, F5 = /* @__PURE__ */ T5(() => /* @__PURE__ */ O("i", { class: "i-youcan:image icon" }, null, -1)), I5 = [
  F5
], R5 = /* @__PURE__ */ K({
  __name: "Skeleton",
  props: {
    type: { default: "text" },
    lines: { default: 5 }
  },
  setup(n) {
    return (e, t) => (E(), F(ze, null, [
      e.type === "text" ? (E(), F("div", M5, [
        (E(!0), F(ze, null, Je(e.lines, (r) => (E(), F("div", {
          key: r,
          class: "pulse"
        }, [
          O("div", {
            class: de(["line", { "last-line": r === e.lines }])
          }, null, 2)
        ]))), 128))
      ])) : ne("", !0),
      e.type === "media" ? (E(), F("div", O5, I5)) : ne("", !0)
    ], 64));
  }
});
const N5 = /* @__PURE__ */ J(R5, [["__scopeId", "data-v-25fa4832"]]), B5 = (n) => (Ye("data-v-e6921c24"), n = n(), Xe(), n), $5 = { class: "container" }, L5 = /* @__PURE__ */ B5(() => /* @__PURE__ */ O("div", { class: "spinner" }, null, -1)), P5 = {
  key: 0,
  class: "label"
}, z5 = /* @__PURE__ */ K({
  __name: "Spinner",
  props: {
    label: {},
    size: { default: "40px" },
    color: { default: "var(--brand-300)" },
    labelColor: { default: "var(--brand-500)" },
    labelFontSize: { default: "md" }
  },
  setup(n) {
    return Zn((e) => ({
      a3d8c7ba: e.labelColor,
      "5c3ea829": `var(--text-${e.labelFontSize}-regular)`,
      "43a99255": e.size,
      "30a9c78f": e.color
    })), (e, t) => (E(), F("div", $5, [
      L5,
      e.label ? (E(), F("p", P5, re(e.label), 1)) : ne("", !0)
    ]));
  }
});
const cp = /* @__PURE__ */ J(z5, [["__scopeId", "data-v-e6921c24"]]), V5 = ["disabled"], H5 = {
  key: 1,
  class: "label"
}, W5 = /* @__PURE__ */ K({
  __name: "SwitchButton",
  props: {
    active: { type: Boolean },
    option: {}
  },
  emits: ["click"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = () => {
      r("click", t.option);
    };
    return (s, o) => (E(), F("button", {
      class: de(["option", { active: s.active, disabled: s.option.disabled }]),
      disabled: s.option.disabled || s.active,
      onClick: i
    }, [
      s.option.icon ? (E(), F("i", {
        key: 0,
        class: de(s.option.icon)
      }, null, 2)) : ne("", !0),
      s.option.label ? (E(), F("span", H5, re(t.option.label), 1)) : ne("", !0)
    ], 10, V5));
  }
});
const Hb = /* @__PURE__ */ J(W5, [["__scopeId", "data-v-5f557170"]]), U5 = { class: "list" }, j5 = /* @__PURE__ */ K({
  __name: "MultiSwitch",
  props: {
    options: {},
    selectedOption: {}
  },
  emits: ["update:selectedOption"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = G(t.selectedOption), s = (o) => {
      i.value = o, r("update:selectedOption", o);
    };
    return (o, l) => (E(), F("div", U5, [
      (E(!0), F(ze, null, Je(o.options, (u) => {
        var d;
        return E(), ge(Hb, {
          key: u.value,
          option: u,
          active: ((d = i.value) == null ? void 0 : d.value) === u.value,
          onClick: (f) => s(u)
        }, null, 8, ["option", "active", "onClick"]);
      }), 128))
    ]));
  }
});
const q5 = /* @__PURE__ */ J(j5, [["__scopeId", "data-v-870810bd"]]), Yv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Dropdown: n0,
  DropdownList: Cu,
  Note: nA,
  Loading: uA,
  Checkbox: ho,
  PrimaryButton: Ca,
  SecondaryButton: Zr,
  PrimaryDestructiveButton: a0,
  SecondaryDestructiveButton: hE,
  TertiaryButton: rn,
  Input: ss,
  InputGroup: NE,
  ColorPicker: _f,
  ColorInput: D0,
  Toggle: C0,
  TextArea: bM,
  Rating: Af,
  RatingInput: kM,
  Badge: Ef,
  Thumbnail: mo,
  FileInput: UM,
  UploadedFile: tO,
  MediaInput: lO,
  UploadedMedia: vO,
  Increment: E0,
  Tag: OO,
  MultiselectDropdown: BO,
  StaticStatus: T0,
  EditableStatus: M0,
  DatePicker: F0,
  DateInput: c2,
  DropdownPrefix: l0,
  Percentage: I0,
  Tab: m2,
  TabsBar: b2,
  Sidebar: E2,
  SidebarItem: N2,
  SidebarSubitem: L2,
  Topbar: U2,
  ActionBar: G2,
  SettingsNav: eF,
  SettingsNavItem: sF,
  Table: CF,
  PaginationBar: MF,
  SearchInput: iI,
  Alert: $0,
  Toast: fI,
  DraggableItem: P0,
  Draggable: TI,
  Radio: z0,
  RadioGroup: BI,
  RadioList: WI,
  RichText: x8,
  Tooltip: $d,
  Slider: N8,
  Modal: K8,
  ResourcePicker: h5,
  Popover: D5,
  Code: S5,
  Divider: E5,
  Skeleton: N5,
  Spinner: cp,
  MultiSwitch: q5,
  SwitchButton: Hb
}, Symbol.toStringTag, { value: "Module" }));
function K5(n) {
  for (const e in Yv)
    n.component(e, Yv[e]);
}
const e6 = { install: K5 };
export {
  G2 as ActionBar,
  $0 as Alert,
  Ef as Badge,
  ho as Checkbox,
  S5 as Code,
  D0 as ColorInput,
  _f as ColorPicker,
  c2 as DateInput,
  F0 as DatePicker,
  E5 as Divider,
  TI as Draggable,
  P0 as DraggableItem,
  n0 as Dropdown,
  Cu as DropdownList,
  l0 as DropdownPrefix,
  M0 as EditableStatus,
  UM as FileInput,
  E0 as Increment,
  ss as Input,
  NE as InputGroup,
  uA as Loading,
  lO as MediaInput,
  K8 as Modal,
  q5 as MultiSwitch,
  BO as MultiselectDropdown,
  nA as Note,
  MF as PaginationBar,
  I0 as Percentage,
  D5 as Popover,
  Ca as PrimaryButton,
  a0 as PrimaryDestructiveButton,
  z0 as Radio,
  BI as RadioGroup,
  WI as RadioList,
  Af as Rating,
  kM as RatingInput,
  h5 as ResourcePicker,
  x8 as RichText,
  iI as SearchInput,
  Zr as SecondaryButton,
  hE as SecondaryDestructiveButton,
  eF as SettingsNav,
  sF as SettingsNavItem,
  E2 as Sidebar,
  N2 as SidebarItem,
  L2 as SidebarSubitem,
  N5 as Skeleton,
  N8 as Slider,
  cp as Spinner,
  T0 as StaticStatus,
  Hb as SwitchButton,
  m2 as Tab,
  CF as Table,
  b2 as TabsBar,
  OO as Tag,
  rn as TertiaryButton,
  bM as TextArea,
  mo as Thumbnail,
  fI as Toast,
  C0 as Toggle,
  $d as Tooltip,
  U2 as Topbar,
  tO as UploadedFile,
  vO as UploadedMedia,
  e6 as default
};
